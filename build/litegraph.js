var He = Object.defineProperty;
var De = (n) => {
  throw TypeError(n);
};
var Ve = (n, t, r) => t in n ? He(n, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : n[t] = r;
var g = (n, t, r) => Ve(n, typeof t != "symbol" ? t + "" : t, r), Xe = (n, t, r) => t.has(n) || De("Cannot " + r);
var Se = (n, t, r) => t.has(n) ? De("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, r);
var oe = (n, t, r) => (Xe(n, t, "access private method"), r);
class LLink {
  /**
   * Create a link object.
   * @param {string} id - The unique identifier of the link.
   * @param {string} type - The type of the link.
   * @param {string} origin_id - The identifier of the origin node.
   * @param {string} origin_slot - The slot of the origin node the link is connected to.
   * @param {string} target_id - The identifier of the target node.
   * @param {string} target_slot - The slot of the target node the link is connected to.
   */
  constructor(t, r, s, a, o, u) {
    this.id = t, this.type = r, this.origin_id = s, this.origin_slot = a, this.target_id = o, this.target_slot = u, this._data = null, this._pos = new Float32Array(2);
  }
  /**
   * Configure the link object with new data.
   * @param {Array|Object} o - An array or object containing link data to configure.
   */
  configure(t) {
    t.constructor === Array ? (this.id = t[0], this.origin_id = t[1], this.origin_slot = t[2], this.target_id = t[3], this.target_slot = t[4], this.type = t[5]) : (this.id = t.id, this.type = t.type, this.origin_id = t.origin_id, this.origin_slot = t.origin_slot, this.target_id = t.target_id, this.target_slot = t.target_slot);
  }
  /**
   * Serialize the link object to an array.
   * @returns {Array} An array containing the serialized link data.
   */
  serialize() {
    return [
      this.id,
      this.origin_id,
      this.origin_slot,
      this.target_id,
      this.target_slot,
      this.type
    ];
  }
}
const wt = class wt {
  /**
   * @constructor
   * @param {Object} o data from previous serialization [optional]} o
   */
  constructor(t) {
    var r;
    (r = LiteGraph.log) == null || r.call(LiteGraph, "Graph created"), this.list_of_graphcanvas = null, this.clear(), t && this.configure(t);
  }
  /**
   * Gets the supported types of the LGraph class, falling back to the default supported types if not defined for the instance.
   * @returns {Array} An array of supported types for the LGraph class.
   */
  getSupportedTypes() {
    var t;
    return (t = this.supported_types) != null ? t : wt.supported_types;
  }
  /**
   * Removes all nodes from this graph
   * @method clear
   */
  clear() {
    var t;
    this.stop(), this.status = wt.STATUS_STOPPED, this.last_node_id = 0, this.last_link_id = 0, this._version = -1, (t = this._nodes) == null || t.forEach((r) => {
      var s;
      (s = r.onRemoved) == null || s.call(r);
    }), this._nodes = [], this._nodes_by_id = {}, this._nodes_in_order = [], this._nodes_executable = null, this._groups = [], this.links = {}, this.iteration = 0, this.config = {}, this.configApplyDefaults(), this.vars = {}, this.extra = {}, this.globaltime = 0, this.runningtime = 0, this.fixedtime = 0, this.fixedtime_lapse = 0.01, this.elapsed_time = 0.01, this.last_update_time = 0, this.starttime = 0, this.catch_errors = !0, this.history = {
      actionHistory: [],
      actionHistoryVersions: [],
      actionHistoryPtr: 0
    }, this.nodes_executing = [], this.nodes_actioning = [], this.node_ancestorsCalculated = [], this.nodes_executedAction = [], this.inputs = {}, this.outputs = {}, this.change(), this.sendActionToCanvas("clear");
  }
  /**
  * Apply config values to LGraph config object
  * @method configApply
   * @param {object} opts options to merge
  */
  configApply(t) {
    this.config = Object.assign(this.config, t);
  }
  /**
  * Apply config values to LGraph config object
  * @method configApply
   * @param {object} opts options to merge
  */
  configApplyDefaults() {
    var t = LiteGraph.graphDefaultConfig;
    this.configApply(t);
  }
  /**
   * Attach Canvas to this graph
   * @method attachCanvas
   * @param {GraphCanvas} graph_canvas
   */
  attachCanvas(t) {
    var r;
    if (!t instanceof LiteGraph.LGraphCanvas)
      throw new Error("attachCanvas expects a LiteGraph.LGraphCanvas instance");
    t.graph && t.graph != this && t.graph.detachCanvas(t), t.graph = this, (r = this.list_of_graphcanvas) != null || (this.list_of_graphcanvas = []), this.list_of_graphcanvas.push(t);
  }
  /**
   * Detach Canvas from this graph
   * @method detachCanvas
   * @param {GraphCanvas} graph_canvas
   */
  detachCanvas(t) {
    if (this.list_of_graphcanvas) {
      var r = this.list_of_graphcanvas.indexOf(t);
      r != -1 && (t.graph = null, this.list_of_graphcanvas.splice(r, 1));
    }
  }
  /**
   * Starts running this graph every interval milliseconds.
   * @method start
   * @param {number} interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
   */
  start(t = 0) {
    var s;
    if (this.status === wt.STATUS_RUNNING)
      return;
    this.status = wt.STATUS_RUNNING, (s = this.onPlayEvent) == null || s.call(this), this.sendEventToAllNodes("onStart"), this.starttime = LiteGraph.getTime(), this.last_update_time = this.starttime;
    const r = () => {
      var a, o;
      this.execution_timer_id === -1 && (window.requestAnimationFrame(r), (a = this.onBeforeStep) == null || a.call(this), this.runStep(1, !this.catch_errors), (o = this.onAfterStep) == null || o.call(this));
    };
    t === 0 && typeof window == "object" && window.requestAnimationFrame ? (this.execution_timer_id = -1, r()) : this.execution_timer_id = setInterval(() => {
      var a, o;
      (a = this.onBeforeStep) == null || a.call(this), this.runStep(1, !this.catch_errors), (o = this.onAfterStep) == null || o.call(this);
    }, t);
  }
  /**
   * Stops the execution loop of the graph
   * @method stop execution
   */
  stop() {
    var t;
    this.status != wt.STATUS_STOPPED && (this.status = wt.STATUS_STOPPED, (t = this.onStopEvent) == null || t.call(this), this.execution_timer_id != null && (this.execution_timer_id != -1 && clearInterval(this.execution_timer_id), this.execution_timer_id = null), this.sendEventToAllNodes("onStop"));
  }
  /**
   * Run N steps (cycles) of the graph
   * @method runStep
   * @param {number} num number of steps to run, default is 1
   * @param {Boolean} do_not_catch_errors [optional] if you want to try/catch errors
   * @param {number} limit max number of nodes to execute (used to execute from start to a node)
   */
  runStep(t = 1, r, s) {
    var l, c, d, f, _, E;
    var a = LiteGraph.getTime();
    this.globaltime = 1e-3 * (a - this.starttime);
    var o = (l = this._nodes_executable) != null ? l : this._nodes;
    if (o) {
      if (s || (s = o.length), r) {
        for (let m = 0; m < t; m++)
          o.forEach((T) => {
            var L, G;
            LiteGraph.use_deferred_actions && ((L = T._waiting_actions) != null && L.length) && T.executePendingActions(), T.mode === LiteGraph.ALWAYS && ((G = T.doExecute) == null || G.call(T));
          }), this.fixedtime += this.fixedtime_lapse, (c = this.onExecuteStep) == null || c.call(this);
        (d = this.onAfterExecute) == null || d.call(this);
      } else
        try {
          for (let m = 0; m < t; m++)
            o.forEach((T) => {
              var L, G;
              LiteGraph.use_deferred_actions && ((L = T._waiting_actions) != null && L.length) && T.executePendingActions(), T.mode === LiteGraph.ALWAYS && ((G = T.doExecute) == null || G.call(T));
            }), this.fixedtime += this.fixedtime_lapse, (f = this.onExecuteStep) == null || f.call(this);
          (_ = this.onAfterExecute) == null || _.call(this), this.errors_in_execution = !1;
        } catch (m) {
          if (this.errors_in_execution = !0, LiteGraph.throw_errors)
            throw m;
          (E = LiteGraph.log) == null || E.call(LiteGraph, `Error during execution: ${m}`), this.stop();
        }
      var u = LiteGraph.getTime(), h = u - a;
      h == 0 && (h = 1), this.execution_time = 1e-3 * h, this.globaltime += 1e-3 * h, this.iteration += 1, this.elapsed_time = (u - this.last_update_time) * 1e-3, this.last_update_time = u, this.nodes_executing = [], this.nodes_actioning = [], this.node_ancestorsCalculated = [], this.nodes_executedAction = [];
    }
  }
  /**
   * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
   * nodes with only inputs.
   * @method updateExecutionOrder
   */
  updateExecutionOrder() {
    this._nodes_in_order = this.computeExecutionOrder(!1), this._nodes_executable = [];
    for (var t = 0; t < this._nodes_in_order.length; ++t)
      this._nodes_in_order[t].onExecute && this._nodes_executable.push(this._nodes_in_order[t]);
  }
  /**
   * Computes the execution order of nodes in the flow graph based on their connections and levels.
   * @param {boolean} only_onExecute - Indicates whether to consider only nodes with an onExecute method.
   * @param {boolean} set_level - If true, assigns levels to the nodes based on their connections.
   * @returns {Array} An array of nodes in the calculated execution order.
   *
   * @TODO:This whole concept is a mistake.  Should call graph back from output nodes
   */
  computeExecutionOrder(t, r) {
    var E;
    var s = [], a = [], o = {}, u = {}, h = {};
    for (let m = 0, T = this._nodes.length; m < T; ++m) {
      let L = this._nodes[m];
      if (!(t && !L.onExecute)) {
        o[L.id] = L;
        var l = 0;
        if (L.inputs)
          for (var c = 0, d = L.inputs.length; c < d; c++)
            L.inputs[c] && L.inputs[c].link != null && (l += 1);
        l == 0 ? (a.push(L), r && (L._level = 1)) : (r && (L._level = 0), h[L.id] = l);
      }
    }
    for (; a.length != 0; ) {
      var f = a.shift();
      if (s.push(f), delete o[f.id], !!f.outputs)
        for (let m = 0; m < f.outputs.length; m++) {
          let T = f.outputs[m];
          if (!(T == null || T.links == null || T.links.length == 0))
            for (let L = 0; L < T.links.length; L++) {
              let G = T.links[L], O = this.links[G];
              if (!O || u[O.id])
                continue;
              let b = this.getNodeById(O.target_id);
              if (b == null) {
                u[O.id] = !0;
                continue;
              }
              r && (!b._level || b._level <= f._level) && (b._level = f._level + 1), u[O.id] = !0, h[b.id] -= 1, h[b.id] == 0 && a.push(b);
            }
        }
    }
    for (let m in o)
      s.push(o[m]);
    s.length != this._nodes.length && LiteGraph.debug && ((E = LiteGraph.warn) == null || E.call(LiteGraph, "something went wrong, nodes missing"));
    var _ = s.length;
    for (let m = 0; m < _; ++m)
      s[m].order = m;
    s = s.sort((m, T) => {
      let L = m.constructor.priority || m.priority || 0, G = T.constructor.priority || T.priority || 0;
      return L == G ? m.order - T.order : L - G;
    });
    for (let m = 0; m < _; ++m)
      s[m].order = m;
    return s;
  }
  /**
   * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs recursively.
   * It doesn't include the node itself
   * @method getAncestors
   * @return {Array} an array with all the LiteGraph.LGraphNodes that affect this node, in order of execution
   */
  getAncestors(t, r = {}) {
    for (var s = {
      modesSkip: [],
      modesOnly: [],
      typesSkip: [],
      typesOnly: []
    }, a = Object.assign(s, r), o = [], u = [], h = [t], l = {}; h.length; ) {
      var c = h.shift();
      if (c && !l[c.id]) {
        if (l[c.id] = !0, c.id != t.id) {
          if (a.modesSkip && a.modesSkip.length && a.modesSkip.indexOf(c.mode) != -1 || a.modesOnly && a.modesOnly.length && a.modesOnly.indexOf(c.mode) == -1)
            continue;
          u.indexOf(c.id) == -1 && (o.push(c), u.push(c.id));
        }
        if (c.inputs)
          for (var d = 0; d < c.inputs.length; ++d) {
            var f = c.getInputNode(d);
            if (f) {
              var _ = c.inputs[d].type;
              a.typesSkip && a.typesSkip.length && a.typesSkip.indexOf(_) != -1 || a.typesOnly && a.typesOnly.length && a.typesOnly.indexOf(f.mode) == -1 || u.indexOf(f.id) == -1 && (l[f.id] || h.push(f));
            }
          }
      }
    }
    return o.sort((E, m) => E.order - m.order), o;
  }
  /**
   * Positions every node in a more readable manner
   * @method arrange
   */
  arrange(t = 100, r) {
    var u;
    const s = this.computeExecutionOrder(!1, !0), a = [];
    for (let h = 0; h < s.length; ++h) {
      const l = s[h], c = l._level || 1;
      (u = a[c]) != null || (a[c] = []), a[c].push(l);
    }
    let o = t;
    for (let h = 0; h < a.length; ++h) {
      const l = a[h];
      if (!l)
        continue;
      let c = 100, d = t + LiteGraph.NODE_TITLE_HEIGHT;
      for (let f = 0; f < l.length; ++f) {
        const _ = l[f];
        _.pos[0] = r == LiteGraph.VERTICAL_LAYOUT ? d : o, _.pos[1] = r == LiteGraph.VERTICAL_LAYOUT ? o : d;
        const E = r == LiteGraph.VERTICAL_LAYOUT ? 1 : 0;
        _.size[E] > c && (c = _.size[E]);
        const m = r == LiteGraph.VERTICAL_LAYOUT ? 0 : 1;
        d += _.size[m] + t + LiteGraph.NODE_TITLE_HEIGHT;
      }
      o += c + t;
    }
    this.setDirtyCanvas(!0, !0);
  }
  /**
   * Returns the amount of time the graph has been running in milliseconds
   * @method getTime
   * @return {number} number of milliseconds the graph has been running
   */
  getTime() {
    return this.globaltime;
  }
  /**
   * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in context where the time increments should be constant
   * @method getFixedTime
   * @return {number} number of milliseconds the graph has been running
   */
  getFixedTime() {
    return this.fixedtime;
  }
  /**
   * Returns the amount of time it took to compute the latest iteration. Take into account that this number could be not correct
   * if the nodes are using graphical actions
   * @method getElapsedTime
   * @return {number} number of milliseconds it took the last cycle
   */
  getElapsedTime() {
    return this.elapsed_time;
  }
  /**
   * Sends an event to all the nodes, useful to trigger stuff
   * @method sendEventToAllNodes
   * @param {String} eventname the name of the event (function to be called)
   * @param {Array} params parameters in array format
   */
  sendEventToAllNodes(t, r, s = LiteGraph.ALWAYS) {
    var a = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (a)
      for (let o = 0, u = a.length; o < u; ++o) {
        const h = a[o];
        if (h.constructor === LiteGraph.Subgraph && t !== "onExecute") {
          h.mode == s && h.sendEventToAllNodes(t, r, s);
          continue;
        }
        !h[t] || h.mode !== s || (r === void 0 ? h[t]() : Array.isArray(r) ? h[t].apply(h, r) : h[t](r));
      }
  }
  /**
   * Sends an action with parameters to the connected GraphCanvas instances for processing.
   * @param {string} action - The action to be performed on the GraphCanvas instances.
   * @param {Array} params - An array of parameters to be passed to the action method.
   */
  sendActionToCanvas(t, r) {
    if (this.list_of_graphcanvas)
      for (const s of this.list_of_graphcanvas)
        s[t] && r && s[t](...r);
  }
  /**
   * Adds a new node instance to this graph
   * @method add
   * @param {LiteGraph.LGraphNode} node the instance of the node
   */
  add(t, r, s = {}) {
    var u, h, l;
    var a = {
      doProcessChange: !0,
      doCalcSize: !0
    }, o = Object.assign(a, s);
    if (t) {
      if (t.constructor === LiteGraph.LGraphGroup) {
        this._groups.push(t), this.setDirtyCanvas(!0), this.change(), t.graph = this, this.onGraphChanged({ action: "groupAdd", doSave: o.doProcessChange });
        return;
      }
      if (t.id != -1 && this._nodes_by_id[t.id] != null && ((u = LiteGraph.warn) == null || u.call(LiteGraph, "LiteGraph: there is already a node with this ID, changing it"), LiteGraph.use_uuids ? t.id = LiteGraph.uuidv4() : t.id = ++this.last_node_id), this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES)
        throw new Error("LiteGraph: max number of nodes in a graph reached");
      return LiteGraph.use_uuids ? (t.id == null || t.id == -1) && (t.id = LiteGraph.uuidv4()) : t.id == null || t.id == -1 ? t.id = ++this.last_node_id : this.last_node_id < t.id && (this.last_node_id = t.id), t.graph = this, this.onGraphChanged({ action: "nodeAdd", doSave: o.doProcessChange }), this._nodes.push(t), this._nodes_by_id[t.id] = t, (h = t.onAdded) == null || h.call(t, this), this.config.align_to_grid && t.alignToGrid(), r || this.updateExecutionOrder(), (l = this.onNodeAdded) == null || l.call(this, t), o.doCalcSize && t.setSize(t.computeSize()), this.setDirtyCanvas(!0), this.change(), t;
    }
  }
  /**
   * Removes a node from the graph
   * @method remove
   * @param {LiteGraph.LGraphNode} node the instance of the node
   */
  remove(t) {
    var a, o;
    if (t.constructor === LiteGraph.LGraphGroup) {
      var r = this._groups.indexOf(t);
      r != -1 && this._groups.splice(r, 1), t.graph = null, this.onGraphChanged({ action: "groupRemove" }), this.setDirtyCanvas(!0, !0), this.change();
      return;
    }
    if (this._nodes_by_id[t.id] != null && !t.ignore_remove) {
      if (t.inputs)
        for (let u = 0; u < t.inputs.length; u++)
          t.inputs[u].link != null && t.disconnectInput(u, { doProcessChange: !1 });
      if (t.outputs)
        for (let u = 0; u < t.outputs.length; u++) {
          let h = t.outputs[u];
          h.links != null && h.links.length && t.disconnectOutput(u, !1, { doProcessChange: !1 });
        }
      if ((a = t.onRemoved) == null || a.call(t), t.graph = null, this.onGraphChanged({ action: "nodeRemove" }), this.list_of_graphcanvas)
        for (let u = 0; u < this.list_of_graphcanvas.length; ++u) {
          let h = this.list_of_graphcanvas[u];
          h.selected_nodes[t.id] && delete h.selected_nodes[t.id], h.node_dragged == t && (h.node_dragged = null);
        }
      var s = this._nodes.indexOf(t);
      s != -1 && this._nodes.splice(s, 1), delete this._nodes_by_id[t.id], (o = this.onNodeRemoved) == null || o.call(this, t), this.sendActionToCanvas("checkPanels"), this.setDirtyCanvas(!0, !0), this.change(), this.updateExecutionOrder();
    }
  }
  /**
   * Returns a node by its id.
   * @method getNodeById
   * @param {Number} id
   */
  getNodeById(t) {
    return t == null ? null : this._nodes_by_id[t];
  }
  /**
   * Returns a list of nodes that matches a class
   * @method findNodesByClass
   * @param {Class} classObject the class itself (not an string)
   * @return {Array} a list with all the nodes of this type
   */
  findNodesByClass(t, r = []) {
    return r = this._nodes.filter((s) => s.constructor === t), r;
  }
  /**
   * Returns a list of nodes that matches a type
   * @method findNodesByType
   * @param {String} type the name of the node type
   * @return {Array} a list with all the nodes of this type
   */
  findNodesByType(t, r = []) {
    const s = t.toLowerCase();
    return r = this._nodes.filter((a) => a.type.toLowerCase() === s), r;
  }
  /**
   * Returns the first node that matches a name in its title
   * @method findNodeByTitle
   * @param {String} name the name of the node to search
   * @return {Node} the node or null
   */
  findNodeByTitle(t) {
    var r;
    return (r = this._nodes.find((s) => s.title === t)) != null ? r : null;
  }
  /**
   * Returns a list of nodes that matches a name
   * @method findNodesByTitle
   * @param {String} name the name of the node to search
   * @return {Array} a list with all the nodes with this name
   */
  findNodesByTitle(t) {
    return this._nodes.filter((r) => r.title === t);
  }
  /**
   * Returns the top-most node in this position of the canvas
   * @method getNodeOnPos
   * @param {number} x the x coordinate in canvas space
   * @param {number} y the y coordinate in canvas space
   * @param {Array} nodes_list a list with all the nodes to search from, by default is all the nodes in the graph
   * @return {LiteGraph.LGraphNode} the node at this position or null
   */
  getNodeOnPos(t, r, s = this._nodes, a = 0) {
    var o;
    return (o = s.reverse().find((u) => u.isPointInside(t, r, a))) != null ? o : null;
  }
  /**
   * Returns the top-most group in that position
   * @method getGroupOnPos
   * @param {number} x the x coordinate in canvas space
   * @param {number} y the y coordinate in canvas space
   * @return {LiteGraph.LGraphGroup} the group or null
   */
  getGroupOnPos(t, r) {
    var s;
    return (s = this._groups.find((a) => a.isPointInside(t, r, 2, !0))) != null ? s : null;
  }
  /**
   * Checks that the node type matches the node type registered, used when replacing a nodetype by a newer version during execution
   * this replaces the ones using the old version with the new version
   * @method checkNodeTypes
   */
  checkNodeTypes() {
    var o;
    for (var t = 0; t < this._nodes.length; t++) {
      var r = this._nodes[t], s = LiteGraph.registered_node_types[r.type];
      if (r.constructor != s) {
        LiteGraph.debug && ((o = LiteGraph.log) == null || o.call(LiteGraph, `node being replaced by newer version: ${r.type}`));
        var a = LiteGraph.createNode(r.type);
        this._nodes[t] = a, a.configure(r.serialize()), a.graph = this, this._nodes_by_id[a.id] = a, r.inputs && (a.inputs = r.inputs.concat()), r.outputs && (a.outputs = r.outputs.concat());
      }
    }
    this.updateExecutionOrder();
  }
  /**
   * Executes an action on the GraphInput nodes based on the provided action name and parameters.
   * @param {string} action - The name of the action to be executed on the GraphInput nodes.
   * @param {any} param - The parameter to pass to the action method.
   * @param {object} options - Additional options for the action.
   */
  onAction(t, r, s) {
    this._input_nodes = this.findNodesByClass(
      LiteGraph.GraphInput,
      this._input_nodes
    );
    for (var a = 0; a < this._input_nodes.length; ++a) {
      var o = this._input_nodes[a];
      if (o.properties.name == t) {
        o.actionDo(t, r, s);
        break;
      }
    }
  }
  trigger(t, r) {
    var s;
    (s = this.onTrigger) == null || s.call(this, t, r);
  }
  /**
   * Tell this graph it has a global graph input of this type
   * @method addGlobalInput
   * @param {String} name
   * @param {String} type
   * @param {*} value [optional]
   */
  addInput(t, r, s) {
    var o, u;
    var a = this.inputs[t];
    a || (this.beforeChange(), this.inputs[t] = { name: t, type: r, value: s }, this.onGraphChanged({ action: "addInput" }), this.afterChange(), (o = this.onInputAdded) == null || o.call(this, t, r), (u = this.onInputsOutputsChange) == null || u.call(this));
  }
  /**
   * Assign a data to the global graph input
   * @method setGlobalInputData
   * @param {String} name
   * @param {*} data
   */
  setInputData(t, r) {
    var s = this.inputs[t];
    s && (s.value = r);
  }
  /**
   * Returns the current value of a global graph input
   * @method getInputData
   * @param {String} name
   * @return {*} the data
   */
  getInputData(t) {
    var r = this.inputs[t];
    return r ? r.value : null;
  }
  /**
   * Changes the name of a global graph input
   * @method renameInput
   * @param {String} old_name
   * @param {String} new_name
   */
  renameInput(t, r) {
    var s, a, o;
    if (r != t) {
      if (!this.inputs[t])
        return !1;
      if (this.inputs[r])
        return (s = LiteGraph.error) == null || s.call(LiteGraph, "there is already one input with that name"), !1;
      this.inputs[r] = this.inputs[t], delete this.inputs[t], this.onGraphChanged({ action: "renameInput" }), (a = this.onInputRenamed) == null || a.call(this, t, r), (o = this.onInputsOutputsChange) == null || o.call(this);
    }
  }
  /**
   * Changes the type of a global graph input
   * @method changeInputType
   * @param {String} name
   * @param {String} type
   */
  changeInputType(t, r) {
    var s;
    if (!this.inputs[t])
      return !1;
    this.inputs[t].type && String(this.inputs[t].type).toLowerCase() == String(r).toLowerCase() || (this.inputs[t].type = r, this.onGraphChanged({ action: "changeInputType" }), (s = this.onInputTypeChanged) == null || s.call(this, t, r));
  }
  /**
   * Removes a global graph input
   * @method removeInput
   * @param {String} name
   * @param {String} type
   */
  removeInput(t) {
    var r, s;
    return this.inputs[t] ? (delete this.inputs[t], this.onGraphChanged({ action: "graphRemoveInput" }), (r = this.onInputRemoved) == null || r.call(this, t), (s = this.onInputsOutputsChange) == null || s.call(this), !0) : !1;
  }
  /**
   * Creates a global graph output
   * @method addOutput
   * @param {String} name
   * @param {String} type
   * @param {*} value
   */
  addOutput(t, r, s) {
    var a, o;
    this.outputs[t] = { name: t, type: r, value: s }, this.onGraphChanged({ action: "addOutput" }), (a = this.onOutputAdded) == null || a.call(this, t, r), (o = this.onInputsOutputsChange) == null || o.call(this);
  }
  /**
   * Assign a data to the global output
   * @method setOutputData
   * @param {String} name
   * @param {String} value
   */
  setOutputData(t, r) {
    var s = this.outputs[t];
    s && (s.value = r);
  }
  /**
   * Returns the current value of a global graph output
   * @method getOutputData
   * @param {String} name
   * @return {*} the data
   */
  getOutputData(t) {
    var r = this.outputs[t];
    return r ? r.value : null;
  }
  /**
   * Renames a global graph output
   * @method renameOutput
   * @param {String} old_name
   * @param {String} new_name
   */
  renameOutput(t, r) {
    var s, a, o;
    if (!this.outputs[t])
      return !1;
    if (this.outputs[r])
      return (s = LiteGraph.error) == null || s.call(LiteGraph, "there is already one output with that name"), !1;
    this.outputs[r] = this.outputs[t], delete this.outputs[t], this._version++, (a = this.onOutputRenamed) == null || a.call(this, t, r), (o = this.onInputsOutputsChange) == null || o.call(this);
  }
  /**
   * Changes the type of a global graph output
   * @method changeOutputType
   * @param {String} name
   * @param {String} type
   */
  changeOutputType(t, r) {
    var s;
    if (!this.outputs[t])
      return !1;
    this.outputs[t].type && String(this.outputs[t].type).toLowerCase() == String(r).toLowerCase() || (this.outputs[t].type = r, this.onGraphChanged({ action: "changeOutputType" }), (s = this.onOutputTypeChanged) == null || s.call(this, t, r));
  }
  /**
   * Removes a global graph output
   * @method removeOutput
   * @param {String} name
   */
  removeOutput(t) {
    var r, s;
    return this.outputs[t] ? (delete this.outputs[t], this.onGraphChanged({ action: "removeOutput" }), (r = this.onOutputRemoved) == null || r.call(this, t), (s = this.onInputsOutputsChange) == null || s.call(this), !0) : !1;
  }
  /**
   * Triggers the 'onTrigger' method on nodes with a specific title by passing a value to them.
   * @param {string} name - The title of the nodes to trigger.
   * @param {any} value - The value to pass to the 'onTrigger' method of the nodes.
   */
  triggerInput(t, r) {
    for (var s = this.findNodesByTitle(t), a = 0; a < s.length; ++a)
      s[a].onTrigger(r);
  }
  /**
   * Sets a callback function on nodes with a specific title by invoking their 'setTrigger' method.
   * @param {string} name - The title of the nodes to set the callback function on.
   * @param {Function} func - The callback function to be set on the nodes.
   */
  setCallback(t, r) {
    for (var s = this.findNodesByTitle(t), a = 0; a < s.length; ++a)
      s[a].setTrigger(r);
  }
  /**
   * Executes actions before a change with the provided information detail.
   * Calls the 'onBeforeChange' function on the class instance and sends the action to connected GraphCanvas instances.
   * @param {object} info - The information detail about the change.
   */
  beforeChange(t) {
    var r;
    (r = this.onBeforeChange) == null || r.call(this, this, t), this.sendActionToCanvas("onBeforeChange", this);
  }
  /**
   * Executes actions after a change with the provided information detail.
   * Calls the 'onAfterChange' function on the class instance and sends the action to connected GraphCanvas instances.
   * @param {object} info - The information detail about the change.
   */
  afterChange(t) {
    var r;
    (r = this.onAfterChange) == null || r.call(this, this, t), this.sendActionToCanvas("onAfterChange", this);
  }
  /**
   * Handles changes in node connections and triggers related actions.
   * Updates the execution order, calls the 'onConnectionChange' function on the class instance and connected GraphCanvas instances, and increments the version.
   * @param {object} node - The node where the connection change occurred.
   * @param {object} link_info - Information about the changed connection.
   */
  connectionChange(t) {
    var r;
    this.updateExecutionOrder(), (r = this.onConnectionChange) == null || r.call(this, t), this.onGraphChanged({ action: "connectionChange", doSave: !1 }), this.sendActionToCanvas("onConnectionChange");
  }
  /**
   * returns if the graph is in live mode
   * @method isLive
   */
  isLive() {
    if (!this.list_of_graphcanvas)
      return !1;
    for (var t = 0; t < this.list_of_graphcanvas.length; ++t) {
      var r = this.list_of_graphcanvas[t];
      if (r.live_mode)
        return !0;
    }
    return !1;
  }
  /**
   * clears the triggered slot animation in all links (stop visual animation)
   * @method clearTriggeredSlots
   */
  clearTriggeredSlots() {
    for (var t in this.links) {
      var r = this.links[t];
      r && r._last_time && (r._last_time = 0);
    }
  }
  /**
   * Indicates a visual change in the graph (not the structure) and triggers related actions.
   * Logs a message if in debug mode, sends a 'setDirty' action with parameters to connected GraphCanvas instances, and calls the 'on_change' function on the class instance.
   * @method change
   */
  change() {
    var t, r;
    (t = LiteGraph.log) == null || t.call(LiteGraph, "Graph visually changed"), this.sendActionToCanvas("setDirty", [!0, !0]), (r = this.on_change) == null || r.call(this, this);
  }
  setDirtyCanvas(t, r) {
    this.sendActionToCanvas("setDirty", [t, r]);
  }
  /**
   * Destroys a link
   * @method removeLink
   * @param {Number} link_id
   */
  removeLink(t) {
    var r = this.links[t];
    if (r) {
      var s = this.getNodeById(r.target_id);
      s && (this.beforeChange(), s.disconnectInput(r.target_slot), this.afterChange());
    }
  }
  /**
   * Creates a Object containing all the info about this graph, it can be serialized
   * @method serialize
   * @return {Object} value of the node
   */
  serialize() {
    var c, d;
    const t = this._nodes.map((f) => f.serialize());
    var r = [];
    for (var s in this.links) {
      var a = this.links[s];
      if (!a.serialize) {
        (c = LiteGraph.warn) == null || c.call(LiteGraph, "weird LLink bug, link info is not a LLink but a regular object");
        var o = new LiteGraph.LLink();
        for (var u in a)
          o[u] = a[u];
        this.links[s] = o, a = o;
      }
      r.push(a.serialize());
    }
    const h = this._groups.map((f) => f.serialize());
    var l = {
      last_node_id: this.last_node_id,
      last_link_id: this.last_link_id,
      nodes: t,
      links: r,
      groups: h,
      config: this.config,
      extra: this.extra,
      version: LiteGraph.VERSION
    };
    return (d = this.onSerialize) == null || d.call(this, l), l;
  }
  /**
   * Configure a graph from a JSON string
   * @method configure
   * @param {String} str configure a graph from a JSON string
   * @param {Boolean} returns if there was any error parsing
   */
  configure(t, r) {
    var f, _, E, m, T;
    if (t) {
      r || this.clear();
      var s = t.nodes;
      if (t.links && t.links.constructor === Array) {
        for (var a = [], o = 0; o < t.links.length; ++o) {
          var u = t.links[o];
          if (!u) {
            (f = LiteGraph.warn) == null || f.call(LiteGraph, "serialized graph link data contains errors, skipping.");
            continue;
          }
          var h = new LiteGraph.LLink();
          h.configure(u), a[h.id] = h;
        }
        t.links = a;
      }
      for (let L in t)
        ["nodes", "groups"].includes(L) || (this[L] = t[L]);
      var l = !1;
      if (this._nodes = [], s) {
        for (let L = 0, G = s.length; L < G; ++L) {
          var c = s[L], d = LiteGraph.createNode(c.type, c.title);
          d || ((_ = LiteGraph.log) == null || _.call(LiteGraph, `Node not found or has errors: ${c.type}`), d = new LiteGraph.LGraphNode(), d.last_serialization = c, d.has_errors = !0, l = !0), d.id = c.id, this.add(d, !0, { doProcessChange: !1 });
        }
        s.forEach((L) => {
          const G = this.getNodeById(L.id);
          G == null || G.configure(L);
        });
      }
      return this._groups.length = 0, t.groups && t.groups.forEach((L) => {
        const G = new LiteGraph.LGraphGroup();
        G.configure(L), this.add(G, !0, { doProcessChange: !1 });
      }), this.updateExecutionOrder(), this.extra = (E = t.extra) != null ? E : {}, (m = this.onConfigure) == null || m.call(this, t), t._version ? (T = LiteGraph.debug) == null || T.call(LiteGraph, "skip onGraphChanged when configure passing version too!") : this.onGraphChanged({ action: "graphConfigure", doSave: !1 }), this.setDirtyCanvas(!0, !0), l;
    }
  }
  /**
   * Loads graph data from a given URL or file and configures the graph accordingly.
   * @param {string | File | Blob} url - The URL or file to load the graph data from.
   * @param {Function} callback - An optional callback function to be executed after loading and configuring the graph.
   */
  load(t, r) {
    var s = this;
    if (t.constructor === File || t.constructor === Blob) {
      var a = new FileReader();
      a.addEventListener("load", (u) => {
        var h = JSON.parse(u.target.result);
        s.configure(h), r == null || r();
      }), a.readAsText(t);
      return;
    }
    var o = new XMLHttpRequest();
    o.open("GET", t, !0), o.send(null), o.onload = (u) => {
      var l;
      if (o.status !== 200) {
        (l = LiteGraph.error) == null || l.call(LiteGraph, "Error loading graph:", o.status, o.response);
        return;
      }
      var h = JSON.parse(o.response);
      s.configure(h), r == null || r();
    }, o.onerror = (u) => {
      var h;
      (h = LiteGraph.error) == null || h.call(LiteGraph, "Error loading graph:", u);
    };
  }
  /**
  * Meant to serve the history-saving mechanism
  * @method onGraphSaved
  * @param {object} optsIn options
  */
  onGraphSaved(t = {}) {
    var r = {};
    Object.assign(r, t), this.savedVersion = this._version;
  }
  /**
  * Meant to serve the history-saving mechanism
  * @method onGraphSaved
  * @param {object} optsIn options
  */
  onGraphLoaded(t = {}) {
    var r = {};
    Object.assign(r, t), this.savedVersion = this._version;
  }
  /**
  * Ment to be the history and prevent-exit mechanism, call to change _version
  * @method onGraphChanged
  * @param {object} optsIn options
  */
  onGraphChanged(t = {}) {
    var h, l, c, d, f, _;
    var r = {
      action: "",
      doSave: !0,
      // log action in graph.history
      doSaveGraph: !0
      // save
    }, s = Object.assign(r, t);
    if (this._version++, s.action ? (h = LiteGraph.debug) == null || h.call(LiteGraph, "Graph change", s.action) : (l = LiteGraph.debug) == null || l.call(LiteGraph, "Graph change, no action", s), s.doSave && LiteGraph.actionHistory_enabled) {
      (c = LiteGraph.debug) == null || c.call(LiteGraph, "onGraphChanged SAVE :: " + s.action);
      var a = { actionName: s.action };
      s.doSaveGraph && (a = Object.assign(
        a,
        { graphSave: this.serialize() }
        // this is a heavy method, but the alternative is way more complex: every action has to have its contrary
      ));
      for (var o = this.history; o.actionHistoryPtr < o.actionHistoryVersions.length - 1; )
        (d = LiteGraph.debug) == null || d.call(LiteGraph, "popping: gone back? " + (o.actionHistoryPtr + " < " + (o.actionHistoryVersions.length - 1))), o.actionHistoryVersions.pop();
      if (o.actionHistoryVersions.length >= LiteGraph.actionHistoryMaxSave) {
        var u = o.actionHistoryVersions.shift();
        (f = LiteGraph.debug) == null || f.call(LiteGraph, "maximum saves reached: " + o.actionHistoryVersions.length + ", remove older: " + u), o.actionHistory[u] = !1;
      }
      o.actionHistoryPtr = o.actionHistoryVersions.length, o.actionHistoryVersions.push(o.actionHistoryPtr), o.actionHistory[o.actionHistoryPtr] = a, (_ = LiteGraph.debug) == null || _.call(LiteGraph, "history saved: " + o.actionHistoryPtr, a.actionName);
    }
  }
  /**
  * Go back in action history
  * @method actionHistoryBack
  * @param {object} optsIn options
  */
  actionHistoryBack(t = {}) {
    var a, o, u, h, l;
    var r = {};
    Object.assign(r, t);
    var s = this.history;
    return s.actionHistoryPtr != null && s.actionHistoryPtr >= 0 ? (s.actionHistoryPtr--, (a = LiteGraph.debug) == null || a.call(LiteGraph, "history step back: " + s.actionHistoryPtr), this.actionHistoryLoad({ iVersion: s.actionHistoryPtr }) ? ((u = LiteGraph.debug) == null || u.call(LiteGraph, "history loaded back: " + s.actionHistoryPtr), (h = LiteGraph.debug) == null || h.call(LiteGraph, this.history), !0) : ((o = LiteGraph.warn) == null || o.call(LiteGraph, "historyLoad failed, restore pointer? " + s.actionHistoryPtr), s.actionHistoryPtr++, !1)) : ((l = LiteGraph.debug) == null || l.call(LiteGraph, "history is already at older state"), !1);
  }
  /**
  * Go forward in action history
  * @method actionHistoryForward
  * @param {object} optsIn options
  */
  actionHistoryForward(t = {}) {
    var a, o, u, h;
    var r = {};
    Object.assign(r, t);
    var s = this.history;
    return s.actionHistoryPtr < s.actionHistoryVersions.length ? (s.actionHistoryPtr++, (a = LiteGraph.debug) == null || a.call(LiteGraph, "history step forward: " + s.actionHistoryPtr), this.actionHistoryLoad({ iVersion: s.actionHistoryPtr }) ? ((u = LiteGraph.debug) == null || u.call(LiteGraph, "history loaded forward: " + s.actionHistoryPtr), !0) : ((o = LiteGraph.warn) == null || o.call(LiteGraph, "historyLoad failed, restore pointer? " + s.actionHistoryPtr), s.actionHistoryPtr--, !1)) : ((h = LiteGraph.debug) == null || h.call(LiteGraph, "history is already at newer state"), !1);
  }
  /**
  * Load from action history
  * @method actionHistoryLoad
  * @param {object} optsIn options
  */
  actionHistoryLoad(t = {}) {
    var u;
    var r = {
      iVersion: !1,
      backStep: !1
    }, s = Object.assign(r, t), a = this.history;
    if (a.actionHistory[s.iVersion] && a.actionHistory[s.iVersion].graphSave) {
      var o = JSON.stringify(this.history);
      return this.configure(a.actionHistory[s.iVersion].graphSave), this.history = JSON.parse(o), (u = LiteGraph.debug) == null || u.call(LiteGraph, "history loaded: " + s.iVersion, a.actionHistory[s.iVersion].actionName), !0;
    } else
      return !1;
  }
};
// default supported types
g(wt, "supported_types", ["number", "string", "boolean"]), g(wt, "STATUS_STOPPED", 1), g(wt, "STATUS_RUNNING", 2);
let LGraph = wt;
class LGraphNode {
  constructor(t = "Unnamed") {
    this.title = t, this.size = [LiteGraph.NODE_WIDTH, 60], this.graph = null, this._pos = new Float32Array(10, 10), LiteGraph.use_uuids ? this.id = LiteGraph.uuidv4() : this.id = -1, this.type = null, this.inputs = [], this.outputs = [], this.connections = [], this.properties = {}, this.properties_info = [], this.flags = {};
  }
  set pos(t) {
    var r;
    !t || t.length < 2 || ((r = this._pos) != null || (this._pos = new Float32Array(10, 10)), this._pos[0] = t[0], this._pos[1] = t[1]);
  }
  get pos() {
    return this._pos;
  }
  /**
   * configure a node from an object containing the serialized info
   * @method configure
   */
  configure(t) {
    var r, s, a, o, u;
    Object.entries(t).forEach(([h, l]) => {
      var d;
      if (h === "properties") {
        for (var c in l)
          this.properties[c] = l[c], (d = this.onPropertyChanged) == null || d.call(this, c, l[c]);
        return;
      }
      l !== null && (typeof l == "object" ? this[h] && this[h].configure ? this[h].configure(l) : this[h] = LiteGraph.cloneObject(l, this[h]) : this[h] = l);
    }), t.title || (this.title = this.constructor.title), (r = this.inputs) == null || r.forEach((h, l) => {
      var d, f;
      if (!h.link)
        return;
      const c = this.graph ? this.graph.links[h.link] : null;
      (d = this.onConnectionsChange) == null || d.call(this, LiteGraph.INPUT, l, !0, c, h), (f = this.onInputAdded) == null || f.call(this, h);
    }), (s = this.outputs) == null || s.forEach((h, l) => {
      var c;
      h.links && (h.links.forEach(() => {
        var f;
        const d = this.graph;
        (f = this.onConnectionsChange) == null || f.call(this, LiteGraph.OUTPUT, l, !0, d, h);
      }), (c = this.onOutputAdded) == null || c.call(this, h));
    }), this.widgets && (this.widgets.forEach((h) => {
      h && h.options && h.options.property && this.properties[h.options.property] !== void 0 && (h.value = JSON.parse(JSON.stringify(this.properties[h.options.property])));
    }), (a = t.widgets_values) == null || a.forEach((h, l) => {
      this.widgets[l] && (this.widgets[l].value = h);
    })), (o = this.onConfigure) == null || o.call(this, t), (u = this.graph) == null || u.onGraphChanged({ action: "nodeConfigure", doSave: !1 });
  }
  /**
   * serialize the content
   * @method serialize
   */
  serialize() {
    var r, s, a;
    var t = {
      id: this.id,
      type: this.type,
      pos: this.pos,
      size: this.size,
      flags: LiteGraph.cloneObject(this.flags),
      order: this.order,
      mode: this.mode
    };
    return this.constructor === LGraphNode && this.last_serialization ? this.last_serialization : (this.inputs && (t.inputs = LiteGraph.cloneObject(this.inputs)), this.outputs && (this.outputs.forEach((o) => {
      delete o._data;
    }), t.outputs = LiteGraph.cloneObject(this.outputs)), this.title && this.title != this.constructor.title && (t.title = this.title), this.properties && (t.properties = LiteGraph.cloneObject(this.properties)), this.widgets && this.serialize_widgets && (t.widgets_values = this.widgets.map((o) => {
      var u;
      return (u = o == null ? void 0 : o.value) != null ? u : null;
    })), (r = t.type) != null || (t.type = this.constructor.type), this.color && (t.color = this.color), this.bgcolor && (t.bgcolor = this.bgcolor), this.boxcolor && (t.boxcolor = this.boxcolor), this.shape && (t.shape = this.shape), (s = this.onSerialize) != null && s.call(this, t) && ((a = LiteGraph.warn) == null || a.call(LiteGraph, "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter")), t);
  }
  /* Creates a clone of this node */
  clone() {
    var s, a;
    var t = LiteGraph.createNode(this.type);
    if (!t)
      return null;
    var r = LiteGraph.cloneObject(this.serialize());
    return (s = r.inputs) == null || s.forEach((o) => {
      o.link = null;
    }), (a = r.outputs) == null || a.forEach((o) => {
      o.links && (o.links.length = 0);
    }), delete r.id, LiteGraph.use_uuids && (r.id = LiteGraph.uuidv4()), t.configure(r), t;
  }
  /**
   * serialize and stringify
   * @method toString
   */
  toString() {
    return JSON.stringify(this.serialize());
  }
  // LGraphNode.prototype.deserialize = function(info) {} //this cannot be done from within, must be done in LiteGraph
  /**
   * get the title string
   * @method getTitle
   */
  getTitle() {
    var t;
    return (t = this.title) != null ? t : this.constructor.title;
  }
  /**
   * sets the value of a property
   * @method setProperty
   * @param {String} name
   * @param {*} value
   */
  setProperty(t, r) {
    var o, u;
    if (this.properties || (this.properties = {}), r === this.properties[t])
      return;
    const s = this.properties[t];
    this.properties[t] = r, ((o = this.onPropertyChanged) == null ? void 0 : o.call(this, t, r, s)) === !1 && (this.properties[t] = s);
    const a = (u = this.widgets) == null ? void 0 : u.find((h) => {
      var l;
      return h && ((l = h.options) == null ? void 0 : l.property) === t;
    });
    a && (a.value = r);
  }
  // Execution *************************
  /**
   * sets the output data
   * @method setOutputData
   * @param {number} slot
   * @param {*} data
   */
  setOutputData(t, r) {
    var a;
    if (this.outputs) {
      if ((t == null ? void 0 : t.constructor) === String)
        t = this.findOutputSlot(t);
      else if (t == -1 || t >= this.outputs.length)
        return;
      var s = this.outputs[t];
      s && (s._data = r, (a = this.outputs[t].links) == null || a.forEach((o) => {
        const u = this.graph.links[o];
        u && (u.data = r);
      }));
    }
  }
  /**
   * sets the output data type, useful when you want to be able to overwrite the data type
   * @method setOutputDataType
   * @param {number} slot
   * @param {String} datatype
   */
  setOutputDataType(t, r) {
    var a, o;
    if (this.outputs && !(t == -1 || t >= this.outputs.length)) {
      var s = this.outputs[t];
      s && (s.type = r, (o = (a = this.outputs[t]) == null ? void 0 : a.links) == null || o.forEach((u) => {
        this.graph.links[u] && (this.graph.links[u].type = r);
      }));
    }
  }
  /**
   * Retrieves the input data (data traveling through the connection) from one slot
   * @method getInputData
   * @param {number} slot
   * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
   * @return {*} data or if it is not connected returns undefined
   */
  getInputData(t, r, s) {
    var c;
    if (this.inputs && !(t >= this.inputs.length || this.inputs[t].link == null)) {
      var a = this.inputs[t].link, o = this.graph.links[a];
      if (!o)
        return null;
      if (!r)
        return o.data;
      var u = this.graph.getNodeById(o.origin_id);
      if (!u)
        return o.data;
      if (s) {
        var h = this.id + "_getInputData_forced_" + Math.floor(Math.random() * 9999), l = { action: h, options: { action_call: h } };
        this.refreshAncestors(l);
      }
      return u.updateOutputData ? u.updateOutputData(o.origin_slot) : (c = u.doExecute) == null || c.call(u), o.data;
    }
  }
  /**
   * Retrieves the input data type (in case this supports multiple input types)
   * @method getInputDataType
   * @param {number} slot
   * @return {String} datatype in string format
   */
  getInputDataType(t) {
    if (!this.inputs || t >= this.inputs.length || this.inputs[t].link == null)
      return null;
    var r = this.inputs[t].link, s = this.graph.links[r];
    if (!s)
      return null;
    var a = this.graph.getNodeById(s.origin_id);
    if (!a)
      return s.type;
    var o = a.outputs[s.origin_slot];
    return o ? o.type : null;
  }
  /**
   * Retrieves the input data from one slot using its name instead of slot number
   * @method getInputDataByName
   * @param {String} slot_name
   * @param {boolean} force_update if set to true it will force the connected node of this slot to output data into this link
   * @return {*} data or if it is not connected returns null
   */
  getInputDataByName(t, r) {
    var s = this.findInputSlot(t);
    return s == -1 ? null : this.getInputData(s, r);
  }
  /**
   * tells you if there is a connection in one input slot
   * @method isInputConnected
   * @param {number} slot
   * @return {boolean}
   */
  isInputConnected(t) {
    return this.inputs ? t < this.inputs.length && this.inputs[t].link != null : !1;
  }
  /**
   * tells you info about an input connection (which node, type, etc)
   * @method getInputInfo
   * @param {number} slot
   * @return {Object} object or null { link: id, name: string, type: string or 0 }
   */
  getInputInfo(t) {
    return this.inputs && t < this.inputs.length ? this.inputs[t] : null;
  }
  /**
   * Returns the link info in the connection of an input slot
   * @method getInputLink
   * @param {number} slot
   * @return {LiteGraph.LLink} object or null
   */
  getInputLink(t) {
    if (!this.inputs)
      return null;
    if (t < this.inputs.length) {
      var r = this.inputs[t];
      return this.graph.links[r.link];
    }
    return null;
  }
  /**
   * returns the node connected in the input slot
   * @method getInputNode
   * @param {number} slot
   * @return {LGraphNode} node or null
   */
  getInputNode(t) {
    if (!this.inputs || t >= this.inputs.length)
      return null;
    var r = this.inputs[t];
    if (!r || r.link === null)
      return null;
    var s = this.graph.links[r.link];
    return s ? this.graph.getNodeById(s.origin_id) : null;
  }
  /**
   * returns the value of an input with this name, otherwise checks if there is a property with that name
   * @method getInputOrProperty
   * @param {string} name
   * @return {*} value
   */
  getInputOrProperty(t) {
    if (this.inputs)
      for (var r = 0, s = this.inputs.length; r < s; ++r) {
        var a = this.inputs[r];
        if (t == a.name && a.link != null) {
          var o = this.graph.links[a.link];
          if (o)
            return o.data;
        }
      }
    return this.properties ? this.properties[t] : null;
  }
  /**
   * tells you the last output data that went in that slot
   * @method getOutputData
   * @param {number} slot
   * @return {Object}  object or null
   */
  getOutputData(t) {
    if (!this.outputs || t >= this.outputs.length)
      return null;
    var r = this.outputs[t];
    return r._data;
  }
  /**
   * tells you info about an output connection (which node, type, etc)
   * @method getOutputInfo
   * @param {number} slot
   * @return {Object}  object or null { name: string, type: string, links: [ ids of links in number ] }
   */
  getOutputInfo(t) {
    return this.outputs && t < this.outputs.length ? this.outputs[t] : null;
  }
  /**
   * tells you if there is a connection in one output slot
   * @method isOutputConnected
   * @param {number} slot
   * @return {boolean}
   */
  isOutputConnected(t) {
    return this.outputs ? t < this.outputs.length && this.outputs[t].links && this.outputs[t].links.length : !1;
  }
  /**
   * tells you if there is any connection in the output slots
   * @method isAnyOutputConnected
   * @return {boolean}
   */
  isAnyOutputConnected() {
    return this.outputs ? this.outputs.some((t) => t.links && t.links.length) : !1;
  }
  /**
   * retrieves all the nodes connected to this output slot
   * @method getOutputNodes
   * @param {number} slot
   * @return {array}
   */
  getOutputNodes(t) {
    if (!this.outputs || t >= this.outputs.length)
      return null;
    const r = this.outputs[t];
    return !r.links || r.links.length === 0 ? null : r.links.map((s) => this.graph.links[s]).filter((s) => s).map((s) => this.graph.getNodeById(s.target_id)).filter((s) => s);
  }
  addOnTriggerInput() {
    var t = this.findInputSlot("onTrigger");
    return t == -1 ? (this.addInput("onTrigger", LiteGraph.EVENT, { removable: !0, nameLocked: !0 }), this.findInputSlot("onTrigger")) : t;
  }
  addOnExecutedOutput() {
    var t = this.findOutputSlot("onExecuted");
    return t == -1 ? (this.addOutput("onExecuted", LiteGraph.ACTION, { removable: !0, nameLocked: !0 }), this.findOutputSlot("onExecuted")) : t;
  }
  onAfterExecuteNode(t, r) {
    var a;
    var s = this.findOutputSlot("onExecuted");
    s != -1 && ((a = LiteGraph.debug) == null || a.call(LiteGraph, this.id + ":" + this.order + " triggering slot onAfterExecute", t, r), this.triggerSlot(s, t, null, r));
  }
  changeMode(t) {
    switch (t) {
      case LiteGraph.ON_TRIGGER:
        this.addOnTriggerInput(), this.addOnExecutedOutput();
        break;
      case LiteGraph.ON_EVENT:
        break;
      case LiteGraph.NEVER:
        break;
      case LiteGraph.ALWAYS:
        break;
      case LiteGraph.ON_REQUEST:
        break;
      default:
        return !1;
    }
    return this.mode = t, !0;
  }
  /**
   * Triggers the execution of actions that were deferred when the action was triggered
   * @method executePendingActions
   */
  executePendingActions() {
    !this._waiting_actions || !this._waiting_actions.length || (this._waiting_actions.forEach((t) => {
      this.onAction(t[0], t[1], t[2], t[3], t[4]);
    }), this._waiting_actions.length = 0);
  }
  /**
   * Triggers the node code execution, place a boolean/counter to mark the node as being executed
   * @method doExecute
   * @param {*} param
   * @param {*} options
   */
  doExecute(t, r = {}) {
    var s, a, o, u, h;
    if (this.onExecute) {
      if ((s = r.action_call) != null || (r.action_call = `${this.id}_exec_${Math.floor(Math.random() * 9999)}`), this.graph.nodes_executing && this.graph.nodes_executing[this.id]) {
        (a = LiteGraph.debug) == null || a.call(LiteGraph, "NODE already executing! Prevent! " + this.id + ":" + this.order);
        return;
      }
      if (LiteGraph.ensureNodeSingleExecution && this.exec_version && this.exec_version >= this.graph.iteration && this.exec_version !== void 0) {
        (o = LiteGraph.debug) == null || o.call(LiteGraph, "!! NODE already EXECUTED THIS STEP !! " + this.exec_version);
        return;
      }
      if (LiteGraph.ensureUniqueExecutionAndActionCall && this.graph.nodes_executedAction[this.id] && r && r.action_call && this.graph.nodes_executedAction[this.id] == r.action_call) {
        (u = LiteGraph.debug) == null || u.call(LiteGraph, "!! NODE already ACTION THIS STEP !! " + r.action_call);
        return;
      }
      this.graph.nodes_executing[this.id] = !0, this.onExecute(t, r), this.graph.nodes_executing[this.id] = !1, this.exec_version = this.graph.iteration, r && r.action_call && (this.action_call = r.action_call, this.graph.nodes_executedAction[this.id] = r.action_call);
    }
    this.execute_triggered = 2, (h = this.onAfterExecuteNode) == null || h.call(this, t, r);
  }
  /**
   * retrocompatibility :: old doExecute
   * @method doExecute
   * @param {*} param
   * @param {*} options
   */
  execute(t, r = {}) {
    return this.doExecute(t, r);
  }
  /**
   * Triggers an action, wrapped by logics to control execution flow
   * @method actionDo
   * @param {String} action name
   * @param {*} param
   */
  actionDo(t, r, s = {}, a) {
    var o, u, h, l;
    if (this.onAction) {
      if ((o = s.action_call) != null || (s.action_call = `${this.id}_${t || "action"}_${Math.floor(Math.random() * 9999)}`), LiteGraph.ensureNodeSingleAction && this.graph.nodes_actioning && this.graph.nodes_actioning[this.id] == s.action_call)
        return;
      if ((u = LiteGraph.debug) == null || u.call(LiteGraph, "CheckActioned ? " + this.id + ":" + this.order + " :: " + this.action_call), LiteGraph.ensureUniqueExecutionAndActionCall && this.graph.nodes_executedAction[this.id] && s && s.action_call && this.graph.nodes_executedAction[this.id] == s.action_call) {
        (h = LiteGraph.debug) == null || h.call(LiteGraph, "!! NODE already ACTION THIS STEP !! " + s.action_call), ;
        return;
      }
      this.graph.nodes_actioning[this.id] = t || "actioning", this.onAction(t, r, s, a), this.graph.nodes_actioning[this.id] = !1, s && s.action_call && (this.action_call = s.action_call, this.graph.nodes_executedAction[this.id] = s.action_call);
    }
    this.action_triggered = 2, (l = this.onAfterExecuteNode) == null || l.call(this, r, s);
  }
  /**
   * Triggers an event in this node, this will trigger any output with the same name
   * @method trigger
   * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the event is send to all
   * @param {*} param
   */
  trigger(t, r, s) {
    !this.outputs || this.outputs.length === 0 || (this.graph && (this.graph._last_trigger_time = LiteGraph.getTime()), this.outputs.forEach((a, o) => {
      a && a.type === LiteGraph.EVENT && (!t || a.name === t) && this.triggerSlot(o, r, null, s);
    }));
  }
  /**
   * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes
   * @method triggerSlot
   * @param {Number} slot the index of the output slot
   * @param {*} param
   * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
   */
  triggerSlot(t, r, s, a = {}) {
    var f, _, E, m;
    if (this.outputs) {
      if (t == null) {
        (f = LiteGraph.error) == null || f.call(LiteGraph, "triggerSlot", "slot must be a number");
        return;
      }
      t.constructor !== Number && ((_ = LiteGraph.warn) == null || _.call(LiteGraph, "triggerSlot", "slot must be a number, use node.trigger('name') if you want to use a string"));
      var o = this.outputs[t];
      if (o) {
        var u = o.links;
        if (!(!u || !u.length) && !(this.graph && this.graph.ancestorsCall)) {
          this.graph && (this.graph._last_trigger_time = LiteGraph.getTime());
          for (var h = 0; h < u.length; ++h) {
            var l = u[h];
            if (!(s != null && s != l)) {
              var c = this.graph.links[u[h]];
              if (c) {
                c._last_time = LiteGraph.getTime();
                var d = this.graph.getNodeById(c.target_id);
                if (d) {
                  if (d.mode === LiteGraph.ON_TRIGGER)
                    a.action_call || (a.action_call = `${this.id}_trigg_${Math.floor(Math.random() * 9999)}`), LiteGraph.refreshAncestorsOnTriggers && d.refreshAncestors({ action: "trigger", param: r, options: a }), d.onExecute && d.doExecute(r, a);
                  else if (d.onAction) {
                    a.action_call || (a.action_call = `${this.id}_act_${Math.floor(Math.random() * 9999)}`);
                    let T = d.inputs[c.target_slot];
                    (E = LiteGraph.debug) == null || E.call(LiteGraph, "triggerSlot", "will call onACTION: " + this.id + ":" + this.order + " :: " + T.name), LiteGraph.refreshAncestorsOnActions && d.refreshAncestors({ action: T.name, param: r, options: a }), LiteGraph.use_deferred_actions && d.onExecute ? ((m = d._waiting_actions) != null || (d._waiting_actions = []), d._waiting_actions.push([T.name, r, a, c.target_slot])) : d.actionDo(T.name, r, a, c.target_slot);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  /**
   * clears the trigger slot animation
   * @method clearTriggeredSlot
   * @param {Number} slot the index of the output slot
   * @param {Number} link_id [optional] in case you want to trigger and specific output link in a slot
   */
  clearTriggeredSlot(t, r) {
    !this.outputs || !this.outputs[t] || !this.outputs[t].links || this.outputs[t].links.forEach((s) => {
      if (r !== null && r !== s)
        return;
      const a = this.graph.links[s];
      a && (a._last_time = 0);
    });
  }
  /**
   * changes node size and triggers callback
   * @method setSize
   * @param {vec2} size
   */
  setSize(t) {
    var r;
    this.size = t, (r = this.onResize) == null || r.call(this, this.size);
  }
  /**
   * add a new property to this node
   * @method addProperty
   * @param {string} name
   * @param {*} default_value
   * @param {string} type string defining the output type ("vec3","number",...)
   * @param {Object} extra_info this can be used to have special properties of the property (like values, etc)
   */
  addProperty(t, r, s, a) {
    var u, h;
    const o = { name: t, type: s, default_value: r, ...a };
    return this.properties_info = (u = this.properties_info) != null ? u : [], this.properties_info.push(o), this.properties = (h = this.properties) != null ? h : {}, this.properties[t] = r, o;
  }
  /**
   * Add a new input or output slot to use in this node.
   * @param {string} name - Name of the slot.
   * @param {string} type - Type of the slot ("vec3", "number", etc). For a generic type, use "0".
   * @param {Object} extra_info - Additional information for the slot (e.g., label, color, position).
   * @param {boolean} isInput - Whether the slot being added is an input slot.
   * @returns {Object} The newly added slot (input or output).
   *
   * @NOTE: These methods are slightly different, and it would be optimal to keep them separate,
   * but our goal here is to refactor them so they *aren't* slightly different.
   */
  addInput(t, r, s) {
    return this.addSlot(t, r, s, !0);
  }
  addOutput(t, r, s) {
    return this.addSlot(t, r, s, !1);
  }
  addSlot(t, r, s, a) {
    var u, h, l, c;
    const o = a ? { name: t, type: r, link: null, ...s } : { name: t, type: r, links: null, ...s };
    return a ? (this.inputs = (u = this.inputs) != null ? u : [], this.inputs.push(o), (h = this.onInputAdded) == null || h.call(this, o), LiteGraph.registerNodeAndSlotType(this, r)) : (this.outputs = (l = this.outputs) != null ? l : [], this.outputs.push(o), (c = this.onOutputAdded) == null || c.call(this, o), LiteGraph.auto_load_slot_types && LiteGraph.registerNodeAndSlotType(this, r, !0)), this.setSize(this.computeSize()), this.setDirtyCanvas(!0, !0), o;
  }
  /**
   * Add multiple input or output slots to use in this node.
   * @param {Array} array - Array of triplets like [[name, type, extra_info], [...]].
   * @param {boolean} isInput - Whether the slots being added are input slots.
   *
   * @NOTE: These methods are slightly different, and it would be optimal to keep them separate,
   * but our goal here is to refactor them so they *aren't* slightly different.
   */
  addInputs(t) {
    this.addSlots(t, !0);
  }
  addOutputs(t) {
    this.addSlots(t, !1);
  }
  addSlots(t, r) {
    var s;
    typeof t == "string" && (t = [t]), t.forEach((a) => {
      var u, h, l, c, d, f;
      const o = r ? {
        name: a[0],
        type: a[1],
        link: null,
        ...(u = a[2]) != null ? u : {}
      } : {
        name: a[0],
        type: a[1],
        links: null,
        ...(h = a[2]) != null ? h : {}
      };
      r ? (this.inputs = (l = this.inputs) != null ? l : [], this.inputs.push(o), (c = this.onInputAdded) == null || c.call(this, o), LiteGraph.registerNodeAndSlotType(this, a[1])) : (this.outputs = (d = this.outputs) != null ? d : [], this.outputs.push(o), (f = this.onOutputAdded) == null || f.call(this, o), LiteGraph.auto_load_slot_types && LiteGraph.registerNodeAndSlotType(this, a[1], !0));
    }), this.setSize(this.computeSize()), (s = this.setDirtyCanvas) == null || s.call(this, !0, !0);
  }
  /**
   * remove an existing input slot
   * @method removeInput
   * @param {number} slot
   *
   * @NOTE: These two are different enough yet I can't even mash them together meaningfully.
   */
  removeInput(t) {
    var s;
    this.disconnectInput(t);
    const r = this.inputs.splice(t, 1)[0];
    this.inputs.slice(t).filter((a) => !!a).forEach((a) => {
      const o = this.graph.links[a.link];
      o != null && o.target_slot && o.target_slot--;
    }), this.setSize(this.computeSize()), (s = this.onInputRemoved) == null || s.call(this, t, r), this.setDirtyCanvas(!0, !0);
  }
  /**
   * remove an existing output slot
   * @method removeOutput
   * @param {number} slot
   */
  removeOutput(t) {
    var r;
    this.disconnectOutput(t), this.outputs = this.outputs.filter((s, a) => a !== t), this.outputs.slice(t).forEach((s) => {
      !s || !s.links || s.links.forEach((a) => {
        const o = this.graph.links[a];
        o && (o.origin_slot -= 1);
      });
    }), this.setSize(this.computeSize()), (r = this.onOutputRemoved) == null || r.call(this, t), this.setDirtyCanvas(!0, !0);
  }
  /**
   * Add a special connection to this node (used for special kinds of graphs)
   * @method addConnection
   * @param {string} name - The name of the connection
   * @param {string} type - String defining the input type ("vec3", "number", etc.)
   * @param {Float32[]} pos - Position of the connection inside the node as an array [x, y]
   * @param {string} direction - Specifies if it is an input or output connection
   */
  addConnection(t, r, s, a) {
    var o = {
      name: t,
      type: r,
      pos: s,
      direction: a,
      links: null
    };
    return this.connections.push(o), o;
  }
  /**
   * computes the minimum size of a node according to its inputs and output slots
   * @method computeSize
   * @param {vec2} minHeight
   * @return {vec2} the total size
   */
  computeSize(t) {
    if (this.constructor.size)
      return this.constructor.size.concat();
    var r = t || new Float32Array([0, 0]), s = LiteGraph.NODE_TEXT_SIZE;
    const a = (_) => _ ? s * _.length * 0.6 : 0;
    var o = a(this.title), u = 0, h = 0;
    this.inputs && (u = this.inputs.reduce((_, E) => {
      const m = E.label || E.name || "", T = a(m);
      return Math.max(_, T);
    }, 0)), this.outputs && (h = this.outputs.reduce((_, E) => {
      const m = E.label || E.name || "", T = a(m);
      return Math.max(_, T);
    }, 0)), r[0] = Math.max(u + h + 10, o), r[0] = Math.max(r[0], LiteGraph.NODE_WIDTH), this.widgets && this.widgets.length && (r[0] = Math.max(r[0], LiteGraph.NODE_WIDTH * 1.5));
    const l = Math.max(
      this.inputs ? this.inputs.length : 1,
      this.outputs ? this.outputs.length : 1,
      1
    ) * LiteGraph.NODE_SLOT_HEIGHT;
    r[1] = l + (this.constructor.slot_start_y || 0);
    let c = 0;
    if (this.widgets && this.widgets.length) {
      for (var d = 0, f = this.widgets.length; d < f; ++d)
        this.widgets[d].computeSize ? c += this.widgets[d].computeSize(r[0])[1] + 4 : c += LiteGraph.NODE_WIDGET_HEIGHT + 4;
      c += 8;
    }
    return this.widgets_up ? r[1] = Math.max(r[1], c) : this.widgets_start_y != null ? r[1] = Math.max(r[1], c + this.widgets_start_y) : r[1] += c, this.constructor.min_height && r[1] < this.constructor.min_height && (r[1] = this.constructor.min_height), r[1] += 6, r;
  }
  /**
   * returns all the info available about a property of this node.
   *
   * @method getPropertyInfo
   * @param {String} property name of the property
   * @return {Object} the object with all the available info
  */
  getPropertyInfo(t) {
    var r = null;
    if (this.properties_info) {
      for (var s = 0; s < this.properties_info.length; ++s)
        if (this.properties_info[s].name == t) {
          r = this.properties_info[s];
          break;
        }
    }
    return this.constructor[`@${t}`] && (r = this.constructor[`@${t}`]), this.constructor.widgets_info && this.constructor.widgets_info[t] && (r = this.constructor.widgets_info[t]), !r && this.onGetPropertyInfo && (r = this.onGetPropertyInfo(t)), r || (r = {}), r.type || (r.type = typeof this.properties[t]), r.widget == "combo" && (r.type = "enum"), r;
  }
  /**
   * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
   *
   * @method addWidget
   * @param {String} type the widget type (could be "number","string","combo"
   * @param {String} name the text to show on the widget
   * @param {String} value the default value
   * @param {Function|String} callback function to call when it changes (optionally, it can be the name of the property to modify)
   * @param {Object} options the object that contains special properties of this widget
   * @return {Object} the created widget object
   */
  addWidget(t, r, s, a, o) {
    var h, l, c;
    (h = this.widgets) != null || (this.widgets = []), !o && a && a.constructor === Object && (o = a, a = null), o && o.constructor === String && (o = { property: o }), a && a.constructor === String && (o != null || (o = {}), o.property = a, a = null), a && a.constructor !== Function && ((l = LiteGraph.warn) == null || l.call(LiteGraph, "addWidget: callback must be a function"), a = null);
    var u = {
      type: t.toLowerCase(),
      name: r,
      value: s,
      callback: a,
      options: o || {}
    };
    if (u.options.y !== void 0 && (u.y = u.options.y), !a && !u.options.callback && !u.options.property && ((c = LiteGraph.warn) == null || c.call(LiteGraph, "LiteGraph addWidget(...) without a callback or property assigned")), t == "combo" && !u.options.values)
      throw Error("LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }");
    return this.widgets.push(u), this.setSize(this.computeSize()), u;
  }
  addCustomWidget(t) {
    var r;
    return (r = this.widgets) != null || (this.widgets = []), this.widgets.push(t), t;
  }
  /**
   * Returns the bounding box of the object, used for rendering purposes
   * @method getBounding
   * @param {Float32[]} [out] - [Optional] A place to store the output to reduce garbage
   * @param {boolean} [compute_outer] - [Optional] Set to true to include the shadow and connection points in the bounding calculation
   * @return {Float32[]} The bounding box in the format of [topLeftCornerX, topLeftCornerY, width, height]
   */
  getBounding(t = new Float32Array(4), r) {
    const s = this.pos, a = this.flags.collapsed, o = this.size;
    let u = 0, h = 1, l = 0, c = 0;
    return r && (u = 4, h = 6 + u, l = 4, c = 5 + l), t[0] = s[0] - u, t[1] = s[1] - LiteGraph.NODE_TITLE_HEIGHT - l, t[2] = a ? (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + h : o[0] + h, t[3] = a ? LiteGraph.NODE_TITLE_HEIGHT + c : o[1] + LiteGraph.NODE_TITLE_HEIGHT + c, this.onBounding && this.onBounding(t), t;
  }
  /**
   * checks if a point is inside the shape of a node
   * @method isPointInside
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  isPointInside(t, r, s = 0, a) {
    var o = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;
    if (a && (o = 0), this.flags && this.flags.collapsed) {
      if (LiteGraph.isInsideRectangle(
        t,
        r,
        this.pos[0] - s,
        this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - s,
        (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH) + 2 * s,
        LiteGraph.NODE_TITLE_HEIGHT + 2 * s
      ))
        return !0;
    } else if (this.pos[0] - 4 - s < t && this.pos[0] + this.size[0] + 4 + s > t && this.pos[1] - o - s < r && this.pos[1] + this.size[1] + s > r)
      return !0;
    return !1;
  }
  /**
   * checks if a point is inside a node slot, and returns info about which slot
   * @method getSlotInPosition
   * @param {number} x
   * @param {number} y
   * @return {Object} if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
   */
  getSlotInPosition(t, r) {
    var s = new Float32Array(2);
    if (this.inputs)
      for (let a = 0, o = this.inputs.length; a < o; ++a) {
        let u = this.inputs[a];
        if (this.getConnectionPos(!0, a, s), LiteGraph.isInsideRectangle(
          t,
          r,
          s[0] - 10,
          s[1] - 5,
          20,
          10
        ))
          return { input: u, slot: a, link_pos: s };
      }
    if (this.outputs)
      for (let a = 0, o = this.outputs.length; a < o; ++a) {
        let u = this.outputs[a];
        if (this.getConnectionPos(!1, a, s), LiteGraph.isInsideRectangle(
          t,
          r,
          s[0] - 10,
          s[1] - 5,
          20,
          10
        ))
          return { output: u, slot: a, link_pos: s };
      }
    return null;
  }
  /**
   * returns the input slot with a given name (used for dynamic slots), -1 if not found
   * @method findInputSlot
   * @param {string} name the name of the slot
   * @param {boolean} returnObj if the obj itself wanted
   * @return {number_or_object} the slot (-1 if not found)
   */
  findInputSlot(t, r) {
    if (!this.inputs)
      return -1;
    for (var s = 0, a = this.inputs.length; s < a; ++s)
      if (t == this.inputs[s].name)
        return r ? this.inputs[s] : s;
    return -1;
  }
  /**
   * returns the output slot with a given name (used for dynamic slots), -1 if not found
   * @method findOutputSlot
   * @param {string} name the name of the slot
   * @param {boolean} returnObj if the obj itself wanted
   * @return {number_or_object} the slot (-1 if not found)
   */
  findOutputSlot(t, r = !1) {
    if (!this.outputs)
      return -1;
    for (var s = 0, a = this.outputs.length; s < a; ++s)
      if (t == this.outputs[s].name)
        return r ? this.outputs[s] : s;
    return -1;
  }
  // TODO refactor: USE SINGLE findInput/findOutput functions! :: merge options
  /**
   * returns the first free input slot
   * @method findInputSlotFree
   * @param {object} options
   * @return {number_or_object} the slot (-1 if not found)
   */
  findInputSlotFree(t = {}) {
    var r = {
      returnObj: !1,
      typesNotAccepted: []
    }, s = Object.assign(r, t);
    if (!this.inputs)
      return -1;
    for (var a = 0, o = this.inputs.length; a < o; ++a)
      if (!(this.inputs[a].link && this.inputs[a].link != null) && !(s.typesNotAccepted && s.typesNotAccepted.includes && s.typesNotAccepted.includes(this.inputs[a].type)))
        return s.returnObj ? this.inputs[a] : a;
    return -1;
  }
  /**
   * returns the first output slot free
   * @method findOutputSlotFree
   * @param {object} options
   * @return {number_or_object} the slot (-1 if not found)
   */
  findOutputSlotFree(t = {}) {
    var r = {
      returnObj: !1,
      typesNotAccepted: []
    }, s = Object.assign(r, t);
    if (!this.outputs)
      return -1;
    for (let a = 0, o = this.outputs.length; a < o; ++a)
      if (!(this.outputs[a].links && this.outputs[a].links != null) && !(s.typesNotAccepted && s.typesNotAccepted.includes && s.typesNotAccepted.includes(this.outputs[a].type)))
        return s.returnObj ? this.outputs[a] : a;
    return -1;
  }
  /**
   * findSlotByType for INPUTS
   */
  findInputSlotByType(t, r, s, a) {
    return this.findSlotByType(!0, t, r, s, a);
  }
  /**
   * findSlotByType for OUTPUTS
   */
  findOutputSlotByType(t, r, s, a) {
    return this.findSlotByType(!1, t, r, s, a);
  }
  /**
   * returns the output (or input) slot with a given type, -1 if not found
   * @method findSlotByType
   * @param {boolean} input uise inputs instead of outputs
   * @param {string} type the type of the slot
   * @param {boolean} returnObj if the obj itself wanted
   * @param {boolean} preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)
   * @return {number_or_object} the slot (-1 if not found)
   */
  findSlotByType(t = !1, r, s = !1, a = !1, o = !1) {
    var u = t ? this.inputs : this.outputs;
    if (!u)
      return -1;
    (r == "" || r == "*") && (r = 0);
    for (let h = 0, l = u.length; h < l; ++h) {
      let c = (r + "").toLowerCase().split(","), d = u[h].type == "0" || u[h].type == "*" ? "0" : u[h].type;
      d = (d + "").toLowerCase().split(",");
      for (let f = 0; f < c.length; f++)
        for (let _ = 0; _ < d.length; _++)
          if (c[f] == "_event_" && (c[f] = LiteGraph.EVENT), d[f] == "_event_" && (d[f] = LiteGraph.EVENT), c[f] == "*" && (c[f] = 0), d[f] == "*" && (d[f] = 0), c[f] == d[_]) {
            if (a && u[h].links && u[h].links !== null) continue;
            return s ? u[h] : h;
          }
    }
    if (a && !o)
      for (let h = 0, l = u.length; h < l; ++h) {
        let c = (r + "").toLowerCase().split(","), d = u[h].type == "0" || u[h].type == "*" ? "0" : u[h].type;
        d = (d + "").toLowerCase().split(",");
        for (let f = 0; f < c.length; f++)
          for (let _ = 0; _ < d.length; _++)
            if (c[f] == "*" && (c[f] = 0), d[f] == "*" && (d[f] = 0), c[f] == d[_])
              return s ? u[h] : h;
      }
    return -1;
  }
  /**
   * connect this node output to the input of another node BY TYPE
   * @method connectByType
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} node the target node
   * @param {string} target_type the input slot type of the target node
   * @return {Object} the link_info is created, otherwise null
   */
  connectByType(t, r, s = "*", a = {}) {
    var l, c, d, f, _;
    var o = {
      createEventInCase: !0,
      firstFreeIfOutputGeneralInCase: !0,
      generalTypeInCase: !0
    }, u = Object.assign(o, a);
    r && r.constructor === Number && (r = this.graph.getNodeById(r));
    var h = r.findInputSlotByType(s, !1, !0);
    return h >= 0 && h !== null ? ((l = LiteGraph.debug) == null || l.call(LiteGraph, "CONNbyTYPE type " + s + " for " + h), this.connect(t, r, h)) : u.createEventInCase && s == LiteGraph.EVENT ? ((c = LiteGraph.debug) == null || c.call(LiteGraph, "connect WILL CREATE THE onTrigger " + s + " to " + r), this.connect(t, r, -1)) : u.generalTypeInCase && (h = r.findInputSlotByType(0, !1, !0, !0), (d = LiteGraph.debug) == null || d.call(LiteGraph, "connect TO a general type (*, 0), if not found the specific type ", s, " to ", r, "RES_SLOT:", h), h >= 0) ? this.connect(t, r, h) : u.firstFreeIfOutputGeneralInCase && (s == 0 || s == "*" || s == "") && (h = r.findInputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] }), (f = LiteGraph.debug) == null || f.call(LiteGraph, "connect TO TheFirstFREE ", s, " to ", r, "RES_SLOT:", h), h >= 0) ? this.connect(t, r, h) : ((_ = LiteGraph.debug) == null || _.call(LiteGraph, "no way to connect type: ", s, " to targetNODE ", r), null);
  }
  /**
   * connect this node input to the output of another node BY TYPE
   * @method connectByType
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} node the target node
   * @param {string} target_type the output slot type of the target node
   * @return {Object} the link_info is created, otherwise null
   */
  connectByTypeOutput(t, r, s = "*", a = {}) {
    var l, c, d;
    var o = {
      createEventInCase: !0,
      firstFreeIfInputGeneralInCase: !0,
      generalTypeInCase: !0
    }, u = Object.assign(o, a);
    r && r.constructor === Number && (r = this.graph.getNodeById(r));
    var h = r.findOutputSlotByType(s, !1, !0);
    return h >= 0 && h !== null ? ((l = LiteGraph.debug) == null || l.call(LiteGraph, "CONNbyTYPE OUT! type " + s + " for " + h), r.connect(h, this, t)) : u.generalTypeInCase && (h = r.findOutputSlotByType(0, !1, !0, !0), h >= 0) ? r.connect(h, this, t) : u.createEventInCase && s == LiteGraph.EVENT && LiteGraph.do_add_triggers_slots ? (h = r.addOnExecutedOutput(), r.connect(h, this, t)) : u.firstFreeIfInputGeneralInCase && (s == 0 || s == "*" || s == "" || s == "undefined") && (h = r.findOutputSlotFree({ typesNotAccepted: [LiteGraph.EVENT] }), h >= 0) ? r.connect(h, this, t) : ((c = LiteGraph.debug) == null || c.call(LiteGraph, "no way to connect byOUT type: ", s, " to sourceNODE ", r), (d = LiteGraph.log) == null || d.call(LiteGraph, "type OUT! " + s + " not found or not free?"), null);
  }
  /**
   * connect this node output to the input of another node
   * @method connect
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} node the target node
   * @param {number_or_string} target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
   * @return {Object} the link_info is created, otherwise null
   */
  connect(t, r, s = 0) {
    var c, d, f, _, E, m, T, L, G, O, b, I, S, N;
    if (!this.graph)
      return (c = LiteGraph.log) == null || c.call(LiteGraph, "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."), null;
    if (t.constructor === String) {
      if (t = this.findOutputSlot(t), t == -1)
        return (d = LiteGraph.log) == null || d.call(LiteGraph, `Connect: Error, no slot of name ${t}`), null;
    } else if (!this.outputs || t >= this.outputs.length)
      return (f = LiteGraph.log) == null || f.call(LiteGraph, "Connect: Error, slot number not found"), null;
    if (r && r.constructor === Number && (r = this.graph.getNodeById(r)), !r)
      throw new Error("target node is null");
    if (r == this)
      return null;
    if (s.constructor === String) {
      if (s = r.findInputSlot(s), s == -1)
        return (_ = LiteGraph.log) == null || _.call(LiteGraph, `Connect: Error, no slot of name ${s}`), null;
    } else if (s === LiteGraph.EVENT)
      if (LiteGraph.do_add_triggers_slots)
        r.changeMode(LiteGraph.ON_TRIGGER), s = r.findInputSlot("onTrigger");
      else
        return null;
    else if (!r.inputs || s >= r.inputs.length)
      return (E = LiteGraph.log) == null || E.call(LiteGraph, "Connect: Error, slot number not found"), null;
    var a = !1, o = r.inputs[s], u = null, h = this.outputs[t];
    if (!this.outputs[t])
      return (m = LiteGraph.log) == null || m.call(LiteGraph, "Invalid slot passed: ", t, this.outputs), null;
    if (r.onBeforeConnectInput && (s = r.onBeforeConnectInput(r)), ((T = this.onConnectOutput) == null ? void 0 : T.call(this, t, o.type, o, r, s)) === !1)
      return null;
    if (s === !1 || s === null || !LiteGraph.isValidConnection(h.type, o.type))
      return this.setDirtyCanvas(!1, !0), a && this.graph.connectionChange(this, u), null;
    if ((L = LiteGraph.debug) == null || L.call(LiteGraph, "DBG targetSlot", s), ((G = r.onConnectInput) == null ? void 0 : G.call(r, s, h.type, h, this, t)) === !1 || ((O = this.onConnectOutput) == null ? void 0 : O.call(this, t, o.type, o, r, s)) === !1)
      return null;
    r.inputs[s] && r.inputs[s].link != null && (this.graph.beforeChange(), r.disconnectInput(s, { doProcessChange: !1 }), a = !0), (b = h.links) != null && b.length && h.type === LiteGraph.EVENT && (LiteGraph.allow_multi_output_for_events || (this.graph.beforeChange(), this.disconnectOutput(t, !1, { doProcessChange: !1 }), a = !0));
    var l;
    return LiteGraph.use_uuids ? l = LiteGraph.uuidv4() : l = ++this.graph.last_link_id, u = new LiteGraph.LLink(
      l,
      o.type || h.type,
      this.id,
      t,
      r.id,
      s
    ), this.graph.links[u.id] = u, h.links == null && (h.links = []), h.links.push(u.id), typeof r.inputs[s] == "undefined" && ((I = LiteGraph.warn) == null || I.call(LiteGraph, "FIXME error, target_slot does not exists on target_node", r, s)), r.inputs[s].link = u.id, (S = this.onConnectionsChange) == null || S.call(
      this,
      LiteGraph.OUTPUT,
      t,
      !0,
      u,
      h
    ), (N = r.onConnectionsChange) == null || N.call(
      r,
      LiteGraph.INPUT,
      s,
      !0,
      u,
      o
    ), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(
      LiteGraph.INPUT,
      r,
      s,
      this,
      t
    ), this.graph.onNodeConnectionChange(
      LiteGraph.OUTPUT,
      this,
      t,
      r,
      s
    )), this.graph.onGraphChanged({ action: "connect" }), this.setDirtyCanvas(!1, !0), this.graph.afterChange(), this.graph.connectionChange(this, u), u;
  }
  /**
   * disconnect one output to an specific node
   * @method disconnectOutput
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @param {LGraphNode} target_node the target node to which this slot is connected [Optional, if not target_node is specified all nodes will be disconnected]
   * @return {boolean} if it was disconnected successfully
   */
  disconnectOutput(t, r, s = {}) {
    var l, c, d, f, _, E;
    var a = { doProcessChange: !0 }, o = Object.assign(a, s);
    if (t.constructor === String) {
      if (t = this.findOutputSlot(t), t == -1)
        return (l = LiteGraph.log) == null || l.call(LiteGraph, `Connect: Error, no slot of name ${t}`), !1;
    } else if (!this.outputs || t >= this.outputs.length)
      return (c = LiteGraph.log) == null || c.call(LiteGraph, "Connect: Error, slot number not found"), !1;
    var u = this.outputs[t];
    if (!u || !u.links || u.links.length == 0)
      return !1;
    if (r) {
      if (r.constructor === Number && (r = this.graph.getNodeById(r)), !r)
        throw new Error("Target Node not found");
      for (let m = 0, T = u.links.length; m < T; m++) {
        let L = u.links[m], G = this.graph.links[L];
        if (G.target_id == r.id) {
          u.links.splice(m, 1);
          var h = r.inputs[G.target_slot];
          h.link = null, delete this.graph.links[L], (d = this.graph) == null || d.onGraphChanged({ action: "disconnectOutput", doSave: o.doProcessChange }), (f = r.onConnectionsChange) == null || f.call(
            r,
            LiteGraph.INPUT,
            G.target_slot,
            !1,
            G,
            h
          ), (_ = this.onConnectionsChange) == null || _.call(
            this,
            LiteGraph.OUTPUT,
            t,
            !1,
            G,
            u
          ), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(
            LiteGraph.OUTPUT,
            this,
            t
          ), this.graph.onNodeConnectionChange(
            LiteGraph.OUTPUT,
            this,
            t
          ), this.graph.onNodeConnectionChange(
            LiteGraph.INPUT,
            r,
            G.target_slot
          ));
          break;
        }
      }
    } else {
      for (let m = 0, T = u.links.length; m < T; m++) {
        let L = u.links[m], G = this.graph.links[L];
        G && (r = this.graph.getNodeById(G.target_id), h = null, (E = this.graph) == null || E.onGraphChanged({ action: "disconnectOutput", doSave: o.doProcessChange }), r && (h = r.inputs[G.target_slot], h.link = null, r.onConnectionsChange && r.onConnectionsChange(
          LiteGraph.INPUT,
          G.target_slot,
          !1,
          G,
          h
        ), this.graph && this.graph.onNodeConnectionChange && this.graph.onNodeConnectionChange(
          LiteGraph.INPUT,
          r,
          G.target_slot
        )), delete this.graph.links[L], this.onConnectionsChange && this.onConnectionsChange(
          LiteGraph.OUTPUT,
          t,
          !1,
          G,
          u
        ), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(
          LiteGraph.OUTPUT,
          this,
          t
        ), this.graph.onNodeConnectionChange(
          LiteGraph.INPUT,
          r,
          G.target_slot
        )));
      }
      u.links = null;
    }
    return this.setDirtyCanvas(!1, !0), this.graph.connectionChange(this), !0;
  }
  /**
   * disconnect one input
   * @method disconnectInput
   * @param {number_or_string} slot (could be the number of the slot or the string with the name of the slot)
   * @return {boolean} if it was disconnected successfully
   */
  disconnectInput(t, r = {}) {
    var _, E, m;
    var s = { doProcessChange: !0 }, a = Object.assign(s, r);
    if (t.constructor === String) {
      if (t = this.findInputSlot(t), t == -1)
        return (_ = LiteGraph.log) == null || _.call(LiteGraph, `Connect: Error, no slot of name ${t}`), !1;
    } else if (!this.inputs || t >= this.inputs.length)
      return (E = LiteGraph.log) == null || E.call(LiteGraph, "Connect: Error, slot number not found"), !1;
    var o = this.inputs[t];
    if (!o)
      return !1;
    var u = this.inputs[t].link;
    if (u != null) {
      this.inputs[t].link = null;
      var h = this.graph.links[u];
      if (h) {
        var l = this.graph.getNodeById(h.origin_id);
        if (!l)
          return !1;
        var c = l.outputs[h.origin_slot];
        if (!c || !c.links || c.links.length == 0)
          return !1;
        for (var d = 0, f = c.links.length; d < f; d++)
          if (c.links[d] == u) {
            c.links.splice(d, 1);
            break;
          }
        delete this.graph.links[u], (m = this.graph) == null || m.onGraphChanged({ action: "disconnectInput", doSave: a.doProcessChange }), this.onConnectionsChange && this.onConnectionsChange(
          LiteGraph.INPUT,
          t,
          !1,
          h,
          o
        ), l.onConnectionsChange && l.onConnectionsChange(
          LiteGraph.OUTPUT,
          d,
          !1,
          h,
          c
        ), this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(
          LiteGraph.OUTPUT,
          l,
          d
        ), this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, t));
      }
    }
    return this.setDirtyCanvas(!1, !0), this.graph && this.graph.connectionChange(this), !0;
  }
  /**
   * Returns the center of a connection point in canvas coordinates
   * @method getConnectionPos
   * @param {boolean} is_input - True if it is an input slot, false if it is an output slot
   * @param {number | string} slot - Could be the number of the slot or the string with the name of the slot
   * @param {vec2} [out] - [Optional] A place to store the output to reduce garbage
   * @return {Float32[]} The position as [x, y]
   */
  getConnectionPos(t, r, s = new Float32Array(2)) {
    var a = 0;
    t && this.inputs && (a = this.inputs.length), !t && this.outputs && (a = this.outputs.length);
    var o = LiteGraph.NODE_SLOT_HEIGHT * 0.5;
    if (this.flags.collapsed) {
      var u = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;
      return this.horizontal ? (s[0] = this.pos[0] + u * 0.5, t ? s[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT : s[1] = this.pos[1]) : (t ? s[0] = this.pos[0] : s[0] = this.pos[0] + u, s[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5), s;
    }
    return t && r == -1 ? (s[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5, s[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5, s) : t && a > r && this.inputs[r].pos ? (s[0] = this.pos[0] + this.inputs[r].pos[0], s[1] = this.pos[1] + this.inputs[r].pos[1], s) : !t && a > r && this.outputs[r].pos ? (s[0] = this.pos[0] + this.outputs[r].pos[0], s[1] = this.pos[1] + this.outputs[r].pos[1], s) : this.horizontal ? (s[0] = this.pos[0] + (r + 0.5) * (this.size[0] / a), t ? s[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT : s[1] = this.pos[1] + this.size[1], s) : (t ? s[0] = this.pos[0] + o : s[0] = this.pos[0] + this.size[0] + 1 - o, s[1] = this.pos[1] + (r + 0.7) * LiteGraph.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0), s);
  }
  /* Force align to grid */
  alignToGrid() {
    this.pos[0] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE), this.pos[1] = LiteGraph.CANVAS_GRID_SIZE * Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);
  }
  /* Console output */
  trace(t) {
    var r, s, a, o;
    this.console || (this.console = []), (s = (r = this.console).push) == null || s.call(r, t), this.console.length > LGraphNode.MAX_CONSOLE && ((o = (a = this.console).shift) == null || o.call(a)), this.graph.onNodeTrace && this.graph.onNodeTrace(this, t);
  }
  /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
  setDirtyCanvas(t, r) {
    this.graph && this.graph.sendActionToCanvas("setDirty", [
      t,
      r
    ]);
  }
  loadImage(t) {
    var r = new Image();
    r.src = LiteGraph.node_images_path + t, r.ready = !1;
    var s = this;
    return r.onload = function() {
      this.ready = !0, s.setDirtyCanvas(!0);
    }, r;
  }
  // safe LGraphNode action execution (not sure if safe)
  /*
      LGraphNode.prototype.executeAction = function(action)
      {
      if(action == "") return false;
  
      if( action.indexOf(";") != -1 || action.indexOf("}") != -1)
      {
          this.trace("Error: Action contains unsafe characters");
          return false;
      }
  
      var tokens = action.split("(");
      var func_name = tokens[0];
      if( typeof(this[func_name]) != "function")
      {
          this.trace("Error: Action not found on node: " + func_name);
          return false;
      }
  
      var code = action;
  
      try
      {
          var _foo = eval;
          eval = null;
          (new Function("with(this) { " + code + "}")).call(this);
          eval = _foo;
      }
      catch (err)
      {
          this.trace("Error executing action {" + action + "} :" + err);
          return false;
      }
  
      return true;
      }
      */
  /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
  captureInput(t) {
    if (!(!this.graph || !this.graph.list_of_graphcanvas))
      for (var r = this.graph.list_of_graphcanvas, s = 0; s < r.length; ++s) {
        var a = r[s];
        !t && a.node_capturing_input != this || (a.node_capturing_input = t ? this : null);
      }
  }
  /**
   * Collapse the node to make it smaller on the canvas
   * @method collapse
   **/
  collapse(t) {
    this.graph.onGraphChanged({ action: "collapse" }), !(this.constructor.collapsable === !1 && !t) && (this.flags.collapsed ? this.flags.collapsed = !1 : this.flags.collapsed = !0, this.setDirtyCanvas(!0, !0));
  }
  /**
   * Forces the node to do not move or realign on Z
   * @method pin
   **/
  pin(t) {
    this.graph.onGraphChanged({ action: "pin" }), t === void 0 ? this.flags.pinned = !this.flags.pinned : this.flags.pinned = t;
  }
  localToScreen(t, r, s) {
    return [
      (t + this.pos[0]) * s.scale + s.offset[0],
      (r + this.pos[1]) * s.scale + s.offset[1]
    ];
  }
  refreshAncestors(t = {}) {
    var r = {
      action: "",
      param: null,
      options: null,
      passParam: !0
    }, s = Object.assign(r, t);
    if (this.inputs && !(LiteGraph.preventAncestorRecalculation && this.graph.node_ancestorsCalculated && this.graph.node_ancestorsCalculated[this.id])) {
      (!s.action || s.action == "") && (s.action = this.id + "_ancestors"), (!s.param || s.param == "") && (s.param = this.id + "_ancestors"), s.options || (s.options = {}), s.options = Object.assign({ action_call: s.action }, s.options), this.graph.ancestorsCall = !0;
      var a = {
        modesSkip: [LiteGraph.NEVER, LiteGraph.ON_EVENT, LiteGraph.ON_TRIGGER],
        modesOnly: [LiteGraph.ALWAYS, LiteGraph.ON_REQUEST],
        typesSkip: [LiteGraph.ACTION],
        typesOnly: []
      }, o = this.graph.getAncestors(this, a);
      for (iN in o)
        o[iN].doExecute(s.param, s.options), this.graph.node_ancestorsCalculated[o[iN].id] = !0;
      return this.graph.ancestorsCall = !1, this.graph.node_ancestorsCalculated[this.id] = !0, !0;
    }
  }
}
class LGraphGroup {
  /**
   * Constructor for the LGraphGroup class.
   * @param {string} [title="Group"] - The title of the group.
   */
  constructor(t = "Group") {
    g(this, "isPointInside", LiteGraph.LGraphNode.prototype.isPointInside);
    g(this, "setDirtyCanvas", LiteGraph.LGraphNode.prototype.setDirtyCanvas);
    var r, s;
    this.title = t, this.font_size = 24, this.color = (s = (r = LiteGraph.LGraphCanvas.node_colors.pale_blue) == null ? void 0 : r.groupcolor) != null ? s : "#AAA", this._bounding = new Float32Array([10, 10, 140, 80]), this._pos = this._bounding.subarray(0, 2), this._size = this._bounding.subarray(2, 4), this._nodes = [], this.graph = null;
  }
  set pos(t) {
    !t || t.length < 2 || (this._pos[0] = t[0], this._pos[1] = t[1]);
  }
  get pos() {
    return this._pos;
  }
  set size(t) {
    !t || t.length < 2 || (this._size[0] = Math.max(140, t[0]), this._size[1] = Math.max(80, t[1]));
  }
  get size() {
    return this._size;
  }
  /**
   * Updates the properties of the LGraphGroup instance based on the provided configuration object.
   * @param {Object} o - The configuration object with properties to update.
   * @param {string} o.title - The new title for the group.
   * @param {Float32Array} o.bounding - The new bounding box for the group.
   * @param {string} o.color - The new color for the group.
   * @param {number} o.font_size - The new font size for the group.
   */
  configure(t) {
    this.title = t.title, this._bounding.set(t.bounding), this.color = t.color, t.font_size && (this.font_size = t.font_size);
  }
  /**
   * Serializes the LGraphGroup instance into a plain JavaScript object.
   * @returns {Object} - The serialized representation of the LGraphGroup instance.
   * - title: string - The title of the group.
   * - bounding: Array<number> - The bounding box coordinates [x, y, width, height].
   * - color: string - The color of the group.
   * - font_size: number - The font size of the group.
   */
  serialize() {
    var t = this._bounding;
    return {
      title: this.title,
      bounding: t.map((r) => Math.round(r)),
      color: this.color,
      font_size: this.font_size
    };
  }
  /**
   * Moves the LGraphGroup instance by the specified deltas and optionally updates the positions of contained nodes.
   * @param {number} deltax - The amount to move the group along the x-axis.
   * @param {number} deltay - The amount to move the group along the y-axis.
   * @param {boolean} ignore_nodes - Flag to indicate whether to move contained nodes along with the group.
   */
  move(t, r, s) {
    var a, o;
    isNaN(t) && ((a = console.error) == null || a.call(console, "LGraphGroup.move() deltax NaN")), isNaN(r) && ((o = console.error) == null || o.call(console, "LGraphGroup.move() deltay NaN")), this._pos[0] += t, this._pos[1] += r, !s && this._nodes.forEach((u) => {
      u.pos[0] += t, u.pos[1] += r;
    });
  }
  /**
   * Recomputes and updates the list of nodes inside the LGraphGroup based on their bounding boxes.
   * This method checks for nodes that overlap with the group's bounding box and updates the internal nodes list accordingly.
   */
  recomputeInsideNodes() {
    this._nodes.length = 0;
    var t = this.graph._nodes, r = new Float32Array(4);
    this._nodes = t.filter((s) => (s.getBounding(r), LiteGraph.overlapBounding(this._bounding, r)));
  }
}
const _LGraphCanvas = class _LGraphCanvas {
  constructor(n, t, r) {
    /**
     * Called when a mouse wheel event has to be processed
     * @method processMouseWheel
     **/
    g(this, "processMouseWheel", (n) => {
      if (!(!this.graph || !this.allow_dragcanvas)) {
        var t = n.wheelDeltaY != null ? n.wheelDeltaY : n.detail * -60;
        this.adjustMouseEvent(n);
        var r = n.clientX, s = n.clientY, a = !this.viewport || this.viewport && r >= this.viewport[0] && r < this.viewport[0] + this.viewport[2] && s >= this.viewport[1] && s < this.viewport[1] + this.viewport[3];
        if (a) {
          var o = this.ds.scale;
          return o *= Math.pow(1.1, t * 0.01), this.ds.changeScale(o, [n.clientX, n.clientY]), this.graph.change(), n.preventDefault(), !1;
        }
      }
    });
    /**
     * process a key event
     * @method processKey
     **/
    g(this, "processKey", (n) => {
      var r, s, a, o, u;
      if (this.graph) {
        var t = !1;
        if (n.target.localName != "input") {
          if (n.type == "keydown") {
            if (n.keyCode == 32 && (this.dragging_canvas = !0, t = !0), n.keyCode == 27 && (this.node_panel && this.node_panel.close(), this.options_panel && this.options_panel.close(), t = !0), n.keyCode == 65 && n.ctrlKey && (this.selectNodes(), t = !0), n.keyCode === 67 && (n.metaKey || n.ctrlKey) && !n.shiftKey && this.selected_nodes && (this.copyToClipboard(), t = !0), n.keyCode === 86 && (n.metaKey || n.ctrlKey) && this.pasteFromClipboard(n.shiftKey), (n.keyCode == 46 || LiteGraph.backspace_delete && n.keyCode == 8) && n.target.localName != "input" && n.target.localName != "textarea" && (this.deleteSelectedNodes(), t = !0), LiteGraph.actionHistory_enabled && (n.keyCode == 89 && n.ctrlKey || n.keyCode == 90 && n.ctrlKey && n.shiftKey ? this.graph.actionHistoryForward() : n.keyCode == 90 && n.ctrlKey && this.graph.actionHistoryBack()), (r = LiteGraph.debug) == null || r.call(LiteGraph, "Canvas keydown " + n.keyCode), this.selected_nodes)
              for (let h in this.selected_nodes)
                (a = (s = this.selected_nodes[h]).onKeyDown) == null || a.call(s, n);
          } else if (n.type == "keyup" && (n.keyCode == 32 && (this.dragging_canvas = !1), this.selected_nodes))
            for (let h in this.selected_nodes)
              (u = (o = this.selected_nodes[h]).onKeyUp) == null || u.call(o, n);
          if (this.graph.change(), t)
            return n.preventDefault(), n.stopImmediatePropagation(), !1;
        }
      }
    });
    /**
     * process a item drop event on top the canvas
     * @method processDrop
     **/
    g(this, "processDrop", (n) => {
      n.preventDefault(), this.adjustMouseEvent(n);
      var t = n.clientX, r = n.clientY, s = !this.viewport || this.viewport && t >= this.viewport[0] && t < this.viewport[0] + this.viewport[2] && r >= this.viewport[1] && r < this.viewport[1] + this.viewport[3];
      if (s) {
        t = n.localX, r = n.localY;
        var s = !this.viewport || this.viewport && t >= this.viewport[0] && t < this.viewport[0] + this.viewport[2] && r >= this.viewport[1] && r < this.viewport[1] + this.viewport[3];
        if (s) {
          var a = [n.canvasX, n.canvasY], o = this.graph ? this.graph.getNodeOnPos(a[0], a[1]) : null;
          if (!o) {
            var u = null;
            this.onDropItem && (u = this.onDropItem(event)), u || this.checkDropItem(n);
            return;
          }
          if (o.onDropFile || o.onDropData) {
            var h = n.dataTransfer.files;
            if (h && h.length)
              for (let _ = 0; _ < h.length; _++) {
                var l = n.dataTransfer.files[0], c = l.name;
                if (o.onDropFile && o.onDropFile(l), o.onDropData) {
                  var d = new FileReader();
                  d.onload = function(E) {
                    var m = E.target.result;
                    o.onDropData(m, c, l);
                  };
                  var f = l.type.split("/")[0];
                  f == "text" || f == "" ? d.readAsText(l) : f == "image" ? d.readAsDataURL(l) : d.readAsArrayBuffer(l);
                }
              }
          }
          return o.onDropItem && o.onDropItem(event) ? !0 : this.onDropItem ? this.onDropItem(event) : !1;
        }
      }
    });
    r != null || (r = {
      skip_render: !1,
      autoresize: !1,
      clip_all_nodes: !1
    }), this.options = r, this.background_image = _LGraphCanvas.DEFAULT_BACKGROUND_IMAGE, n && n.constructor === String && (n = document.querySelector(n)), this.ds = new LiteGraph.DragAndScale(), this.zoom_modify_alpha = !0, this.title_text_font = `${LiteGraph.NODE_TEXT_SIZE}px Arial`, this.inner_text_font = `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px Arial`, this.node_title_color = LiteGraph.NODE_TITLE_COLOR, this.default_link_color = LiteGraph.LINK_COLOR, this.default_connection_color = {
      input_off: "#778",
      input_on: "#7F7",
      // "#BBD"
      output_off: "#778",
      output_on: "#7F7"
      // "#BBD"
    }, this.default_connection_color_byType = {}, this.default_connection_color_byTypeOff = {}, this.drag_mode = !1, this.dragging_rectangle = null, this.filter = null, this.highquality_render = !0, this.use_gradients = !1, this.editor_alpha = 1, this.pause_rendering = !1, this.clear_background = !0, this.clear_background_color = "#222", this.read_only = !1, this.live_mode = !1, this.show_info = !0, this.allow_dragcanvas = !0, this.allow_dragnodes = !0, this.allow_interaction = !0, this.multi_select = !1, this.allow_searchbox = !0, this.move_destination_link_without_shift = !1, this.align_to_grid = !1, this.drag_mode = !1, this.dragging_rectangle = null, this.filter = null, this.set_canvas_dirty_on_mouse_event = !0, this.always_render_background = !1, this.render_shadows = !0, this.render_canvas_border = !0, this.render_connections_shadows = !1, this.render_connections_border = !0, this.render_curved_connections = !0, this.render_connection_arrows = !1, this.render_collapsed_slots = !0, this.render_execution_order = !1, this.render_title_colored = !0, this.render_link_tooltip = !0, this.free_resize = !0, this.links_render_mode = LiteGraph.SPLINE_LINK, this.autoresize = r.autoresize, this.skip_render = r.skip_render, this.clip_all_nodes = r.clip_all_nodes, this.free_resize = r.free_resize, this.mouse = [0, 0], this.graph_mouse = [0, 0], this.canvas_mouse = this.graph_mouse, this.onSearchBox = null, this.onSearchBoxSelection = null, this.onMouse = null, this.onDrawBackground = null, this.onDrawForeground = null, this.onDrawOverlay = null, this.onDrawLinkTooltip = null, this.onNodeMoved = null, this.onSelectionChange = null, this.onConnectingChange = null, this.onBeforeChange = null, this.onAfterChange = null, this.connections_width = 3, this.round_radius = 8, this.current_node = null, this.node_widget = null, this.over_link_center = null, this.last_mouse_position = [0, 0], this.visible_area = this.ds.visible_area, this.visible_links = [], this.viewport = r.viewport || null, this.low_quality_rendering_threshold = 5, t == null || t.attachCanvas(this), this.setCanvas(n, r.skip_events), this.clear(), !this.skip_render && !r.skip_render && this.startRendering();
  }
  /**
   * clears all the data inside
   *
   * @method clear
   */
  clear() {
    var n;
    this.frame = 0, this.last_draw_time = 0, this.render_time = 0, this.fps = 0, this.low_quality_rendering_counter = 0, this.dragging_rectangle = null, this.selected_nodes = {}, this.selected_group = null, this.visible_nodes = [], this.node_dragged = null, this.node_over = null, this.node_capturing_input = null, this.connecting_node = null, this.highlighted_links = {}, this.dragging_canvas = !1, this.dirty_canvas = !0, this.dirty_bgcanvas = !0, this.dirty_area = null, this.node_in_panel = null, this.node_widget = null, this.last_mouse = [0, 0], this.last_mouseclick = 0, this.pointer_is_down = !1, this.pointer_is_double = !1, this.visible_area.set([0, 0, 0, 0]), (n = this.onClear) == null || n.call(this);
  }
  /**
   * assigns a graph, you can reassign graphs to the same canvas
   *
   * @method setGraph
   * @param {LGraph} graph
   */
  setGraph(n, t) {
    var r;
    if (this.graph != n) {
      if (t || this.clear(), !n) {
        (r = this.graph) == null || r.detachCanvas(this);
        return;
      }
      n.attachCanvas(this), this._graph_stack && (this._graph_stack = null), this.setDirty(!0, !0);
    }
  }
  /**
   * returns the top level graph (in case there are subgraphs open on the canvas)
   *
   * @method getTopGraph
   * @return {LGraph} graph
   */
  getTopGraph() {
    return this._graph_stack.length ? this._graph_stack[0] : this.graph;
  }
  /**
   * opens a graph contained inside a node in the current graph
   *
   * @method openSubgraph
   * @param {LGraph} graph
   */
  openSubgraph(n) {
    if (!n)
      throw new Error("graph cannot be null");
    if (this.graph == n)
      throw new Error("graph cannot be the same");
    this.clear(), this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph)), n.attachCanvas(this), this.checkPanels(), this.setDirty(!0, !0);
  }
  /**
   * closes a subgraph contained inside a node
   *
   * @method closeSubgraph
   * @param {LGraph} assigns a graph
   */
  closeSubgraph() {
    if (!(!this._graph_stack || this._graph_stack.length == 0)) {
      var n = this.graph._subgraph_node, t = this._graph_stack.pop();
      this.selected_nodes = {}, this.highlighted_links = {}, t.attachCanvas(this), this.setDirty(!0, !0), n && (this.centerOnNode(n), this.selectNodes([n])), this.ds.offset = [0, 0], this.ds.scale = 1;
    }
  }
  /**
   * returns the visually active graph (in case there are more in the stack)
   * @method getCurrentGraph
   * @return {LGraph} the active graph
   */
  getCurrentGraph() {
    return this.graph;
  }
  /**
   * assigns a canvas
   *
   * @method setCanvas
   * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)
   */
  setCanvas(n, t) {
    var s;
    if (n && n.constructor === String && (n = document.getElementById(n), !n))
      throw new Error("Error creating LiteGraph canvas: Canvas not found");
    if (n !== this.canvas && (!n && this.canvas && (t || this.unbindEvents()), this.canvas = n, this.ds.element = n, !!n)) {
      if (n.className += " lgraphcanvas", n.data = this, n.tabindex = "1", this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, n.getContext == null)
        throw n.localName != "canvas" ? new Error("Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + n.localName) : new Error("This browser doesn't support Canvas");
      var r = this.ctx = n.getContext("2d");
      r == null && (n.webgl_enabled || (s = LiteGraph.info) == null || s.call(LiteGraph, "This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL()), t || this.bindEvents();
    }
  }
  // used in some events to capture them
  _doNothing(n) {
    return n.preventDefault(), !1;
  }
  _doReturnTrue(n) {
    return n.preventDefault(), !0;
  }
  /**
   * binds mouse, keyboard, touch and drag events to the canvas
   * @method bindEvents
   **/
  bindEvents() {
    var s;
    if (this._events_binded) {
      (s = LiteGraph.warn) == null || s.call(LiteGraph, "LGraphCanvas: events already binded");
      return;
    }
    this._events_binded = !0;
    var n = this.canvas, t = this.getCanvasWindow(), r = t.document;
    this._mousedown_callback = this.processMouseDown.bind(this), this._mousemove_callback = this.processMouseMove.bind(this), this._mouseup_callback = this.processMouseUp.bind(this), n.addEventListener("pointerdown", this._mousedown_callback, !0), n.addEventListener("pointermove", this._mousemove_callback), n.addEventListener("pointerup", this._mouseup_callback, !0), n.addEventListener("contextmenu", this._doNothing), n.addEventListener("wheel", this.processMouseWheel), n.addEventListener("keydown", this.processKey), r.addEventListener("keyup", this.processKey), n.addEventListener("dragover", this._doNothing, !1), n.addEventListener("dragend", this._doNothing, !1), n.addEventListener("drop", this.processDrop), n.addEventListener("dragenter", this._doReturnTrue, !1);
  }
  /**
   * unbinds mouse events from the canvas
   * @method unbindEvents
   **/
  unbindEvents() {
    var s;
    if (!this._events_binded) {
      (s = LiteGraph.warn) == null || s.call(LiteGraph, "LGraphCanvas: no events binded");
      return;
    }
    this._events_binded = !1;
    var n = this.canvas, t = this.getCanvasWindow(), r = t.document;
    n.removeEventListener("pointerdown", this._mousedown_callback), n.removeEventListener("pointermove", this._mousemove_callback), n.removeEventListener("pointerup", this._mouseup_callback), n.removeEventListener("contextmenu", this._doNothing), n.removeEventListener("wheel", this.processMouseWheel), n.removeEventListener("keydown", this.processKey), r.removeEventListener("keyup", this.processKey), n.removeEventListener("dragover", this._doNothing, !1), n.removeEventListener("dragend", this._doNothing, !1), n.removeEventListener("drop", this.processDrop), n.removeEventListener("dragenter", this._doReturnTrue), this._mousedown_callback = null;
  }
  static getFileExtension(n) {
    const r = new URL(n).pathname, s = r.lastIndexOf(".");
    return s === -1 ? "" : r.slice(s + 1).toLowerCase();
  }
  /**
   * this function allows to render the canvas using WebGL instead of Canvas2D
   * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL
   * @method enableWebGL
   **/
  enableWebGL() {
    if (typeof GL == "undefined")
      throw new Error("litegl.js must be included to use a WebGL canvas");
    if (typeof enableWebGLCanvas == "undefined")
      throw new Error("webglCanvas.js must be included to use this feature");
    this.gl = this.ctx = enableWebGLCanvas(this.canvas), this.ctx.webgl = !0, this.bgcanvas = this.canvas, this.bgctx = this.gl, this.canvas.webgl_enabled = !0;
  }
  /**
   * marks as dirty the canvas, this way it will be rendered again
   *
   * @class LGraphCanvas
   * @method setDirty
   * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)
   * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)
   */
  setDirty(n, t) {
    n && (this.dirty_canvas = !0), t && (this.dirty_bgcanvas = !0);
  }
  /**
   * Used to attach the canvas in a popup
   *
   * @method getCanvasWindow
   * @return {window} returns the window where the canvas is attached (the DOM root node)
   */
  getCanvasWindow() {
    var t;
    if (!this.canvas)
      return window;
    var n = this.canvas.ownerDocument;
    return (t = n.defaultView) != null ? t : n.parentWindow;
  }
  /**
   * starts rendering the content of the canvas when needed
   *
   * @method startRendering
   */
  startRendering() {
    if (this.is_rendering)
      return;
    this.is_rendering = !0, n.call(this);
    function n() {
      this.pause_rendering || this.draw();
      var t = this.getCanvasWindow();
      this.is_rendering && t.requestAnimationFrame(n.bind(this));
    }
  }
  /**
   * stops rendering the content of the canvas (to save resources)
   *
   * @method stopRendering
   */
  stopRendering() {
    this.is_rendering = !1;
  }
  /* LiteGraphCanvas input */
  // used to block future mouse events (because of im gui)
  blockClick() {
    this.block_click = !0, this.last_mouseclick = 0;
  }
  processUserInputDown(n) {
    var t, r;
    if (this.pointer_is_down && n.isPrimary !== void 0 && !n.isPrimary ? this.userInput_isNotPrimary = !0 : this.userInput_isNotPrimary = !1, this.userInput_type = n.pointerType ? n.pointerType : !1, this.userInput_id = n.pointerId ? n.pointerId : !1, n.pointerType)
      switch (n.pointerType) {
        case "mouse":
          break;
        case "pen":
          break;
        case "touch":
          break;
        default:
          (t = LiteGraph.log) == null || t.call(LiteGraph, "pointerType unknown " + ev.pointerType);
      }
    return n.button !== void 0 && (this.userInput_button = n.button, n.button), n.buttons !== void 0 && (this.userInput_button_s = n.buttons), this.userInput_touches = n.changedTouches !== void 0 && n.changedTouches.length !== void 0 ? n.changedTouches : !1, this.userInput_touches && this.userInput_touches.length && ((r = LiteGraph.debug) == null || r.call(LiteGraph, "check multiTouches", n.changedTouches)), this.processMouseDown(n);
  }
  processMouseDown(n) {
    var X, F, V, $, U, H, z, K, tt;
    if (this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0), !!this.graph) {
      this.adjustMouseEvent(n);
      var t = this.getCanvasWindow();
      _LGraphCanvas.active_canvas = this;
      var r = n.clientX, s = n.clientY;
      (X = LiteGraph.log) == null || X.call(LiteGraph, "pointerevents: processMouseDown pointerId:" + n.pointerId + " which:" + n.which + " isPrimary:" + n.isPrimary + " :: x y " + r + " " + s, "previousClick", this.last_mouseclick, "diffTimeClick", this.last_mouseclick ? LiteGraph.getTime() - this.last_mouseclick : "notlast"), this.ds.viewport = this.viewport;
      var a = !this.viewport || this.viewport && r >= this.viewport[0] && r < this.viewport[0] + this.viewport[2] && s >= this.viewport[1] && s < this.viewport[1] + this.viewport[3];
      if (this.options.skip_events || (this.canvas.removeEventListener("pointermove", this._mousemove_callback), t.document.addEventListener("pointermove", this._mousemove_callback, !0), t.document.addEventListener("pointerup", this._mouseup_callback, !0)), !!a) {
        var o = this.graph.getNodeOnPos(n.canvasX, n.canvasY, this.visible_nodes, 5), u = !1, h = LiteGraph.getTime(), l = n.isPrimary === void 0 || n.isPrimary, c = h - this.last_mouseclick < 300 && l;
        if (this.mouse[0] = n.clientX, this.mouse[1] = n.clientY, this.graph_mouse[0] = n.canvasX, this.graph_mouse[1] = n.canvasY, this.last_click_position = [this.mouse[0], this.mouse[1]], this.pointer_is_down && l ? this.pointer_is_double = !0 : this.pointer_is_double = !1, this.pointer_is_down = !0, this.canvas.focus(), LiteGraph.ContextMenu.closeAll(t), !((F = this.onMouse) != null && F.call(this, n))) {
          if (n.which == 1 && !this.userInput_isNotPrimary) {
            if (n.ctrlKey && (this.dragging_rectangle = new Float32Array(4), this.dragging_rectangle[0] = n.canvasX, this.dragging_rectangle[1] = n.canvasY, this.dragging_rectangle[2] = 1, this.dragging_rectangle[3] = 1, u = !0), LiteGraph.alt_drag_do_clone_nodes && n.altKey && o && this.allow_interaction && !u && !this.read_only) {
              let W = o, Q = o.clone();
              if (Q) {
                if (Q.pos[0] += 5, Q.pos[1] += 5, this.graph.add(Q, !1, { doCalcSize: !1 }), o = Q, LiteGraph.alt_shift_drag_connect_clone_with_input && n.shiftKey && W.inputs && W.inputs.length)
                  for (var d = 0; d < W.inputs.length; ++d) {
                    var f = W.inputs[d];
                    if (!(!f || f.link == null)) {
                      var _ = this.graph.links[f.link];
                      if (_ && _.type !== LiteGraph.EVENT) {
                        var E;
                        _.origin_id && (E = this.graph.getNodeById(_.origin_id));
                        var m = o;
                        E && m && E.connect(_.origin_slot, m, _.target_slot);
                      }
                    }
                  }
                u = !0, G || (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = o), this.selected_nodes[o.id] || this.processNodeSelected(o, n));
              }
            }
            var T = !1;
            if (o && (this.allow_interaction || o.flags.allow_interaction) && !u && !this.read_only) {
              if (!this.live_mode && !o.flags.pinned && this.bringToFront(o), this.allow_interaction && !this.connecting_node && !o.flags.collapsed && !this.live_mode)
                if (!u && o.resizable !== !1 && LiteGraph.isInsideRectangle(
                  n.canvasX,
                  n.canvasY,
                  o.pos[0] + o.size[0] - 5,
                  o.pos[1] + o.size[1] - 5,
                  10,
                  10
                ))
                  this.graph.beforeChange(), this.resizing_node = o, this.canvas.style.cursor = "se-resize", u = !0;
                else {
                  if (o.outputs)
                    for (let W = 0, Q = o.outputs.length; W < Q; ++W) {
                      let J = o.outputs[W], q = o.getConnectionPos(!1, W);
                      if (LiteGraph.isInsideRectangle(
                        n.canvasX,
                        n.canvasY,
                        q[0] - 15,
                        q[1] - 10,
                        30,
                        20
                      )) {
                        this.connecting_node = o, this.connecting_output = J, this.connecting_output.slot_index = W, this.connecting_pos = o.getConnectionPos(!1, W), this.connecting_slot = W, LiteGraph.shift_click_do_break_link_from && n.shiftKey && o.disconnectOutput(W), c ? (V = o.onOutputDblClick) == null || V.call(o, W, n) : ($ = o.onOutputClick) == null || $.call(o, W, n), u = !0;
                        break;
                      }
                    }
                  if (o.inputs)
                    for (let W = 0, Q = o.inputs.length; W < Q; ++W) {
                      let J = o.inputs[W], q = o.getConnectionPos(!0, W);
                      if (LiteGraph.isInsideRectangle(
                        n.canvasX,
                        n.canvasY,
                        q[0] - 15,
                        q[1] - 10,
                        30,
                        20
                      )) {
                        if (c ? (U = o.onInputDblClick) == null || U.call(o, W, n) : (H = o.onInputClick) == null || H.call(o, W, n), J.link !== null) {
                          var L = this.graph.links[J.link];
                          LiteGraph.click_do_break_link_to && (o.disconnectInput(W), this.dirty_bgcanvas = !0, u = !0), // this.allow_reconnect_links ||
                          // this.move_destination_link_without_shift ||
                          n.shiftKey && (LiteGraph.click_do_break_link_to || o.disconnectInput(W), this.connecting_node = this.graph._nodes_by_id[L.origin_id], this.connecting_slot = L.origin_slot, this.connecting_output = this.connecting_node.outputs[this.connecting_slot], this.connecting_pos = this.connecting_node.getConnectionPos(!1, this.connecting_slot), this.dirty_bgcanvas = !0, u = !0);
                        }
                        u || (this.connecting_node = o, this.connecting_input = J, this.connecting_input.slot_index = W, this.connecting_pos = o.getConnectionPos(!0, W), this.connecting_slot = W, this.dirty_bgcanvas = !0, u = !0);
                      }
                    }
                }
              if (!u) {
                var G = !1, O = [n.canvasX - o.pos[0], n.canvasY - o.pos[1]], b = this.processNodeWidgets(o, this.graph_mouse, n);
                b && (G = !0, this.node_widget = [o, b]), this.allow_interaction && c && this.selected_nodes[o.id] && ((z = o.onDblClick) == null || z.call(o, n, O, this), this.processNodeDblClicked(o), G = !0), o.onMouseDown && o.onMouseDown(n, O, this) ? G = !0 : (o.subgraph && !o.skip_subgraph_button && !o.flags.collapsed && O[0] > o.size[0] - LiteGraph.NODE_TITLE_HEIGHT && O[1] < 0 && setTimeout(() => {
                  this.openSubgraph(o.subgraph);
                }, 10), this.live_mode && (T = !0, G = !0)), G ? o.is_selected || this.processNodeSelected(o, n) : (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = o), this.processNodeSelected(o, n)), this.dirty_canvas = !0;
              }
            } else if (!u) {
              if (!this.read_only)
                for (let W = 0; W < this.visible_links.length; ++W) {
                  var I = this.visible_links[W], S = I._pos;
                  if (!(!S || n.canvasX < S[0] - 4 || n.canvasX > S[0] + 4 || n.canvasY < S[1] - 4 || n.canvasY > S[1] + 4)) {
                    this.showLinkMenu(I, n), this.over_link_center = null;
                    break;
                  }
                }
              if (this.selected_group = this.graph.getGroupOnPos(n.canvasX, n.canvasY), this.selected_group_resizing = !1, this.selected_group && !this.read_only) {
                n.ctrlKey && (this.dragging_rectangle = null);
                var N = LiteGraph.distance([n.canvasX, n.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]);
                N * this.ds.scale < 10 ? this.selected_group_resizing = !0 : this.selected_group.recomputeInsideNodes();
              }
              c && !this.read_only && this.allow_searchbox && (this.showSearchBox(n), n.preventDefault(), n.stopPropagation()), (K = LiteGraph.debug) == null || K.call(LiteGraph, "DEBUG canvas click is_double_click,this.allow_searchbox", c, this.allow_searchbox), T = !0;
            }
            !u && T && this.allow_dragcanvas && (this.dragging_canvas = !0);
          } else if (n.which == 2)
            if (LiteGraph.middle_click_slot_add_default_node) {
              if (o && this.allow_interaction && !u && !this.read_only && !this.connecting_node && !o.flags.collapsed && !this.live_mode) {
                var C = !1, D = !1, M = !1;
                if (o.outputs)
                  for (let W = 0, Q = o.outputs.length; W < Q; ++W) {
                    var P = o.outputs[W];
                    let J = o.getConnectionPos(!1, W);
                    if (LiteGraph.isInsideRectangle(n.canvasX, n.canvasY, J[0] - 15, J[1] - 10, 30, 20)) {
                      C = P, D = W, M = !0;
                      break;
                    }
                  }
                if (o.inputs)
                  for (let W = 0, Q = o.inputs.length; W < Q; ++W) {
                    var f = o.inputs[W];
                    let q = o.getConnectionPos(!0, W);
                    if (LiteGraph.isInsideRectangle(n.canvasX, n.canvasY, q[0] - 15, q[1] - 10, 30, 20)) {
                      C = f, D = W, M = !1;
                      break;
                    }
                  }
                if (C && D !== !1) {
                  var A = 0.5 - (D + 1) / (M ? o.outputs.length : o.inputs.length), R = o.getBounding(), B = [
                    M ? R[0] + R[2] : R[0],
                    // + node_bounding[0]/this.canvas.width*150
                    n.canvasY - 80
                    // + node_bounding[0]/this.canvas.width*66 // vertical "derive"
                  ];
                  this.createDefaultNodeForSlot({
                    nodeFrom: M ? o : null,
                    slotFrom: M ? D : null,
                    nodeTo: M ? null : o,
                    slotTo: M ? null : D,
                    position: B,
                    // ,e: e
                    nodeType: "AUTO",
                    // nodeNewType
                    posAdd: [M ? 30 : -30, -A * 130],
                    // -alphaPosY*30]
                    posSizeFix: [M ? 0 : -1, 0]
                    // -alphaPosY*2*/
                  });
                }
              }
            } else !u && this.allow_dragcanvas && (this.dragging_canvas = !0);
          else (n.which == 3 || LiteGraph.two_fingers_opens_menu && this.userInput_isNotPrimary) && this.allow_interaction && !u && !this.read_only && (o && (Object.keys(this.selected_nodes).length && (this.selected_nodes[o.id] || n.shiftKey || n.ctrlKey || n.metaKey) ? this.selected_nodes[o.id] || this.selectNodes([o], !0) : this.selectNodes([o])), this.processContextMenu(o, n));
          return this.last_mouse[0] = n.clientX, this.last_mouse[1] = n.clientY, this.last_mouseclick = LiteGraph.getTime(), this.last_mouse_dragging = !0, this.graph.change(), (!t.document.activeElement || t.document.activeElement.nodeName.toLowerCase() != "input" && t.document.activeElement.nodeName.toLowerCase() != "textarea") && n.preventDefault(), n.stopPropagation(), (tt = this.onMouseDown) == null || tt.call(this, n), !1;
        }
      }
    }
  }
  /**
   * Called when a mouse move event has to be processed
   * @method processMouseMove
   **/
  processMouseMove(n) {
    var f, _;
    if (this.autoresize && this.resize(), this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0), !!this.graph) {
      _LGraphCanvas.active_canvas = this, this.adjustMouseEvent(n);
      var t = [n.clientX, n.clientY];
      this.mouse[0] = t[0], this.mouse[1] = t[1];
      var r = [
        t[0] - this.last_mouse[0],
        t[1] - this.last_mouse[1]
      ];
      if (this.last_mouse = t, this.graph_mouse[0] = n.canvasX, this.graph_mouse[1] = n.canvasY, this.block_click)
        return n.preventDefault(), !1;
      n.dragging = this.last_mouse_dragging, this.node_widget && (this.processNodeWidgets(
        this.node_widget[0],
        this.graph_mouse,
        n,
        this.node_widget[1]
      ), this.dirty_canvas = !0);
      var s = this.graph.getNodeOnPos(n.canvasX, n.canvasY, this.visible_nodes);
      if (this.dragging_rectangle)
        this.dragging_rectangle[2] = n.canvasX - this.dragging_rectangle[0], this.dragging_rectangle[3] = n.canvasY - this.dragging_rectangle[1], this.dirty_canvas = !0;
      else if (this.selected_group && !this.read_only) {
        if (this.selected_group_resizing)
          this.selected_group.size = [
            n.canvasX - this.selected_group.pos[0],
            n.canvasY - this.selected_group.pos[1]
          ];
        else {
          var a = r[0] / this.ds.scale, o = r[1] / this.ds.scale;
          this.selected_group.move(a, o, n.ctrlKey), this.selected_group._nodes.length && (this.dirty_canvas = !0);
        }
        this.dirty_bgcanvas = !0;
      } else if (this.dragging_canvas)
        this.ds.offset[0] += r[0] / this.ds.scale, this.ds.offset[1] += r[1] / this.ds.scale, this.dirty_canvas = !0, this.dirty_bgcanvas = !0;
      else if ((this.allow_interaction || s && s.flags.allow_interaction) && !this.read_only) {
        this.connecting_node && (this.dirty_canvas = !0);
        for (let E = 0, m = this.graph._nodes.length; E < m; ++E)
          this.graph._nodes[E].mouseOver && s != this.graph._nodes[E] && (this.graph._nodes[E].mouseOver = !1, this.node_over && this.node_over.onMouseLeave && this.node_over.onMouseLeave(n), this.node_over = null, this.dirty_canvas = !0);
        if (s) {
          if (s.redraw_on_mouse && (this.dirty_canvas = !0), s.mouseOver || (s.mouseOver = !0, this.node_over = s, this.dirty_canvas = !0, (f = s.onMouseEnter) == null || f.call(s, n)), (_ = s.onMouseMove) == null || _.call(s, n, [n.canvasX - s.pos[0], n.canvasY - s.pos[1]], this), this.connecting_node) {
            let E;
            if (this.connecting_output) {
              if (E = this._highlight_input || [0, 0], !this.isOverNodeBox(s, n.canvasX, n.canvasY)) {
                let m = this.isOverNodeInput(s, n.canvasX, n.canvasY, E);
                if (m != -1 && s.inputs[m]) {
                  let T = s.inputs[m].type;
                  LiteGraph.isValidConnection(this.connecting_output.type, T) && (this._highlight_input = E, this._highlight_input_slot = s.inputs[m]);
                } else
                  this._highlight_input = null, this._highlight_input_slot = null;
              }
            } else if (this.connecting_input && (E = this._highlight_output || [0, 0], this.isOverNodeBox(s, n.canvasX, n.canvasY))) {
              let m = this.isOverNodeOutput(s, n.canvasX, n.canvasY, E);
              if (m != -1 && s.outputs[m]) {
                let T = s.outputs[m].type;
                LiteGraph.isValidConnection(this.connecting_input.type, T) && (this._highlight_output = E);
              } else
                this._highlight_output = null;
            }
          }
          this.canvas && (LiteGraph.isInsideRectangle(
            n.canvasX,
            n.canvasY,
            s.pos[0] + s.size[0] - 5,
            s.pos[1] + s.size[1] - 5,
            5,
            5
          ) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = "crosshair");
        } else {
          var u = null;
          for (let E = 0; E < this.visible_links.length; ++E) {
            var h = this.visible_links[E], l = h._pos;
            if (!(!l || n.canvasX < l[0] - 4 || n.canvasX > l[0] + 4 || n.canvasY < l[1] - 4 || n.canvasY > l[1] + 4)) {
              u = h;
              break;
            }
          }
          u != this.over_link_center && (this.over_link_center = u, this.dirty_canvas = !0), this.canvas && (this.canvas.style.cursor = "");
        }
        if (this.node_capturing_input && this.node_capturing_input != s && this.node_capturing_input.onMouseMove && this.node_capturing_input.onMouseMove(n, [n.canvasX - this.node_capturing_input.pos[0], n.canvasY - this.node_capturing_input.pos[1]], this), this.node_dragged && !this.live_mode) {
          for (let E in this.selected_nodes) {
            let m = this.selected_nodes[E];
            m.pos[0] += r[0] / this.ds.scale, m.pos[1] += r[1] / this.ds.scale, m.is_selected || this.processNodeSelected(m, n);
          }
          this.dirty_canvas = !0, this.dirty_bgcanvas = !0;
        }
        if (this.resizing_node && !this.live_mode) {
          var c = [n.canvasX - this.resizing_node.pos[0], n.canvasY - this.resizing_node.pos[1]], d = this.resizing_node.computeSize();
          c[0] = Math.max(d[0], c[0]), c[1] = Math.max(d[1], c[1]), this.resizing_node.setSize(c), this.canvas.style.cursor = "se-resize", this.dirty_canvas = !0, this.dirty_bgcanvas = !0;
        }
      }
      return n.preventDefault(), !1;
    }
  }
  /**
   * Called when a mouse up event has to be processed
   * @method processMouseUp
   **/
  processMouseUp(n) {
    var O;
    var t = n.isPrimary === void 0 || n.isPrimary;
    if (!t)
      return !1;
    if (this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0), !!this.graph) {
      var r = this.getCanvasWindow(), s = r.document;
      _LGraphCanvas.active_canvas = this, this.options.skip_events || (s.removeEventListener("pointermove", this._mousemove_callback, !0), this.canvas.addEventListener("pointermove", this._mousemove_callback, !0), s.removeEventListener("pointerup", this._mouseup_callback, !0)), this.adjustMouseEvent(n);
      var a = LiteGraph.getTime();
      if (n.click_time = a - this.last_mouseclick, this.last_mouse_dragging = !1, this.last_click_position = null, this.block_click && (this.block_click = !1), n.which == 1) {
        if (this.node_widget && this.processNodeWidgets(this.node_widget[0], this.graph_mouse, n), this.node_widget = null, this.selected_group) {
          var o = this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]), u = this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]);
          this.selected_group.move(o, u, n.ctrlKey), this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]), this.selected_group._nodes.length && (this.dirty_canvas = !0), this.selected_group = null;
        }
        this.selected_group_resizing = !1;
        var h = this.graph.getNodeOnPos(
          n.canvasX,
          n.canvasY,
          this.visible_nodes
        );
        if (this.dragging_rectangle) {
          if (this.graph) {
            var l = this.graph._nodes, c = new Float32Array(4), d = Math.abs(this.dragging_rectangle[2]), f = Math.abs(this.dragging_rectangle[3]), _ = this.dragging_rectangle[2] < 0 ? this.dragging_rectangle[0] - d : this.dragging_rectangle[0], E = this.dragging_rectangle[3] < 0 ? this.dragging_rectangle[1] - f : this.dragging_rectangle[1];
            if (this.dragging_rectangle[0] = _, this.dragging_rectangle[1] = E, this.dragging_rectangle[2] = d, this.dragging_rectangle[3] = f, !h || d > 10 && f > 10) {
              var m = [];
              for (let b = 0; b < l.length; ++b) {
                var T = l[b];
                T.getBounding(c), LiteGraph.overlapBounding(
                  this.dragging_rectangle,
                  c
                ) && m.push(T);
              }
              m.length && this.selectNodes(m, n.shiftKey);
            } else
              this.selectNodes([h], n.shiftKey || n.ctrlKey);
          }
          this.dragging_rectangle = null;
        } else if (this.connecting_node) {
          this.dirty_canvas = !0, this.dirty_bgcanvas = !0;
          var L = this.connecting_output || this.connecting_input, G = L.type;
          if (h = this.graph.getNodeOnPos(
            n.canvasX,
            n.canvasY,
            this.visible_nodes
          ), h) {
            let b;
            this.connecting_output ? (b = this.isOverNodeInput(
              h,
              n.canvasX,
              n.canvasY
            ), b != -1 ? this.connecting_node.connect(this.connecting_slot, h, b) : this.connecting_node.connectByType(this.connecting_slot, h, G)) : this.connecting_input && (b = this.isOverNodeOutput(
              h,
              n.canvasX,
              n.canvasY
            ), b != -1 ? h.connect(b, this.connecting_node, this.connecting_slot) : this.connecting_node.connectByTypeOutput(this.connecting_slot, h, G));
          } else
            LiteGraph.release_link_on_empty_shows_menu && (n.shiftKey && this.allow_searchbox ? this.connecting_output ? this.showSearchBox(n, { node_from: this.connecting_node, slot_from: this.connecting_output, type_filter_in: this.connecting_output.type }) : this.connecting_input && this.showSearchBox(n, { node_to: this.connecting_node, slot_from: this.connecting_input, type_filter_out: this.connecting_input.type }) : this.connecting_output ? this.showConnectionMenu({ nodeFrom: this.connecting_node, slotFrom: this.connecting_output, e: n }) : this.connecting_input && this.showConnectionMenu({ nodeTo: this.connecting_node, slotTo: this.connecting_input, e: n }));
          this.connecting_output = null, this.connecting_input = null, this.connecting_pos = null, this.connecting_node = null, this.connecting_slot = -1;
        } else this.resizing_node ? (this.dirty_canvas = !0, this.dirty_bgcanvas = !0, this.graph.afterChange(this.resizing_node), this.resizing_node = null) : this.node_dragged ? (h = this.node_dragged, h && n.click_time < 300 && LiteGraph.isInsideRectangle(n.canvasX, n.canvasY, h.pos[0], h.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT) && h.collapse(), this.dirty_canvas = !0, this.dirty_bgcanvas = !0, this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]), this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]), (this.graph.config.align_to_grid || this.align_to_grid) && this.node_dragged.alignToGrid(), (O = this.onNodeMoved) == null || O.call(this, this.node_dragged), this.graph.onGraphChanged({ action: "nodeDrag", doSave: !0 }), this.graph.afterChange(this.node_dragged), this.node_dragged = null) : (h = this.graph.getNodeOnPos(
          n.canvasX,
          n.canvasY,
          this.visible_nodes
        ), !h && n.click_time < 300 && this.deselectAllNodes(), this.dirty_canvas = !0, this.dragging_canvas = !1, this.node_over && this.node_over.onMouseUp && this.node_over.onMouseUp(n, [n.canvasX - this.node_over.pos[0], n.canvasY - this.node_over.pos[1]], this), this.node_capturing_input && this.node_capturing_input.onMouseUp && this.node_capturing_input.onMouseUp(n, [
          n.canvasX - this.node_capturing_input.pos[0],
          n.canvasY - this.node_capturing_input.pos[1]
        ]));
      } else n.which == 2 ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : n.which == 3 && (this.dirty_canvas = !0, this.dragging_canvas = !1);
      return t && (this.pointer_is_down = !1, this.pointer_is_double = !1), this.graph.change(), n.stopPropagation(), n.preventDefault(), !1;
    }
  }
  /**
   * returns true if a position (in graph space) is on top of a node little corner box
   * @method isOverNodeBox
   **/
  isOverNodeBox(n, t, r) {
    var s = LiteGraph.NODE_TITLE_HEIGHT;
    return !!LiteGraph.isInsideRectangle(
      t,
      r,
      n.pos[0] + 2,
      n.pos[1] + 2 - s,
      s - 4,
      s - 4
    );
  }
  /**
   * returns the INDEX if a position (in graph space) is on top of a node input slot
   * @method isOverNodeInput
   **/
  isOverNodeInput(n, t, r, s) {
    if (n.inputs)
      for (let u = 0, h = n.inputs.length; u < h; ++u) {
        var a = n.getConnectionPos(!0, u), o = !1;
        if (n.horizontal ? o = LiteGraph.isInsideRectangle(
          t,
          r,
          a[0] - 5,
          a[1] - 10,
          10,
          20
        ) : o = LiteGraph.isInsideRectangle(
          t,
          r,
          a[0] - 10,
          a[1] - 5,
          40,
          10
        ), o)
          return s && (s[0] = a[0], s[1] = a[1]), u;
      }
    return -1;
  }
  /**
   * returns the INDEX if a position (in graph space) is on top of a node output slot
   * @method isOverNodeOuput
   **/
  isOverNodeOutput(n, t, r, s) {
    if (n.outputs)
      for (let u = 0, h = n.outputs.length; u < h; ++u) {
        var a = n.getConnectionPos(!1, u), o = !1;
        if (n.horizontal ? o = LiteGraph.isInsideRectangle(
          t,
          r,
          a[0] - 5,
          a[1] - 10,
          10,
          20
        ) : o = LiteGraph.isInsideRectangle(
          t,
          r,
          a[0] - 10,
          a[1] - 5,
          40,
          10
        ), o)
          return s && (s[0] = a[0], s[1] = a[1]), u;
      }
    return -1;
  }
  copyToClipboard() {
    var l;
    var n = {
      nodes: [],
      links: []
    }, t = 0, r = [];
    for (let c in this.selected_nodes) {
      let d = this.selected_nodes[c];
      d.clonable !== !1 && (d._relative_id = t, r.push(d), t += 1);
    }
    for (let c = 0; c < r.length; ++c) {
      let d = r[c];
      if (d.clonable !== !1) {
        var s = d.clone();
        if (!s) {
          (l = LiteGraph.warn) == null || l.call(LiteGraph, "node type not found: " + d.type);
          continue;
        }
        if (n.nodes.push(s.serialize()), d.inputs && d.inputs.length)
          for (var a = 0; a < d.inputs.length; ++a) {
            var o = d.inputs[a];
            if (!(!o || o.link == null)) {
              var u = this.graph.links[o.link];
              if (u) {
                var h = this.graph.getNodeById(u.origin_id);
                h && n.links.push([
                  h._relative_id,
                  u.origin_slot,
                  // j,
                  d._relative_id,
                  u.target_slot,
                  h.id
                ]);
              }
            }
          }
      }
    }
    localStorage.setItem(
      "litegrapheditor_clipboard",
      JSON.stringify(n)
    );
  }
  pasteFromClipboard(n = !1) {
    var E;
    if (!(!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && n)) {
      var t = localStorage.getItem("litegrapheditor_clipboard");
      if (t) {
        this.graph.beforeChange();
        var r = JSON.parse(t), s = !1, a = !1;
        for (let m = 0; m < r.nodes.length; ++m)
          s ? (s[0] > r.nodes[m].pos[0] && (s[0] = r.nodes[m].pos[0], a[0] = m), s[1] > r.nodes[m].pos[1] && (s[1] = r.nodes[m].pos[1], a[1] = m)) : (s = [r.nodes[m].pos[0], r.nodes[m].pos[1]], a = [m, m]);
        var o = [];
        for (let m = 0; m < r.nodes.length; ++m) {
          var u = r.nodes[m], h = LiteGraph.createNode(u.type);
          h && (h.configure(u), h.pos[0] += this.graph_mouse[0] - s[0], h.pos[1] += this.graph_mouse[1] - s[1], this.graph.add(h, { doProcessChange: !1 }), o.push(h));
        }
        for (let m = 0; m < r.links.length; ++m) {
          var l = r.links[m], c = void 0, d = l[0];
          if (d != null)
            c = o[d];
          else if (LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && n) {
            var f = l[4];
            f && (c = this.graph.getNodeById(f));
          }
          var _ = o[l[2]];
          c && _ ? c.connect(l[1], _, l[3]) : (E = LiteGraph.warn) == null || E.call(LiteGraph, "Warning, nodes missing on pasting");
        }
        this.selectNodes(o), this.graph.onGraphChanged({ action: "paste", doSave: !0 }), this.graph.afterChange();
      }
    }
  }
  // called if the graph doesn't have a default drop item behaviour
  checkDropItem(n) {
    var o;
    if (n.dataTransfer.files.length) {
      var t = n.dataTransfer.files[0], r = _LGraphCanvas.getFileExtension(t.name).toLowerCase(), s = LiteGraph.node_types_by_file_extension[r];
      if (s) {
        this.graph.beforeChange();
        var a = LiteGraph.createNode(s.type);
        a.pos = [n.canvasX, n.canvasY], this.graph.add(a, !1, { doProcessChange: !1 }), (o = a.onDropFile) == null || o.call(a, t), this.graph.onGraphChanged({ action: "fileDrop", doSave: !0 }), this.graph.afterChange();
      }
    }
  }
  processNodeDblClicked(n) {
    var t;
    this.onShowNodePanel ? this.onShowNodePanel(n) : this.showShowNodePanel(n), (t = this.onNodeDblClicked) == null || t.call(this, n), this.setDirty(!0);
  }
  processNodeSelected(n, t) {
    var r;
    this.selectNode(n, t && (t.shiftKey || t.ctrlKey || this.multi_select)), (r = this.onNodeSelected) == null || r.call(this, n);
  }
  /**
   * selects a given node (or adds it to the current selection)
   * @method selectNode
   **/
  selectNode(n, t) {
    n == null ? this.deselectAllNodes() : this.selectNodes([n], t);
  }
  /**
   * selects several nodes (or adds them to the current selection)
   * @method selectNodes
   **/
  selectNodes(n, t) {
    var r;
    t || this.deselectAllNodes(), n = n || this.graph._nodes, typeof n == "string" && (n = [n]), Object.values(n).forEach((s) => {
      var a, o, u;
      if (s.is_selected) {
        this.deselectNode(s);
        return;
      }
      s.is_selected = !0, this.selected_nodes[s.id] = s, (a = s.onSelected) == null || a.call(s), (o = s.inputs) == null || o.forEach((h) => {
        this.highlighted_links[h.link] = !0;
      }), (u = s.outputs) == null || u.forEach((h) => {
        var l;
        (l = h.links) == null || l.forEach((c) => {
          this.highlighted_links[c] = !0;
        });
      });
    }), (r = this.onSelectionChange) == null || r.call(this, this.selected_nodes), this.setDirty(!0);
  }
  /**
   * removes a node from the current selection
   * @method deselectNode
   **/
  deselectNode(n) {
    var t, r, s, a;
    n.is_selected && ((t = n.onDeselected) == null || t.call(n), n.is_selected = !1, (r = this.onNodeDeselected) == null || r.call(this, n), (s = n.inputs) == null || s.forEach((o) => {
      var u;
      (u = this.highlighted_links) == null || delete u[o.link];
    }), (a = n.outputs) == null || a.forEach((o) => {
      var u;
      (u = o.links) == null || u.forEach((h) => {
        var l;
        return (l = this.highlighted_links) == null ? !0 : delete l[h];
      });
    }));
  }
  /**
   * removes all nodes from the current selection
   * @method deselectAllNodes
   **/
  deselectAllNodes() {
    var n, t;
    this.graph && ((n = this.graph._nodes) == null || n.forEach((r) => {
      var s, a;
      r.is_selected && ((s = r.onDeselected) == null || s.call(r), r.is_selected = !1, (a = this.onNodeDeselected) == null || a.call(this, r));
    }), this.selected_nodes = {}, this.current_node = null, this.highlighted_links = {}, (t = this.onSelectionChange) == null || t.call(this, this.selected_nodes), this.setDirty(!0));
  }
  /**
   * deletes all nodes in the current selection from the graph
   * @method deleteSelectedNodes
   **/
  deleteSelectedNodes() {
    this.graph.beforeChange();
    for (let o in this.selected_nodes) {
      var n = this.selected_nodes[o];
      if (!n.block_delete) {
        if (n.inputs && n.inputs.length && n.outputs && n.outputs.length && LiteGraph.isValidConnection(n.inputs[0].type, n.outputs[0].type) && n.inputs[0].link && n.outputs[0].links && n.outputs[0].links.length) {
          var t = n.graph.links[n.inputs[0].link], r = n.graph.links[n.outputs[0].links[0]], s = n.getInputNode(0), a = n.getOutputNodes(0)[0];
          s && a && s.connect(t.origin_slot, a, r.target_slot);
        }
        this.graph.remove(n), this.onNodeDeselected && this.onNodeDeselected(n);
      }
    }
    this.selected_nodes = {}, this.current_node = null, this.highlighted_links = {}, this.setDirty(!0), this.graph.afterChange();
  }
  /**
   * centers the camera on a given node
   * @method centerOnNode
   **/
  centerOnNode(n) {
    this.ds.offset[0] = -n.pos[0] - n.size[0] * 0.5 + this.canvas.width * 0.5 / this.ds.scale, this.ds.offset[1] = -n.pos[1] - n.size[1] * 0.5 + this.canvas.height * 0.5 / this.ds.scale, this.setDirty(!0, !0);
  }
  /**
   * adds some useful properties to a mouse event, like the position in graph coordinates
   * @method adjustMouseEvent
   **/
  adjustMouseEvent(n) {
    var t = 0, r = 0;
    if (this.canvas) {
      var s = this.canvas.getBoundingClientRect();
      t = n.clientX - s.left, r = n.clientY - s.top;
    } else
      t = n.clientX, r = n.clientY;
    this.last_mouse_position[0] = t, this.last_mouse_position[1] = r, n.canvasX = t / this.ds.scale - this.ds.offset[0], n.canvasY = r / this.ds.scale - this.ds.offset[1];
  }
  /**
   * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom
   * @method setZoom
   **/
  setZoom(n, t) {
    this.ds.changeScale(n, t), this.dirty_canvas = !0, this.dirty_bgcanvas = !0;
  }
  /**
   * converts a coordinate from graph coordinates to canvas2D coordinates
   * @method convertOffsetToCanvas
   **/
  convertOffsetToCanvas(n, t) {
    return this.ds.convertOffsetToCanvas(n, t);
  }
  /**
   * converts a coordinate from Canvas2D coordinates to graph space
   * @method convertCanvasToOffset
   **/
  convertCanvasToOffset(n, t) {
    return this.ds.convertCanvasToOffset(n, t);
  }
  // converts event coordinates from canvas2D to graph coordinates
  convertEventToCanvasOffset(n) {
    var t = this.canvas.getBoundingClientRect();
    return this.convertCanvasToOffset([
      n.clientX - t.left,
      n.clientY - t.top
    ]);
  }
  /**
   * brings a node to front (above all other nodes)
   * @method bringToFront
   **/
  bringToFront(n) {
    var t = this.graph._nodes.indexOf(n);
    t != -1 && (this.graph._nodes.splice(t, 1), this.graph._nodes.push(n));
  }
  /**
   * sends a node to the back (below all other nodes)
   * @method sendToBack
   **/
  sendToBack(n) {
    var t = this.graph._nodes.indexOf(n);
    t != -1 && (this.graph._nodes.splice(t, 1), this.graph._nodes.unshift(n));
  }
  /**
   * checks which nodes are visible (inside the camera area)
   * @method computeVisibleNodes
   **/
  computeVisibleNodes(n, t) {
    var r = t || [];
    r.length = 0, n = n || this.graph._nodes;
    for (var s = 0, a = n.length; s < a; ++s) {
      var o = n[s];
      this.live_mode && !o.onDrawBackground && !o.onDrawForeground || LiteGraph.overlapBounding(this.visible_area, o.getBounding(temp, !0)) && r.push(o);
    }
    return r;
  }
  /**
   * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)
   * @method draw
   **/
  draw(n, t) {
    if (!(!this.canvas || this.canvas.width == 0 || this.canvas.height == 0)) {
      var r = LiteGraph.getTime();
      this.render_time = (r - this.last_draw_time) * 1e-3, this.last_draw_time = r, this.graph && this.ds.computeVisibleArea(this.viewport), (this.dirty_bgcanvas || t || this.always_render_background || this.graph && this.graph._last_trigger_time && r - this.graph._last_trigger_time < 1e3) && this.drawBackCanvas();
      var s = this.dirty_canvas || n;
      if (s && this.drawFrontCanvas(), this.fps = this.render_time ? 1 / this.render_time : 0, this.frame += 1, this.ds.scale < 0.7) {
        if (s) {
          var a = this.low_quality_rendering_threshold;
          const o = 45;
          this.fps < o ? (this.low_quality_rendering_counter += o / this.fps, this.low_quality_rendering_counter = Math.min(this.low_quality_rendering_counter, 2 * a)) : (this.low_quality_rendering_counter -= this.fps / o * 0.01, this.low_quality_rendering_counter = Math.max(this.low_quality_rendering_counter, 0));
        }
      } else
        this.low_quality_rendering_counter = 0;
    }
  }
  /**
   * draws the front canvas (the one containing all the nodes)
   * @method drawFrontCanvas
   **/
  drawFrontCanvas() {
    var d, f, _, E, m;
    this.dirty_canvas = !1, this.ctx || (this.ctx = this.bgcanvas.getContext("2d"));
    var n = this.ctx;
    if (n) {
      var t = this.canvas;
      n.start2D && !this.viewport && (n.start2D(), n.restore(), n.setTransform(1, 0, 0, 1, 0, 0));
      var r = this.viewport || this.dirty_area;
      if (r && (n.save(), n.beginPath(), n.rect(r[0], r[1], r[2], r[3]), n.clip()), this.clear_background && (r ? n.clearRect(r[0], r[1], r[2], r[3]) : n.clearRect(0, 0, t.width, t.height)), this.bgcanvas == this.canvas ? this.drawBackCanvas() : n.drawImage(this.bgcanvas, 0, 0), (d = this.onRender) == null || d.call(this, t, n), this.show_info && this.renderInfo(n, r ? r[0] : 0, r ? r[1] : 0), this.graph) {
        n.save(), this.ds.toCanvasContext(n);
        var s = this.computeVisibleNodes(
          null,
          this.visible_nodes
        );
        for (let T = 0; T < s.length; ++T) {
          let L = s[T];
          n.save(), n.translate(L.pos[0], L.pos[1]), this.drawNode(L, n), n.restore();
        }
        if (this.render_execution_order && this.drawExecutionOrder(n), this.graph.config.links_ontop && (this.live_mode || this.drawConnections(n)), this.connecting_pos != null) {
          n.lineWidth = this.connections_width;
          var a = null, o = this.connecting_output || this.connecting_input, u = o.type, h = o.dir;
          h == null && (this.connecting_output ? h = this.connecting_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT : h = this.connecting_node.horizontal ? LiteGraph.UP : LiteGraph.LEFT);
          var l = o.shape;
          switch (u) {
            case LiteGraph.EVENT:
            case LiteGraph.ACTION:
              a = LiteGraph.EVENT_LINK_COLOR;
              break;
            default:
              a = LiteGraph.CONNECTING_LINK_COLOR;
          }
          if (this.renderLink(
            n,
            this.connecting_pos,
            [this.graph_mouse[0], this.graph_mouse[1]],
            null,
            !1,
            null,
            a,
            h,
            LiteGraph.CENTER
          ), n.beginPath(), u === LiteGraph.EVENT || u === LiteGraph.ACTION || l === LiteGraph.BOX_SHAPE ? (n.rect(
            this.connecting_pos[0] - 6 + 0.5,
            this.connecting_pos[1] - 5 + 0.5,
            14,
            10
          ), n.fill(), n.beginPath(), n.rect(
            this.graph_mouse[0] - 6 + 0.5,
            this.graph_mouse[1] - 5 + 0.5,
            14,
            10
          )) : l === LiteGraph.ARROW_SHAPE ? (n.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5), n.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5), n.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5), n.closePath()) : (n.arc(
            this.connecting_pos[0],
            this.connecting_pos[1],
            4,
            0,
            Math.PI * 2
          ), n.fill(), n.beginPath(), n.arc(
            this.graph_mouse[0],
            this.graph_mouse[1],
            4,
            0,
            Math.PI * 2
          )), n.fill(), n.fillStyle = "#ffcc00", this._highlight_input) {
            n.beginPath();
            var c = this._highlight_input_slot.shape;
            c === LiteGraph.ARROW_SHAPE ? (n.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5), n.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5), n.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5), n.closePath()) : n.arc(
              this._highlight_input[0],
              this._highlight_input[1],
              6,
              0,
              Math.PI * 2
            ), n.fill();
          }
          this._highlight_output && (n.beginPath(), c === LiteGraph.ARROW_SHAPE ? (n.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5), n.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5), n.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5), n.closePath()) : n.arc(
            this._highlight_output[0],
            this._highlight_output[1],
            6,
            0,
            Math.PI * 2
          ), n.fill());
        }
        this.dragging_rectangle && (n.strokeStyle = "#FFF", n.strokeRect(
          this.dragging_rectangle[0],
          this.dragging_rectangle[1],
          this.dragging_rectangle[2],
          this.dragging_rectangle[3]
        )), this.over_link_center && this.render_link_tooltip ? this.drawLinkTooltip(n, this.over_link_center) : (f = this.onDrawLinkTooltip) == null || f.call(this, n, null), (_ = this.onDrawForeground) == null || _.call(this, n, this.visible_rect), n.restore();
      }
      this._graph_stack && this._graph_stack.length && this.drawSubgraphPanel(n), (E = this.onDrawOverlay) == null || E.call(this, n), r && n.restore(), (m = n.finish2D) == null || m.call(n);
    }
  }
  /**
   * draws the panel in the corner that shows subgraph properties
   * @method drawSubgraphPanel
   **/
  drawSubgraphPanel(n) {
    var s;
    var t = this.graph;
    if (t) {
      var r = t._subgraph_node;
      if (!r) {
        (s = LiteGraph.warn) == null || s.call(LiteGraph, "subgraph without subnode");
        return;
      }
      this.drawSubgraphPanelLeft(t, r, n), this.drawSubgraphPanelRight(t, r, n);
    }
  }
  drawSubgraphPanelLeft(n, t, r) {
    var f;
    var s = t.inputs ? t.inputs.length : 0, a = 200, o = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
    if (r.fillStyle = "#111", r.globalAlpha = 0.8, r.beginPath(), r.roundRect(10, 10, a, (s + 1) * o + 50, [8]), r.fill(), r.globalAlpha = 1, r.fillStyle = "#888", r.font = "14px Arial", r.textAlign = "left", r.fillText("Graph Inputs", 20, 34), this.drawButton(a - 20, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
      return;
    }
    var u = 50;
    if (r.font = "14px Arial", t.inputs)
      for (var h = 0; h < t.inputs.length; ++h) {
        var l = t.inputs[h];
        if (!l.not_subgraph_input) {
          if (this.drawButton(20, u + 2, a - 20, o - 2)) {
            var c = t.constructor.input_node_type || "graph/input";
            this.graph.beforeChange();
            var d = LiteGraph.createNode(c);
            d ? (n.add(d, !1, { doProcessChange: !1 }), this.block_click = !1, this.last_click_position = null, this.selectNodes([d]), this.node_dragged = d, this.dragging_canvas = !1, d.setProperty("name", l.name), d.setProperty("type", l.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : (f = LiteGraph.error) == null || f.call(LiteGraph, "graph input node not found:", c);
          }
          r.fillStyle = "#9C9", r.beginPath(), r.arc(a - 16, u + o * 0.5, 5, 0, 2 * Math.PI), r.fill(), r.fillStyle = "#AAA", r.fillText(l.name, 30, u + o * 0.75), r.fillStyle = "#777", r.fillText(l.type, 130, u + o * 0.75), u += o;
        }
      }
    this.drawButton(20, u + 2, a - 20, o - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialog(t);
  }
  drawSubgraphPanelRight(n, t, r) {
    var m;
    var s = t.outputs ? t.outputs.length : 0, a = this.bgcanvas.width, o = 200, u = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);
    r.fillStyle = "#111", r.globalAlpha = 0.8, r.beginPath(), r.roundRect(a - o - 10, 10, o, (s + 1) * u + 50, [8]), r.fill(), r.globalAlpha = 1, r.fillStyle = "#888", r.font = "14px Arial", r.textAlign = "left";
    const h = "Graph Outputs";
    var l = r.measureText(h).width;
    if (r.fillText(h, a - l - 20, 34), this.drawButton(a - o, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
      return;
    }
    var c = 50;
    if (r.font = "14px Arial", t.outputs)
      for (var d = 0; d < t.outputs.length; ++d) {
        var f = t.outputs[d];
        if (!f.not_subgraph_input) {
          if (this.drawButton(a - o, c + 2, o - 20, u - 2)) {
            var _ = t.constructor.output_node_type || "graph/output";
            this.graph.beforeChange();
            var E = LiteGraph.createNode(_);
            E ? (n.add(E, !1, { doProcessChange: !1 }), this.block_click = !1, this.last_click_position = null, this.selectNodes([E]), this.node_dragged = E, this.dragging_canvas = !1, E.setProperty("name", f.name), E.setProperty("type", f.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : (m = LiteGraph.error) == null || m.call(LiteGraph, "graph input node not found:", _);
          }
          r.fillStyle = "#9C9", r.beginPath(), r.arc(a - o + 16, c + u * 0.5, 5, 0, 2 * Math.PI), r.fill(), r.fillStyle = "#AAA", r.fillText(f.name, a - o + 30, c + u * 0.75), r.fillStyle = "#777", r.fillText(f.type, a - o + 130, c + u * 0.75), c += u;
        }
      }
    this.drawButton(a - o, c + 2, o - 20, u - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialogRight(t);
  }
  // Draws a button into the canvas overlay and computes if it was clicked using the immediate gui paradigm
  drawButton(n, t, r, s, a, o, u, h) {
    var l = this.ctx;
    o = o || LiteGraph.NODE_DEFAULT_COLOR, u = u || "#555", h = h || LiteGraph.NODE_TEXT_COLOR;
    var c = this.ds.convertOffsetToCanvas(this.graph_mouse), d = LiteGraph.isInsideRectangle(c[0], c[1], n, t, r, s);
    if (c = this.last_click_position ? [this.last_click_position[0], this.last_click_position[1]] : null, c) {
      var f = this.canvas.getBoundingClientRect();
      c[0] -= f.left, c[1] -= f.top;
    }
    var _ = c && LiteGraph.isInsideRectangle(c[0], c[1], n, t, r, s);
    l.fillStyle = d ? u : o, _ && (l.fillStyle = "#AAA"), l.beginPath(), l.roundRect(n, t, r, s, [4]), l.fill(), a != null && a.constructor == String && (l.fillStyle = h, l.textAlign = "center", l.font = (s * 0.65 | 0) + "px Arial", l.fillText(a, n + r * 0.5, t + s * 0.75), l.textAlign = "left");
    var E = _ && !this.block_click;
    return _ && this.blockClick(), E;
  }
  isAreaClicked(n, t, r, s, a) {
    var o = this.last_click_position, u = o && LiteGraph.isInsideRectangle(o[0], o[1], n, t, r, s), h = u && !this.block_click;
    return u && a && this.blockClick(), h;
  }
  /**
   * draws some useful stats in the corner of the canvas
   * @method renderInfo
   **/
  renderInfo(n, t, r) {
    t = t || 10, r = r || this.canvas.height - 80, n.save(), n.translate(t, r), n.font = "10px Arial", n.fillStyle = "#888", n.textAlign = "left", this.graph ? (n.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), n.fillText("I: " + this.graph.iteration, 5, 26), n.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 39), n.fillText("V: " + this.graph._version, 5, 52), n.fillText("FPS:" + this.fps.toFixed(2), 5, 65)) : n.fillText("No graph selected", 5, 13), n.restore();
  }
  /**
   * draws the back canvas (the one containing the background and the connections)
   * @method drawBackCanvas
   **/
  drawBackCanvas() {
    var h, l, c;
    var n = this.bgcanvas;
    this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d"));
    var t = this.bgctx;
    t.start && t.start();
    var r = this.viewport || [0, 0, t.canvas.width, t.canvas.height];
    if (this.clear_background && t.clearRect(r[0], r[1], r[2], r[3]), this._graph_stack && this._graph_stack.length) {
      t.save();
      var s = this.graph._subgraph_node;
      t.strokeStyle = s.bgcolor, t.lineWidth = 10, t.strokeRect(1, 1, n.width - 2, n.height - 2), t.lineWidth = 1, t.font = "40px Arial", t.textAlign = "center", t.fillStyle = s.bgcolor || "#AAA";
      let d = "";
      this._graph_stack.slice(1).forEach((f, _) => {
        d += `${f._subgraph_node.getTitle()} ${_ < this._graph_stack.length - 2 ? ">> " : ""}`;
      }), t.fillText(
        d + s.getTitle(),
        n.width * 0.5,
        40
      ), t.restore();
    }
    var a = !1;
    if (this.onRenderBackground && (a = this.onRenderBackground(n, t)), this.viewport || (t.restore(), t.setTransform(1, 0, 0, 1, 0, 0)), this.visible_links.length = 0, this.graph) {
      if (t.save(), this.ds.toCanvasContext(t), this.ds.scale < 1.5 && !a && this.clear_background_color && (t.fillStyle = this.clear_background_color, t.fillRect(
        this.visible_area[0],
        this.visible_area[1],
        this.visible_area[2],
        this.visible_area[3]
      )), this.background_image && this.ds.scale > 0.5 && !a) {
        if (this.zoom_modify_alpha ? t.globalAlpha = (1 - 0.5 / this.ds.scale) * this.editor_alpha : t.globalAlpha = this.editor_alpha, t.imageSmoothingEnabled = t.imageSmoothingEnabled = !1, !this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image(), this._bg_img.name = this.background_image, this._bg_img.src = this.background_image;
          var o = this;
          this._bg_img.onload = function() {
            o.draw(!0, !0);
          };
        }
        var u = null;
        this._pattern == null && this._bg_img.width > 0 ? (u = t.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = u) : u = this._pattern, u && (t.fillStyle = u, t.fillRect(
          this.visible_area[0],
          this.visible_area[1],
          this.visible_area[2],
          this.visible_area[3]
        ), t.fillStyle = "transparent"), t.globalAlpha = 1, t.imageSmoothingEnabled = t.imageSmoothingEnabled = !0;
      }
      this.graph._groups.length && !this.live_mode && this.drawGroups(n, t), (h = this.onDrawBackground) == null || h.call(this, t, this.visible_area), this.onBackgroundRender && ((l = LiteGraph.error) == null || l.call(LiteGraph, "WARNING! onBackgroundRender deprecated, now is named onDrawBackground "), this.onBackgroundRender = null), this.render_canvas_border && (t.strokeStyle = "#235", t.strokeRect(0, 0, n.width, n.height)), this.render_connections_shadows ? (t.shadowColor = "#000", t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 6) : t.shadowColor = "rgba(0,0,0,0)", this.live_mode || this.drawConnections(t), t.shadowColor = "rgba(0,0,0,0)", t.restore();
    }
    (c = t.finish) == null || c.call(t), this.dirty_bgcanvas = !1, this.dirty_canvas = !0;
  }
  /**
   * draws the given node inside the canvas
   * @method drawNode
   **/
  drawNode(n, t) {
    var I, S, N;
    this.current_node = n;
    var r = n.color || n.constructor.color || LiteGraph.NODE_DEFAULT_COLOR, s = n.bgcolor || n.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR, a = this.ds.scale < 0.6;
    if (this.live_mode) {
      n.flags.collapsed || (t.shadowColor = "transparent", (I = n.onDrawForeground) == null || I.call(n, t, this, this.canvas));
      return;
    }
    var o = this.editor_alpha;
    if (t.globalAlpha = o, this.render_shadows && !a ? (t.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR, t.shadowOffsetX = 2 * this.ds.scale, t.shadowOffsetY = 2 * this.ds.scale, t.shadowBlur = 3 * this.ds.scale) : t.shadowColor = "transparent", !(n.flags.collapsed && ((S = n.onDrawCollapsed) != null && S.call(n, t, this)))) {
      var u = n._shape || LiteGraph.BOX_SHAPE, h = temp_vec2;
      temp_vec2.set(n.size);
      var l = n.horizontal;
      if (n.flags.collapsed) {
        t.font = this.inner_text_font;
        var c = n.getTitle ? n.getTitle() : n.title;
        c != null && (n._collapsed_width = Math.min(
          n.size[0],
          t.measureText(c).width + LiteGraph.NODE_TITLE_HEIGHT * 2
        ), h[0] = n._collapsed_width, h[1] = 0);
      }
      (n.clip_area || this.clip_all_nodes) && (t.save(), t.beginPath(), u == LiteGraph.BOX_SHAPE ? t.rect(0, 0, h[0], h[1]) : u == LiteGraph.ROUND_SHAPE ? t.roundRect(0, 0, h[0], h[1], [10]) : u == LiteGraph.CIRCLE_SHAPE && t.arc(
        h[0] * 0.5,
        h[1] * 0.5,
        h[0] * 0.5,
        0,
        Math.PI * 2
      ), t.clip()), n.has_errors && (s = "red"), this.drawNodeShape(
        n,
        t,
        h,
        r,
        s,
        n.is_selected,
        n.mouseOver
      ), t.shadowColor = "transparent", (N = n.onDrawForeground) == null || N.call(n, t, this, this.canvas), LiteGraph.show_node_tooltip && n.mouseOver && n.is_selected && (!this.selected_nodes || Object.keys(this.selected_nodes).length <= 1) && this.drawNodeTooltip(t, n), t.textAlign = l ? "center" : "left", t.font = this.inner_text_font;
      var d = !this.lowQualityRenderingRequired(0.6), f = this.connecting_output, _ = this.connecting_input;
      t.lineWidth = 1;
      var E = 0, m = new Float32Array(2), T;
      if (n.flags.collapsed) {
        if (this.render_collapsed_slots) {
          var G = null, O = null;
          if (n.inputs)
            for (let C = 0; C < n.inputs.length; C++) {
              var b = n.inputs[C];
              if (b.link != null) {
                G = b;
                break;
              }
            }
          if (n.outputs)
            for (let C = 0; C < n.outputs.length; C++) {
              var b = n.outputs[C];
              !b.links || !b.links.length || (O = b);
            }
          if (G) {
            let C = 0, D = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
            l && (C = n._collapsed_width * 0.5, D = -LiteGraph.NODE_TITLE_HEIGHT), t.fillStyle = "#686", t.beginPath(), b.type === LiteGraph.EVENT || b.type === LiteGraph.ACTION || b.shape === LiteGraph.BOX_SHAPE ? t.rect(C - 7 + 0.5, D - 4, 14, 8) : b.shape === LiteGraph.ARROW_SHAPE ? (t.moveTo(C + 8, D), t.lineTo(C + -4, D - 4), t.lineTo(C + -4, D + 4), t.closePath()) : t.arc(C, D, 4, 0, Math.PI * 2), t.fill();
          }
          if (O) {
            let C = n._collapsed_width, D = LiteGraph.NODE_TITLE_HEIGHT * -0.5;
            l && (C = n._collapsed_width * 0.5, D = 0), t.fillStyle = "#686", t.strokeStyle = "black", t.beginPath(), b.type === LiteGraph.EVENT || b.type === LiteGraph.ACTION || b.shape === LiteGraph.BOX_SHAPE ? t.rect(C - 7 + 0.5, D - 4, 14, 8) : b.shape === LiteGraph.ARROW_SHAPE ? (t.moveTo(C + 6, D), t.lineTo(C - 6, D - 4), t.lineTo(C - 6, D + 4), t.closePath()) : t.arc(C, D, 4, 0, Math.PI * 2), t.fill();
          }
        }
      } else {
        if (n.inputs)
          for (let C = 0; C < n.inputs.length; C++) {
            let D = n.inputs[C], M = D.type, P = D.shape;
            t.globalAlpha = o, this.connecting_output && !LiteGraph.isValidConnection(D.type, f.type) && (t.globalAlpha = 0.4 * o), t.fillStyle = D.link != null ? D.color_on || this.default_connection_color_byType[M] || this.default_connection_color.input_on : D.color_off || this.default_connection_color_byTypeOff[M] || this.default_connection_color_byType[M] || this.default_connection_color.input_off;
            let A = n.getConnectionPos(!0, C, m);
            if (A[0] -= n.pos[0], A[1] -= n.pos[1], E < A[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5 && (E = A[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5), t.beginPath(), M == "array" ? P = LiteGraph.GRID_SHAPE : D.name == "onTrigger" || D.name == "onExecuted" ? P = LiteGraph.ARROW_SHAPE : (M === LiteGraph.EVENT || M === LiteGraph.ACTION) && (P = LiteGraph.BOX_SHAPE), T = !0, P === LiteGraph.BOX_SHAPE ? l ? t.rect(
              A[0] - 5 + 0.5,
              A[1] - 8 + 0.5,
              10,
              14
            ) : t.rect(
              A[0] - 6 + 0.5,
              A[1] - 5 + 0.5,
              14,
              10
            ) : P === LiteGraph.ARROW_SHAPE ? (t.moveTo(A[0] + 8, A[1] + 0.5), t.lineTo(A[0] - 4, A[1] + 6 + 0.5), t.lineTo(A[0] - 4, A[1] - 6 + 0.5), t.closePath()) : P === LiteGraph.GRID_SHAPE ? (t.rect(A[0] - 4, A[1] - 4, 2, 2), t.rect(A[0] - 1, A[1] - 4, 2, 2), t.rect(A[0] + 2, A[1] - 4, 2, 2), t.rect(A[0] - 4, A[1] - 1, 2, 2), t.rect(A[0] - 1, A[1] - 1, 2, 2), t.rect(A[0] + 2, A[1] - 1, 2, 2), t.rect(A[0] - 4, A[1] + 2, 2, 2), t.rect(A[0] - 1, A[1] + 2, 2, 2), t.rect(A[0] + 2, A[1] + 2, 2, 2), T = !1) : a ? t.rect(A[0] - 4, A[1] - 4, 8, 8) : t.arc(A[0], A[1], 4, 0, Math.PI * 2), t.fill(), d && !(D.name == "onTrigger" || D.name == "onExecuted")) {
              let R = D.label != null ? D.label : D.name;
              R && (t.fillStyle = LiteGraph.NODE_TEXT_COLOR, l || D.dir == LiteGraph.UP ? t.fillText(R, A[0], A[1] - 10) : t.fillText(R, A[0] + 10, A[1] + 5));
            }
          }
        if (t.textAlign = l ? "center" : "right", t.strokeStyle = "black", n.outputs)
          for (let C = 0; C < n.outputs.length; C++) {
            let D = n.outputs[C], M = D.type, P = D.shape;
            this.connecting_input && !LiteGraph.isValidConnection(M, _.type) && (t.globalAlpha = 0.4 * o);
            let A = n.getConnectionPos(!1, C, m);
            if (A[0] -= n.pos[0], A[1] -= n.pos[1], E < A[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5 && (E = A[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5), t.fillStyle = D.links && D.links.length ? D.color_on || this.default_connection_color_byType[M] || this.default_connection_color.output_on : D.color_off || this.default_connection_color_byTypeOff[M] || this.default_connection_color_byType[M] || this.default_connection_color.output_off, t.beginPath(), M == "array" ? P = LiteGraph.GRID_SHAPE : D.name == "onTrigger" || D.name == "onExecuted" ? P = LiteGraph.ARROW_SHAPE : (M === LiteGraph.EVENT || M === LiteGraph.ACTION) && (P = LiteGraph.BOX_SHAPE), T = !0, P === LiteGraph.BOX_SHAPE ? l ? t.rect(
              A[0] - 5 + 0.5,
              A[1] - 8 + 0.5,
              10,
              14
            ) : t.rect(
              A[0] - 6 + 0.5,
              A[1] - 5 + 0.5,
              14,
              10
            ) : P === LiteGraph.ARROW_SHAPE ? (t.moveTo(A[0] + 8, A[1] + 0.5), t.lineTo(A[0] - 4, A[1] + 6 + 0.5), t.lineTo(A[0] - 4, A[1] - 6 + 0.5), t.closePath()) : P === LiteGraph.GRID_SHAPE ? (t.rect(A[0] - 4, A[1] - 4, 2, 2), t.rect(A[0] - 1, A[1] - 4, 2, 2), t.rect(A[0] + 2, A[1] - 4, 2, 2), t.rect(A[0] - 4, A[1] - 1, 2, 2), t.rect(A[0] - 1, A[1] - 1, 2, 2), t.rect(A[0] + 2, A[1] - 1, 2, 2), t.rect(A[0] - 4, A[1] + 2, 2, 2), t.rect(A[0] - 1, A[1] + 2, 2, 2), t.rect(A[0] + 2, A[1] + 2, 2, 2), T = !1) : a ? t.rect(A[0] - 4, A[1] - 4, 8, 8) : t.arc(A[0], A[1], 4, 0, Math.PI * 2), t.fill(), !a && T && t.stroke(), d && !(D.name == "onTrigger" || D.name == "onExecuted")) {
              let R = D.label != null ? D.label : D.name;
              R && (t.fillStyle = LiteGraph.NODE_TEXT_COLOR, l || D.dir == LiteGraph.DOWN ? t.fillText(R, A[0], A[1] - 8) : t.fillText(R, A[0] - 10, A[1] + 5));
            }
          }
        if (t.textAlign = "left", t.globalAlpha = 1, n.widgets) {
          var L = E;
          (l || n.widgets_up) && (L = 2), n.widgets_start_y != null && (L = n.widgets_start_y), this.drawNodeWidgets(
            n,
            L,
            t,
            this.node_widget && this.node_widget[0] == n ? this.node_widget[1] : null
          );
        }
      }
      (n.clip_area || this.clip_all_nodes) && t.restore(), t.globalAlpha = 1;
    }
  }
  drawNodeTooltip(n, t) {
    var l;
    if (!t || !n) {
      (l = LiteGraph.warn) == null || l.call(LiteGraph, "drawNodeTooltip: invalid node or ctx", t, n);
      return;
    }
    var r = t.properties.tooltip != null ? t.properties.tooltip : "";
    if ((!r || r == "") && LiteGraph.show_node_tooltip_use_descr_property && t.constructor.desc && (r = t.constructor.desc), r = (r + "").trim(), !(!r || r == "")) {
      var s = [0, -LiteGraph.NODE_TITLE_HEIGHT], a = t.flags.collapsed ? [LiteGraph.NODE_COLLAPSED_WIDTH, LiteGraph.NODE_TITLE_HEIGHT] : t.size;
      n.font = "14px Courier New", n.measureText(r);
      var o = Math.max(t.size[0], 160) + 20, u = t.ttip_oTMultiRet ? t.ttip_oTMultiRet.height + 15 : 21;
      n.globalAlpha = 0.7 * this.editor_alpha, n.shadowColor = t.ttip_oTMultiRet ? "black" : "transparent", n.shadowOffsetX = 2, n.shadowOffsetY = 2, n.shadowBlur = 3, n.fillStyle = t.ttip_oTMultiRet ? "#454" : "transparent", n.beginPath(), n.roundRect(s[0] - o * 0.5 + a[0] / 2, s[1] - 15 - u, o, u, [3]), n.moveTo(s[0] - 10 + a[0] / 2, s[1] - 15), n.lineTo(s[0] + 10 + a[0] / 2, s[1] - 15), n.lineTo(s[0] + a[0] / 2, s[1] - 5), n.fill(), n.shadowColor = "transparent", n.textAlign = "center", n.fillStyle = t.ttip_oTMultiRet ? "#CEC" : "transparent", n.globalAlpha = this.editor_alpha;
      var h = LiteGraph.canvasFillTextMultiline(n, r, s[0] + a[0] / 2, s[1] - u, o, 14);
      t.ttip_oTMultiRet = h, n.closePath();
    }
  }
  // used by this.over_link_center
  drawLinkTooltip(n, t) {
    var l;
    var r = t._pos;
    if (n.fillStyle = "black", n.beginPath(), n.arc(r[0], r[1], 3, 0, Math.PI * 2), n.fill(), t.data != null && !((l = this.onDrawLinkTooltip) != null && l.call(this, n, t, this))) {
      var s = t.data, a = null;
      if (s.constructor === Number ? a = s.toFixed(2) : s.constructor === String ? a = '"' + s + '"' : s.constructor === Boolean ? a = String(s) : s.toToolTip ? a = s.toToolTip() : a = "[" + s.constructor.name + "]", a != null) {
        a = a.substr(0, 30), n.font = "14px Courier New";
        var o = n.measureText(a), u = o.width + 20, h = 24;
        n.shadowColor = "black", n.shadowOffsetX = 2, n.shadowOffsetY = 2, n.shadowBlur = 3, n.fillStyle = "#454", n.beginPath(), n.roundRect(r[0] - u * 0.5, r[1] - 15 - h, u, h, [3]), n.moveTo(r[0] - 10, r[1] - 15), n.lineTo(r[0] + 10, r[1] - 15), n.lineTo(r[0], r[1] - 5), n.fill(), n.shadowColor = "transparent", n.textAlign = "center", n.fillStyle = "#CEC", n.fillText(a, r[0], r[1] - 15 - h * 0.3);
      }
    }
  }
  drawNodeShape(n, t, r, s, a, o, u) {
    var S;
    t.strokeStyle = s, t.fillStyle = a;
    var h = LiteGraph.NODE_TITLE_HEIGHT, l = this.lowQualityRenderingRequired(0.5), c = n._shape || n.constructor.shape || LiteGraph.ROUND_SHAPE, d = n.constructor.title_mode, f = !0;
    d == LiteGraph.TRANSPARENT_TITLE || d == LiteGraph.NO_TITLE ? f = !1 : d == LiteGraph.AUTOHIDE_TITLE && u && (f = !0);
    var _ = tmp_area;
    _[0] = 0, _[1] = f ? -h : 0, _[2] = r[0] + 1, _[3] = f ? r[1] + h : r[1];
    var E = t.globalAlpha;
    if (t.beginPath(), c == LiteGraph.BOX_SHAPE || l ? t.fillRect(_[0], _[1], _[2], _[3]) : c == LiteGraph.ROUND_SHAPE || c == LiteGraph.CARD_SHAPE ? t.roundRect(
      _[0],
      _[1],
      _[2],
      _[3],
      c == LiteGraph.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]
    ) : c == LiteGraph.CIRCLE_SHAPE && t.arc(
      r[0] * 0.5,
      r[1] * 0.5,
      r[0] * 0.5,
      0,
      Math.PI * 2
    ), t.fill(), !n.flags.collapsed && f && (t.shadowColor = "transparent", t.fillStyle = "rgba(0,0,0,0.2)", t.fillRect(0, -1, _[2], 2)), t.shadowColor = "transparent", (S = n.onDrawBackground) == null || S.call(n, t, this, this.canvas, this.graph_mouse), f || d == LiteGraph.TRANSPARENT_TITLE) {
      if (n.onDrawTitleBar)
        n.onDrawTitleBar(t, h, r, this.ds.scale, s);
      else if (d != LiteGraph.TRANSPARENT_TITLE && (n.constructor.title_color || this.render_title_colored)) {
        var m = n.constructor.title_color || s;
        if (n.flags.collapsed && (t.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR), this.use_gradients) {
          var T = _LGraphCanvas.gradients[m];
          T || (T = _LGraphCanvas.gradients[m] = t.createLinearGradient(0, 0, 400, 0), T.addColorStop(0, m), T.addColorStop(1, "#000")), t.fillStyle = T;
        } else
          t.fillStyle = m;
        t.beginPath(), c == LiteGraph.BOX_SHAPE || l ? t.rect(0, -h, r[0] + 1, h) : (c == LiteGraph.ROUND_SHAPE || c == LiteGraph.CARD_SHAPE) && t.roundRect(
          0,
          -h,
          r[0] + 1,
          h,
          n.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]
        ), t.fill(), t.shadowColor = "transparent";
      }
      let N = !1;
      LiteGraph.node_box_coloured_by_mode && LiteGraph.NODE_MODES_COLORS[n.mode] && (N = LiteGraph.NODE_MODES_COLORS[n.mode]), LiteGraph.node_box_coloured_when_on && (N = n.action_triggered ? "#FFF" : n.execute_triggered ? "#AAA" : N);
      var L = 10;
      if (n.onDrawTitleBox ? n.onDrawTitleBox(t, h, r, this.ds.scale) : c == LiteGraph.ROUND_SHAPE || c == LiteGraph.CIRCLE_SHAPE || c == LiteGraph.CARD_SHAPE ? (l && (t.fillStyle = "black", t.beginPath(), t.arc(
        h * 0.5,
        h * -0.5,
        L * 0.5 + 1,
        0,
        Math.PI * 2
      ), t.fill()), t.fillStyle = n.boxcolor || N || LiteGraph.NODE_DEFAULT_BOXCOLOR, l ? t.fillRect(h * 0.5 - L * 0.5, h * -0.5 - L * 0.5, L, L) : (t.beginPath(), t.arc(
        h * 0.5,
        h * -0.5,
        L * 0.5,
        0,
        Math.PI * 2
      ), t.fill())) : (l && (t.fillStyle = "black", t.fillRect(
        (h - L) * 0.5 - 1,
        (h + L) * -0.5 - 1,
        L + 2,
        L + 2
      )), t.fillStyle = n.boxcolor || N || LiteGraph.NODE_DEFAULT_BOXCOLOR, t.fillRect(
        (h - L) * 0.5,
        (h + L) * -0.5,
        L,
        L
      )), t.globalAlpha = E, n.onDrawTitleText && n.onDrawTitleText(
        t,
        h,
        r,
        this.ds.scale,
        this.title_text_font,
        o
      ), !l) {
        t.font = this.title_text_font;
        var G = String(n.getTitle());
        G && (o ? t.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR : t.fillStyle = n.constructor.title_text_color || this.node_title_color, n.flags.collapsed ? (t.textAlign = "left", t.fillText(
          G.substr(0, 20),
          // avoid urls too long //@TODO: Replace with substring
          h,
          // + measure.width * 0.5,
          LiteGraph.NODE_TITLE_TEXT_Y - h
        ), t.textAlign = "left") : (t.textAlign = "left", t.fillText(
          G,
          h,
          LiteGraph.NODE_TITLE_TEXT_Y - h
        )));
      }
      if (!n.flags.collapsed && n.subgraph && !n.skip_subgraph_button) {
        var O = LiteGraph.NODE_TITLE_HEIGHT, b = n.size[0] - O, I = LiteGraph.isInsideRectangle(this.graph_mouse[0] - n.pos[0], this.graph_mouse[1] - n.pos[1], b + 2, -O + 2, O - 4, O - 4);
        t.fillStyle = I ? "#888" : "#555", c == LiteGraph.BOX_SHAPE || l ? t.fillRect(b + 2, -O + 2, O - 4, O - 4) : (t.beginPath(), t.roundRect(b + 2, -O + 2, O - 4, O - 4, [4]), t.fill()), t.fillStyle = "#333", t.beginPath(), t.moveTo(b + O * 0.2, -O * 0.6), t.lineTo(b + O * 0.8, -O * 0.6), t.lineTo(b + O * 0.5, -O * 0.3), t.fill();
      }
      n.onDrawTitle && n.onDrawTitle(t);
    }
    o && (n.onBounding && n.onBounding(_), d == LiteGraph.TRANSPARENT_TITLE && (_[1] -= h, _[3] += h), t.lineWidth = 1, t.globalAlpha = 0.8, t.beginPath(), c == LiteGraph.BOX_SHAPE ? t.rect(
      -6 + _[0],
      -6 + _[1],
      12 + _[2],
      12 + _[3]
    ) : c == LiteGraph.ROUND_SHAPE || c == LiteGraph.CARD_SHAPE && n.flags.collapsed ? t.roundRect(
      -6 + _[0],
      -6 + _[1],
      12 + _[2],
      12 + _[3],
      [this.round_radius * 2]
    ) : c == LiteGraph.CARD_SHAPE ? t.roundRect(
      -6 + _[0],
      -6 + _[1],
      12 + _[2],
      12 + _[3],
      [this.round_radius * 2, 2, this.round_radius * 2, 2]
    ) : c == LiteGraph.CIRCLE_SHAPE && t.arc(
      r[0] * 0.5,
      r[1] * 0.5,
      r[0] * 0.5 + 6,
      0,
      Math.PI * 2
    ), t.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR, t.stroke(), t.strokeStyle = s, t.globalAlpha = 1), n.execute_triggered > 0 && n.execute_triggered--, n.action_triggered > 0 && n.action_triggered--;
  }
  /**
   * draws every connection visible in the canvas
   * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time
   * @method drawConnections
   **/
  drawConnections(n) {
    var t = LiteGraph.getTime(), r = this.visible_area;
    margin_area[0] = r[0] - 20, margin_area[1] = r[1] - 20, margin_area[2] = r[2] + 40, margin_area[3] = r[3] + 40, n.lineWidth = this.connections_width, n.fillStyle = "#AAA", n.strokeStyle = "#AAA", n.globalAlpha = this.editor_alpha;
    for (var s = this.graph._nodes, a = 0, o = s.length; a < o; ++a) {
      var u = s[a];
      if (!(!u.inputs || !u.inputs.length))
        for (let I = 0; I < u.inputs.length; ++I) {
          var h = u.inputs[I];
          if (!(!h || h.link == null)) {
            var l = h.link, c = this.graph.links[l];
            if (c) {
              var d = this.graph.getNodeById(c.origin_id);
              if (d != null) {
                var f = c.origin_slot, _ = null;
                f == -1 ? _ = [
                  d.pos[0] + 10,
                  d.pos[1] + 10
                ] : _ = d.getConnectionPos(
                  !1,
                  f,
                  tempA
                );
                var E = u.getConnectionPos(!0, I, tempB);
                if (link_bounding[0] = _[0], link_bounding[1] = _[1], link_bounding[2] = E[0] - _[0], link_bounding[3] = E[1] - _[1], link_bounding[2] < 0 && (link_bounding[0] += link_bounding[2], link_bounding[2] = Math.abs(link_bounding[2])), link_bounding[3] < 0 && (link_bounding[1] += link_bounding[3], link_bounding[3] = Math.abs(link_bounding[3])), !!LiteGraph.overlapBounding(link_bounding, margin_area)) {
                  var m = d.outputs[f], T = u.inputs[I];
                  if (!(!m || !T)) {
                    var L = m.dir || (d.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT), G = T.dir || (u.horizontal ? LiteGraph.UP : LiteGraph.LEFT);
                    if (this.renderLink(
                      n,
                      _,
                      E,
                      c,
                      !1,
                      0,
                      null,
                      L,
                      G
                    ), c && c._last_time && t - c._last_time < 1e3) {
                      var O = 2 - (t - c._last_time) * 2e-3, b = n.globalAlpha;
                      n.globalAlpha = b * O, this.renderLink(
                        n,
                        _,
                        E,
                        c,
                        !0,
                        O,
                        "white",
                        L,
                        G
                      ), n.globalAlpha = b;
                    }
                  }
                }
              }
            }
          }
        }
    }
    n.globalAlpha = 1;
  }
  /**
   * draws a link between two points
   * @method renderLink
   * @param {vec2} a start pos
   * @param {vec2} b end pos
   * @param {Object} link the link object with all the link info
   * @param {boolean} skip_border ignore the shadow of the link
   * @param {boolean} flow show flow animation (for events)
   * @param {string} color the color for the link
   * @param {number} start_dir the direction enum
   * @param {number} end_dir the direction enum
   * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)
   **/
  renderLink(n, t, r, s, a, o, u, h, l, c) {
    s && this.visible_links.push(s), !u && s && (u = s.color || _LGraphCanvas.link_type_colors[s.type]), u || (u = this.default_link_color), s != null && this.highlighted_links[s.id] && (u = "#FFF"), h = h || LiteGraph.RIGHT, l = l || LiteGraph.LEFT;
    var d = LiteGraph.distance(t, r);
    this.render_connections_border && this.ds.scale > 0.6 && (n.lineWidth = this.connections_width + 4), n.lineJoin = "round", c = c || 1, c > 1 && (n.lineWidth = 0.5), n.beginPath();
    for (let M = 0; M < c; M += 1) {
      var f = (M - (c - 1) * 0.5) * 5;
      if (this.links_render_mode == LiteGraph.SPLINE_LINK) {
        n.moveTo(t[0], t[1] + f);
        let P = 0, A = 0, R = 0, B = 0;
        switch (h) {
          case LiteGraph.LEFT:
            P = d * -0.25;
            break;
          case LiteGraph.RIGHT:
            P = d * 0.25;
            break;
          case LiteGraph.UP:
            A = d * -0.25;
            break;
          case LiteGraph.DOWN:
            A = d * 0.25;
            break;
        }
        switch (l) {
          case LiteGraph.LEFT:
            R = d * -0.25;
            break;
          case LiteGraph.RIGHT:
            R = d * 0.25;
            break;
          case LiteGraph.UP:
            B = d * -0.25;
            break;
          case LiteGraph.DOWN:
            B = d * 0.25;
            break;
        }
        n.bezierCurveTo(
          t[0] + P,
          t[1] + A + f,
          r[0] + R,
          r[1] + B + f,
          r[0],
          r[1] + f
        );
      } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {
        n.moveTo(t[0], t[1] + f);
        let P = 0, A = 0, R = 0, B = 0;
        switch (h) {
          case LiteGraph.LEFT:
            P = -1;
            break;
          case LiteGraph.RIGHT:
            P = 1;
            break;
          case LiteGraph.UP:
            A = -1;
            break;
          case LiteGraph.DOWN:
            A = 1;
            break;
        }
        switch (l) {
          case LiteGraph.LEFT:
            R = -1;
            break;
          case LiteGraph.RIGHT:
            R = 1;
            break;
          case LiteGraph.UP:
            B = -1;
            break;
          case LiteGraph.DOWN:
            B = 1;
            break;
        }
        var _ = 15;
        n.lineTo(
          t[0] + P * _,
          t[1] + A * _ + f
        ), n.lineTo(
          r[0] + R * _,
          r[1] + B * _ + f
        ), n.lineTo(r[0], r[1] + f);
      } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {
        n.moveTo(t[0], t[1]);
        var E = t[0], m = t[1], T = r[0], L = r[1];
        h == LiteGraph.RIGHT ? E += 10 : m += 10, l == LiteGraph.LEFT ? T -= 10 : L -= 10, n.lineTo(E, m), n.lineTo((E + T) * 0.5, m), n.lineTo((E + T) * 0.5, L), n.lineTo(T, L), n.lineTo(r[0], r[1]);
      } else
        return;
    }
    this.render_connections_border && this.ds.scale > 0.6 && !a && (n.strokeStyle = "rgba(0,0,0,0.5)", n.stroke()), n.lineWidth = this.connections_width, n.fillStyle = n.strokeStyle = u, n.stroke();
    var G = this.computeConnectionPoint(t, r, 0.5, h, l);
    if (s && s._pos && (s._pos[0] = G[0], s._pos[1] = G[1]), this.ds.scale >= 0.6 && this.highquality_render && l != LiteGraph.CENTER) {
      if (this.render_connection_arrows) {
        var O = this.computeConnectionPoint(
          t,
          r,
          0.25,
          h,
          l
        ), b = this.computeConnectionPoint(
          t,
          r,
          0.26,
          h,
          l
        ), I = this.computeConnectionPoint(
          t,
          r,
          0.75,
          h,
          l
        ), S = this.computeConnectionPoint(
          t,
          r,
          0.76,
          h,
          l
        ), N = 0, C = 0;
        this.render_curved_connections ? (N = -Math.atan2(b[0] - O[0], b[1] - O[1]), C = -Math.atan2(S[0] - I[0], S[1] - I[1])) : C = N = r[1] > t[1] ? 0 : Math.PI, n.save(), n.translate(O[0], O[1]), n.rotate(N), n.beginPath(), n.moveTo(-5, -3), n.lineTo(0, 7), n.lineTo(5, -3), n.fill(), n.restore(), n.save(), n.translate(I[0], I[1]), n.rotate(C), n.beginPath(), n.moveTo(-5, -3), n.lineTo(0, 7), n.lineTo(5, -3), n.fill(), n.restore();
      }
      n.beginPath(), n.arc(G[0], G[1], 5, 0, Math.PI * 2), n.fill();
    }
    if (o) {
      n.fillStyle = u;
      for (let M = 0; M < 5; ++M) {
        var D = (LiteGraph.getTime() * 1e-3 + M * 0.2) % 1;
        G = this.computeConnectionPoint(
          t,
          r,
          D,
          h,
          l
        ), n.beginPath(), n.arc(G[0], G[1], 5, 0, 2 * Math.PI), n.fill();
      }
    }
  }
  // returns the link center point based on curvature
  computeConnectionPoint(n, t, r, s, a) {
    s = s || LiteGraph.RIGHT, a = a || LiteGraph.LEFT;
    var o = LiteGraph.distance(n, t), u = n, h = [n[0], n[1]], l = [t[0], t[1]], c = t;
    switch (s) {
      case LiteGraph.LEFT:
        h[0] += o * -0.25;
        break;
      case LiteGraph.RIGHT:
        h[0] += o * 0.25;
        break;
      case LiteGraph.UP:
        h[1] += o * -0.25;
        break;
      case LiteGraph.DOWN:
        h[1] += o * 0.25;
        break;
    }
    switch (a) {
      case LiteGraph.LEFT:
        l[0] += o * -0.25;
        break;
      case LiteGraph.RIGHT:
        l[0] += o * 0.25;
        break;
      case LiteGraph.UP:
        l[1] += o * -0.25;
        break;
      case LiteGraph.DOWN:
        l[1] += o * 0.25;
        break;
    }
    var d = (1 - r) * (1 - r) * (1 - r), f = 3 * ((1 - r) * (1 - r)) * r, _ = 3 * (1 - r) * (r * r), E = r * r * r, m = d * u[0] + f * h[0] + _ * l[0] + E * c[0], T = d * u[1] + f * h[1] + _ * l[1] + E * c[1];
    return [m, T];
  }
  drawExecutionOrder(n) {
    n.shadowColor = "transparent", n.globalAlpha = 0.25, n.textAlign = "center", n.strokeStyle = "white", n.globalAlpha = 0.75;
    var t = this.visible_nodes;
    for (let s = 0; s < t.length; ++s) {
      var r = t[s];
      n.fillStyle = "black", n.fillRect(
        r.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,
        r.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT
      ), r.order == 0 && n.strokeRect(
        r.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
        r.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,
        LiteGraph.NODE_TITLE_HEIGHT,
        LiteGraph.NODE_TITLE_HEIGHT
      ), n.fillStyle = "#FFF", n.fillText(
        r.order,
        r.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,
        r.pos[1] - 6
      );
    }
    n.globalAlpha = 1;
  }
  /**
   * draws the widgets stored inside a node
   * @method drawNodeWidgets
   **/
  drawNodeWidgets(n, t, r, s) {
    if (!n.widgets || !n.widgets.length)
      return 0;
    var a = n.size[0], o = n.widgets;
    t += 2;
    var u = LiteGraph.NODE_WIDGET_HEIGHT, h = !this.lowQualityRenderingRequired(0.5);
    r.save(), r.globalAlpha = this.editor_alpha;
    var l = LiteGraph.WIDGET_OUTLINE_COLOR, c = LiteGraph.WIDGET_BGCOLOR, d = LiteGraph.WIDGET_TEXT_COLOR, f = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR, _ = 15;
    for (let S = 0; S < o.length; ++S) {
      var E = o[S], m = t;
      E.y && (m = E.y), E.last_y = m, r.strokeStyle = l, r.fillStyle = "#222", r.textAlign = "left", E.disabled && (r.globalAlpha *= 0.5);
      var T = E.width || a;
      switch (E.type) {
        case "button":
          E.clicked && (r.fillStyle = "#AAA", E.clicked = !1, this.dirty_canvas = !0), r.fillRect(_, m, T - _ * 2, u), h && !E.disabled && r.strokeRect(_, m, T - _ * 2, u), h && (r.textAlign = "center", r.fillStyle = d, r.fillText(E.label || E.name, T * 0.5, m + u * 0.7));
          break;
        case "toggle":
          if (r.textAlign = "left", r.strokeStyle = l, r.fillStyle = c, r.beginPath(), h ? r.roundRect(_, m, T - _ * 2, u, [u * 0.5]) : r.rect(_, m, T - _ * 2, u), r.fill(), h && !E.disabled && r.stroke(), r.fillStyle = E.value ? "#89A" : "#333", r.beginPath(), r.arc(T - _ * 2, m + u * 0.5, u * 0.36, 0, Math.PI * 2), r.fill(), h) {
            r.fillStyle = f;
            const N = E.label || E.name;
            N != null && r.fillText(N, _ * 2, m + u * 0.7), r.fillStyle = E.value ? d : f, r.textAlign = "right", r.fillText(
              E.value ? E.options.on || "true" : E.options.off || "false",
              T - 40,
              m + u * 0.7
            );
          }
          break;
        case "slider":
          r.fillStyle = c, r.fillRect(_, m, T - _ * 2, u);
          var L = E.options.max - E.options.min, G = (E.value - E.options.min) / L;
          if (G < 0 && (G = 0), G > 1 && (G = 1), r.fillStyle = E.options.hasOwnProperty("slider_color") ? E.options.slider_color : s == E ? "#89A" : "#678", r.fillRect(_, m, G * (T - _ * 2), u), h && !E.disabled && r.strokeRect(_, m, T - _ * 2, u), E.marker) {
            var O = (E.marker - E.options.min) / L;
            O < 0 && (O = 0), O > 1 && (O = 1), r.fillStyle = E.options.hasOwnProperty("marker_color") ? E.options.marker_color : "#AA9", r.fillRect(_ + O * (T - _ * 2), m, 2, u);
          }
          h && (r.textAlign = "center", r.fillStyle = d, r.fillText(
            E.label || E.name + "  " + Number(E.value).toFixed(E.options.precision != null ? E.options.precision : 3),
            T * 0.5,
            m + u * 0.7
          ));
          break;
        case "number":
        case "combo":
          if (r.textAlign = "left", r.strokeStyle = l, r.fillStyle = c, r.beginPath(), h ? r.roundRect(_, m, T - _ * 2, u, [u * 0.5]) : r.rect(_, m, T - _ * 2, u), r.fill(), h)
            if (E.disabled || r.stroke(), r.fillStyle = d, E.disabled || (r.beginPath(), r.moveTo(_ + 16, m + 5), r.lineTo(_ + 6, m + u * 0.5), r.lineTo(_ + 16, m + u - 5), r.fill(), r.beginPath(), r.moveTo(T - _ - 16, m + 5), r.lineTo(T - _ - 6, m + u * 0.5), r.lineTo(T - _ - 16, m + u - 5), r.fill()), r.fillStyle = f, r.fillText(E.label || E.name, _ * 2 + 5, m + u * 0.7), r.fillStyle = d, r.textAlign = "right", E.type == "number")
              r.fillText(
                Number(E.value).toFixed(E.options.precision !== void 0 ? E.options.precision : 3),
                T - _ * 2 - 20,
                m + u * 0.7
              );
            else {
              var b = E.value;
              if (E.options.values) {
                var I = E.options.values;
                I.constructor === Function && (I = I()), I && I.constructor !== Array && (b = I[E.value]);
              }
              r.fillText(
                b,
                T - _ * 2 - 20,
                m + u * 0.7
              );
            }
          break;
        case "string":
        case "text":
          if (r.textAlign = "left", r.strokeStyle = l, r.fillStyle = c, r.beginPath(), h ? r.roundRect(_, m, T - _ * 2, u, [u * 0.5]) : r.rect(_, m, T - _ * 2, u), r.fill(), h) {
            E.disabled || r.stroke(), r.save(), r.beginPath(), r.rect(_, m, T - _ * 2, u), r.clip(), r.fillStyle = f;
            const N = E.label || E.name;
            N != null && r.fillText(N, _ * 2, m + u * 0.7), r.fillStyle = d, r.textAlign = "right", r.fillText(String(E.value).substr(0, 30), T - _ * 2, m + u * 0.7), r.restore();
          }
          break;
        default:
          E.draw && E.draw(r, n, T, m, u);
          break;
      }
      t += (E.computeSize ? E.computeSize(T)[1] : u) + 4, r.globalAlpha = this.editor_alpha;
    }
    r.restore(), r.textAlign = "left";
  }
  /**
   * process an event on widgets
   * @method processNodeWidgets
   **/
  processNodeWidgets(node, pos, event, active_widget) {
    if (!node.widgets || !node.widgets.length || !this.allow_interaction && !node.flags.allow_interaction)
      return null;
    var x = pos[0] - node.pos[0], y = pos[1] - node.pos[1], width = node.size[0], deltaX = event.deltaX || event.deltax || 0, that = this, ref_window = this.getCanvasWindow();
    for (let i = 0; i < node.widgets.length; ++i) {
      var w = node.widgets[i];
      if (!(!w || w.disabled)) {
        var widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT, widget_width = w.width || width;
        if (!(w != active_widget && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height || w.last_y === void 0))) {
          var old_value = w.value;
          switch (w.type) {
            case "button":
              event.type === "pointerdown" && (w.callback && setTimeout(function() {
                w.callback(w, that, node, pos, event);
              }, 20), w.clicked = !0, this.dirty_canvas = !0);
              break;
            case "slider":
              var nvalue = LiteGraph.clamp((x - 15) / (widget_width - 30), 0, 1);
              if (w.options.read_only) break;
              w.value = w.options.min + (w.options.max - w.options.min) * nvalue, old_value != w.value && setTimeout(function() {
                inner_value_change(w, w.value, old_value);
              }, 20), this.dirty_canvas = !0;
              break;
            case "number":
            case "combo":
            case "enum":
              if (event.type == "pointermove" && w.type == "number")
                deltaX && (w.value += deltaX * 0.1 * (w.options.step || 1)), w.options.min != null && w.value < w.options.min && (w.value = w.options.min), w.options.max != null && w.value > w.options.max && (w.value = w.options.max);
              else if (event.type == "pointerdown") {
                var values = w.options.values;
                values && values.constructor === Function && (values = w.options.values(w, node));
                var values_list = null;
                w.type != "number" && (values_list = values.constructor === Array ? values : Object.keys(values));
                let n = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
                if (w.type == "number")
                  w.value += n * 0.1 * (w.options.step || 1), w.options.min != null && w.value < w.options.min && (w.value = w.options.min), w.options.max != null && w.value > w.options.max && (w.value = w.options.max);
                else if (n) {
                  var index = -1;
                  this.last_mouseclick = 0, values.constructor === Object ? index = values_list.indexOf(String(w.value)) + n : index = values_list.indexOf(w.value) + n, index >= values_list.length && (index = values_list.length - 1), index < 0 && (index = 0), values.constructor === Array ? w.value = values[index] : w.value = index;
                } else {
                  let t = function(r) {
                    return values != values_list && (r = text_values.indexOf(r)), this.value = r, inner_value_change(this, r, old_value), that.dirty_canvas = !0, !1;
                  };
                  var text_values = values != values_list ? Object.values(values) : values;
                  new LiteGraph.ContextMenu(
                    text_values,
                    {
                      scale: Math.max(1, this.ds.scale),
                      event,
                      className: "dark",
                      callback: t.bind(w)
                    },
                    ref_window
                  );
                }
              } else if (event.type == "pointerup" && w.type == "number") {
                let delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;
                event.click_time < 200 && delta == 0 && this.prompt(
                  "Value",
                  w.value,
                  function(v) {
                    var n;
                    if (/^[0-9+\-*/()\s]+|\d+\.\d+$/.test(v))
                      try {
                        v = eval(v);
                      } catch (t) {
                        (n = LiteGraph.warn) == null || n.call(LiteGraph, t);
                      }
                    this.value = Number(v), inner_value_change(this, this.value, old_value);
                  }.bind(w),
                  event
                );
              }
              old_value != w.value && setTimeout(
                function() {
                  inner_value_change(this, this.value, old_value);
                }.bind(w),
                20
              ), this.dirty_canvas = !0;
              break;
            case "toggle":
              event.type == "pointerdown" && (w.value = !w.value, setTimeout(function() {
                inner_value_change(w, w.value);
              }, 20));
              break;
            case "string":
            case "text":
              event.type == "pointerdown" && this.prompt(
                "Value",
                w.value,
                function(n) {
                  inner_value_change(this, n);
                }.bind(w),
                event,
                w.options ? w.options.multiline : !1
              );
              break;
            default:
              w.mouse && (this.dirty_canvas = w.mouse(event, [x, y], node));
              break;
          }
          return w;
        }
      }
    }
    function inner_value_change(n, t, r) {
      var s;
      (s = LiteGraph.debug) == null || s.call(LiteGraph, "inner_value_change for processNodeWidgets", n, t), r != w.value && (node.onWidgetChanged && node.onWidgetChanged(w.name, w.value, r, w), node.graph.onGraphChanged({ action: "widgetChanged", doSave: !0 })), n.type == "number" && (t = Number(t)), n.value = t, n.options && n.options.property && node.properties[n.options.property] !== void 0 && node.setProperty(n.options.property, t), n.callback && n.callback(n.value, that, node, pos, event);
    }
    return null;
  }
  /**
   * draws every group area in the background
   * @method drawGroups
   **/
  drawGroups(n, t) {
    if (this.graph) {
      var r = this.graph._groups;
      t.save(), t.globalAlpha = 0.5 * this.editor_alpha;
      for (let h = 0; h < r.length; ++h) {
        var s = r[h];
        if (LiteGraph.overlapBounding(this.visible_area, s._bounding)) {
          t.fillStyle = s.color || "#335", t.strokeStyle = s.color || "#335";
          var a = s._pos, o = s._size;
          t.globalAlpha = 0.25 * this.editor_alpha, t.beginPath(), t.rect(a[0] + 0.5, a[1] + 0.5, o[0], o[1]), t.fill(), t.globalAlpha = this.editor_alpha, t.stroke(), t.beginPath(), t.moveTo(a[0] + o[0], a[1] + o[1]), t.lineTo(a[0] + o[0] - 10, a[1] + o[1]), t.lineTo(a[0] + o[0], a[1] + o[1] - 10), t.fill();
          var u = s.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;
          t.font = u + "px Arial", t.textAlign = "left", t.fillText(s.title, a[0] + 4, a[1] + u);
        }
      }
      t.restore();
    }
  }
  adjustNodesSize() {
    var n = this.graph._nodes;
    for (let t = 0; t < n.length; ++t)
      n[t].size = n[t].computeSize();
    this.setDirty(!0, !0);
  }
  /**
   * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode
   * @method resize
   **/
  resize(n, t) {
    if (!n && !t) {
      var r = this.canvas.parentNode;
      n = r.offsetWidth, t = r.offsetHeight;
    }
    this.canvas.width == n && this.canvas.height == t || (this.canvas.width = n, this.canvas.height = t, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0));
  }
  /**
   * switches to live mode (node shapes are not rendered, only the content)
   * this feature was designed when graphs where meant to create user interfaces
   * @method switchLiveMode
   **/
  switchLiveMode(n) {
    if (!n) {
      this.live_mode = !this.live_mode, this.dirty_canvas = !0, this.dirty_bgcanvas = !0;
      return;
    }
    var t = this, r = this.live_mode ? 1.1 : 0.9;
    this.live_mode && (this.live_mode = !1, this.editor_alpha = 0.1);
    var s = setInterval(function() {
      t.editor_alpha *= r, t.dirty_canvas = !0, t.dirty_bgcanvas = !0, r < 1 && t.editor_alpha < 0.01 && (clearInterval(s), r < 1 && (t.live_mode = !0)), r > 1 && t.editor_alpha > 0.99 && (clearInterval(s), t.editor_alpha = 1);
    }, 1);
  }
  /* @TODO: Validate this is never called
  onNodeSelectionChange() {
      return; // disabled
  }
  */
  /* this is an implementation for touch not in production and not ready
      */
  /* LGraphCanvas.prototype.touchHandler = function(event) {
          //alert("foo");
          var touches = event.changedTouches,
              first = touches[0],
              type = "";
  
          switch (event.type) {
              case "touchstart":
                  type = "pointerdown";
                  break;
              case "touchmove":
                  type = "pointermove";
                  break;
              case "touchend":
                  type = "pointerup";
                  break;
              default:
                  return;
          }
  
          //initMouseEvent(type, canBubble, cancelable, view, clickCount,
          //           screenX, screenY, clientX, clientY, ctrlKey,
          //           altKey, shiftKey, metaKey, button, relatedTarget);
  
          // this is eventually a Dom object, get the LGraphCanvas back
          if(typeof this.getCanvasWindow == "undefined"){
              var window = this.lgraphcanvas.getCanvasWindow();
          }else{
              var window = this.getCanvasWindow();
          }
  
          var document = window.document;
  
          var simulatedEvent = document.createEvent("MouseEvent");
          simulatedEvent.initMouseEvent(
              type,
              true,
              true,
              window,
              1,
              first.screenX,
              first.screenY,
              first.clientX,
              first.clientY,
              false,
              false,
              false,
              false,
              0, //left
              null
          );
          first.target.dispatchEvent(simulatedEvent);
          event.preventDefault();
      };*/
  /* CONTEXT MENU ********************/
  static onGroupAdd(n, t, r) {
    var s = _LGraphCanvas.active_canvas, a = new LiteGraph.LGraphGroup();
    a.pos = s.convertEventToCanvasOffset(r), s.graph.add(a);
  }
  /**
   * Determines the furthest nodes in each direction
   * @param nodes {LGraphNode[]} the nodes to from which boundary nodes will be extracted
   * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
   */
  static getBoundaryNodes(n) {
    let t = null, r = null, s = null, a = null;
    for (const o in n) {
      const u = n[o], [h, l] = u.pos, [c, d] = u.size;
      (t === null || l < t.pos[1]) && (t = u), (r === null || h + c > r.pos[0] + r.size[0]) && (r = u), (s === null || l + d > s.pos[1] + s.size[1]) && (s = u), (a === null || h < a.pos[0]) && (a = u);
    }
    return {
      top: t,
      right: r,
      bottom: s,
      left: a
    };
  }
  /**
   * Determines the furthest nodes in each direction for the currently selected nodes
   * @return {{left: LGraphNode, top: LGraphNode, right: LGraphNode, bottom: LGraphNode}}
   */
  boundaryNodesForSelection() {
    return _LGraphCanvas.getBoundaryNodes(Object.values(this.selected_nodes));
  }
  /**
   *
   * @param {LGraphNode[]} nodes a list of nodes
   * @param {"top"|"bottom"|"left"|"right"} direction Direction to align the nodes
   * @param {LGraphNode?} align_to Node to align to (if null, align to the furthest node in the given direction)
   */
  static alignNodes(n, t, r) {
    if (!n)
      return;
    const s = _LGraphCanvas.active_canvas;
    let a = [];
    r === void 0 ? a = _LGraphCanvas.getBoundaryNodes(n) : a = {
      top: r,
      right: r,
      bottom: r,
      left: r
    };
    for (const [o, u] of Object.entries(s.selected_nodes))
      switch (t) {
        case "right":
          u.pos[0] = a.right.pos[0] + a.right.size[0] - u.size[0];
          break;
        case "left":
          u.pos[0] = a.left.pos[0];
          break;
        case "top":
          u.pos[1] = a.top.pos[1];
          break;
        case "bottom":
          u.pos[1] = a.bottom.pos[1] + a.bottom.size[1] - u.size[1];
          break;
      }
    s.dirty_canvas = !0, s.dirty_bgcanvas = !0;
  }
  static onNodeAlign(n, t, r, s, a) {
    new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
      event: r,
      callback: o,
      parentMenu: s
    });
    function o(u) {
      _LGraphCanvas.alignNodes(_LGraphCanvas.active_canvas.selected_nodes, u.toLowerCase(), a);
    }
  }
  static onGroupAlign(n, t, r, s) {
    new LiteGraph.ContextMenu(["Top", "Bottom", "Left", "Right"], {
      event: r,
      callback: a,
      parentMenu: s
    });
    function a(o) {
      _LGraphCanvas.alignNodes(_LGraphCanvas.active_canvas.selected_nodes, o.toLowerCase());
    }
  }
  static onMenuAdd(n, t, r, s, a) {
    var o = _LGraphCanvas.active_canvas, u = o.getCanvasWindow(), h = o.graph;
    if (!h)
      return;
    function l(c, d) {
      var f = LiteGraph.getNodeTypesCategories(o.filter || h.filter).filter(function(m) {
        return m.startsWith(c);
      }), _ = [];
      f.map(function(m) {
        if (m) {
          var T = new RegExp("^(" + c + ")"), L = m.replace(T, "").split("/")[0], G = c === "" ? L + "/" : c + L + "/", O = L;
          O.indexOf("::") != -1 && (O = O.split("::")[1]);
          var b = _.findIndex(function(I) {
            return I.value === G;
          });
          b === -1 && _.push({
            value: G,
            content: O,
            has_submenu: !0,
            callback: function(I, S, N, C) {
              l(I.value, C);
            }
          });
        }
      });
      var E = LiteGraph.getNodeTypesInCategory(c.slice(0, -1), o.filter || h.filter);
      E.map(function(m) {
        if (!m.skip_list) {
          var T = {
            value: m.type,
            content: m.title,
            has_submenu: !1,
            callback: function(L, G, O, b) {
              var I = b.getFirstEvent();
              o.graph.beforeChange();
              var S = LiteGraph.createNode(L.value);
              S && (S.pos = o.convertEventToCanvasOffset(I), o.graph.add(S)), a && a(S), o.graph.afterChange();
            }
          };
          _.push(T);
        }
      }), new LiteGraph.ContextMenu(_, { event: r, parentMenu: d }, u);
    }
    return l("", s), !1;
  }
  static onMenuCollapseAll() {
  }
  static onMenuNodeEdit() {
  }
  static showMenuNodeOptionalInputs(n, t, r, s, a) {
    var m;
    if (!a)
      return;
    var o = this, u = _LGraphCanvas.active_canvas, h = u.getCanvasWindow();
    t = a.optional_inputs, a.onGetInputs && (t = a.onGetInputs());
    var l = [];
    if (t)
      for (let T = 0; T < t.length; T++) {
        var c = t[T];
        if (!c) {
          l.push(null);
          continue;
        }
        var d = c[0];
        c[2] || (c[2] = {}), c[2].label && (d = c[2].label), c[2].removable = !0;
        var f = { content: d, value: c };
        c[1] == LiteGraph.ACTION && (f.className = "event"), l.push(f);
      }
    if (a.onMenuNodeInputs) {
      var _ = a.onMenuNodeInputs(l);
      _ && (l = _);
    }
    if (LiteGraph.do_add_triggers_slots && a.findInputSlot("onTrigger") == -1 && l.push({ content: "On Trigger", value: ["onTrigger", LiteGraph.EVENT, { nameLocked: !0, removable: !0 }], className: "event" }), !l.length) {
      LiteGraph.debug && ((m = LiteGraph.log) == null || m.call(LiteGraph, "no input entries"));
      return;
    }
    new LiteGraph.ContextMenu(
      l,
      {
        event: r,
        callback: E,
        parentMenu: s,
        node: a
      },
      h
    );
    function E(T, L, G) {
      var b;
      if (a && (T.callback && T.callback.call(o, a, T, L, G), T.value)) {
        a.graph.beforeChange();
        var O = {};
        T.value[2] && (O = Object.assign(O, T.value[2])), a.addInput(T.value[0], T.value[1], O), (b = a.onNodeInputAdd) == null || b.call(a, T.value), a.setDirtyCanvas(!0, !0), a.graph.afterChange();
      }
    }
    return !1;
  }
  static showMenuNodeOptionalOutputs(n, t, r, s, a) {
    if (!a)
      return;
    var o = this, u = _LGraphCanvas.active_canvas, h = u.getCanvasWindow();
    t = a.optional_outputs, a.onGetOutputs && (t = a.onGetOutputs());
    var l = [];
    if (t)
      for (let m = 0; m < t.length; m++) {
        var c = t[m];
        if (!c) {
          l.push(null);
          continue;
        }
        if (!(a.flags && a.flags.skip_repeated_outputs && a.findOutputSlot(c[0]) != -1)) {
          var d = c[0];
          c[2] || (c[2] = {}), c[2].label && (d = c[2].label), c[2].removable = !0;
          var f = { content: d, value: c };
          c[1] == LiteGraph.EVENT && (f.className = "event"), l.push(f);
        }
      }
    if (this.onMenuNodeOutputs && (l = this.onMenuNodeOutputs(l)), LiteGraph.do_add_triggers_slots && a.findOutputSlot("onExecuted") == -1 && l.push({
      content: "On Executed",
      value: [
        "onExecuted",
        LiteGraph.EVENT,
        {
          nameLocked: !0,
          removable: !0
        }
      ],
      className: "event"
    }), a.onMenuNodeOutputs) {
      var _ = a.onMenuNodeOutputs(l);
      _ && (l = _);
    }
    if (!l.length)
      return;
    new LiteGraph.ContextMenu(
      l,
      {
        event: r,
        callback: E,
        parentMenu: s,
        node: a
      },
      h
    );
    function E(m, T, L) {
      var I;
      if (a && (m.callback && m.callback.call(o, a, m, T, L), !!m.value)) {
        var G = m.value[1];
        if (G && (G.constructor === Object || G.constructor === Array)) {
          var O = [];
          for (let S in G)
            O.push({ content: S, value: G[S] });
          return new LiteGraph.ContextMenu(O, {
            event: T,
            callback: E,
            parentMenu: s,
            node: a
          }), !1;
        } else {
          a.graph.beforeChange();
          var b = {};
          m.value[2] && (b = Object.assign(b, m.value[2])), a.addOutput(m.value[0], m.value[1], b), (I = a.onNodeOutputAdd) == null || I.call(a, m.value), a.setDirtyCanvas(!0, !0), a.graph.afterChange();
        }
      }
    }
    return !1;
  }
  static onShowMenuNodeProperties(n, t, r, s, a) {
    if (!a || !a.properties)
      return;
    var o = _LGraphCanvas.active_canvas, u = o.getCanvasWindow(), h = [];
    for (let d in a.properties) {
      n = a.properties[d] !== void 0 ? a.properties[d] : " ", typeof n == "object" && (n = JSON.stringify(n));
      var l = a.getPropertyInfo(d);
      (l.type == "enum" || l.type == "combo") && (n = _LGraphCanvas.getPropertyPrintableValue(n, l.values)), n = _LGraphCanvas.decodeHTML(n), h.push({
        content: "<span class='property_name'>" + (l.label ? l.label : d) + "</span><span class='property_value'>" + n + "</span>",
        value: d
      });
    }
    if (!h.length)
      return;
    new LiteGraph.ContextMenu(
      h,
      {
        event: r,
        callback: c,
        parentMenu: s,
        allow_html: !0,
        node: a
      },
      u
    );
    function c(d) {
      if (a) {
        var f = this.getBoundingClientRect();
        o.showEditPropertyValue(a, d.value, { position: [f.left, f.top] });
      }
    }
    return !1;
  }
  static decodeHTML(n) {
    var t = document.createElement("div");
    return t.innerText = n, t.innerHTML;
  }
  static onMenuResizeNode(n, t, r, s, a) {
    if (!a)
      return;
    const o = (h) => {
      h.size = h.computeSize(), h.onResize && h.onResize(h.size);
    };
    var u = _LGraphCanvas.active_canvas;
    if (!u.selected_nodes || Object.keys(u.selected_nodes).length <= 1)
      o(a);
    else
      for (let h in u.selected_nodes)
        o(u.selected_nodes[h]);
    a.setDirtyCanvas(!0, !0);
  }
  showLinkMenu(n, t) {
    var r = this, s = r.graph.getNodeById(n.origin_id), a = r.graph.getNodeById(n.target_id), o = !1;
    s && s.outputs && s.outputs[n.origin_slot] && (o = s.outputs[n.origin_slot].type);
    var u = !1;
    a && a.outputs && a.outputs[n.target_slot] && (u = a.inputs[n.target_slot].type);
    var h = new LiteGraph.ContextMenu(options, {
      event: t,
      title: n.data != null ? n.data.constructor.name : null,
      callback: l
    });
    function l(c, d, f) {
      switch (c) {
        case "Add Node":
          _LGraphCanvas.onMenuAdd(null, null, f, h, function(_) {
            var E;
            (E = LiteGraph.debug) == null || E.call(LiteGraph, "node autoconnect"), !(!_.inputs || !_.inputs.length || !_.outputs || !_.outputs.length) && s.connectByType(n.origin_slot, _, o) && (_.connectByType(n.target_slot, a, u), _.pos[0] -= _.size[0] * 0.5);
          });
          break;
        case "Delete":
          r.graph.removeLink(n.id);
          break;
      }
    }
    return !1;
  }
  createDefaultNodeForSlot(n = {}) {
    var m, T, L, G, O;
    var t = Object.assign(
      {
        nodeFrom: null,
        // input
        slotFrom: null,
        // input
        nodeTo: null,
        // output
        slotTo: null,
        // output
        position: [],
        // pass the event coords
        nodeType: null,
        // choose a nodetype to add, AUTO to set at first good
        posAdd: [0, 0],
        // adjust x,y
        posSizeFix: [0, 0]
        // alpha, adjust the position x,y based on the new node size w,h
      },
      n
    ), r = this, s = t.nodeFrom && t.slotFrom !== null, a = !s && t.nodeTo && t.slotTo !== null;
    if (!s && !a)
      return (m = LiteGraph.warn) == null || m.call(LiteGraph, "No data passed to createDefaultNodeForSlot " + t.nodeFrom + " " + t.slotFrom + " " + t.nodeTo + " " + t.slotTo), !1;
    if (!t.nodeType)
      return (T = LiteGraph.warn) == null || T.call(LiteGraph, "No type to createDefaultNodeForSlot"), !1;
    var o = s ? t.nodeFrom : t.nodeTo, u = s ? t.slotFrom : t.slotTo, h = !1;
    switch (typeof u) {
      case "string":
        h = s ? o.findOutputSlot(u, !1) : o.findInputSlot(u, !1), u = s ? o.outputs[u] : o.inputs[u];
        break;
      case "object":
        h = s ? o.findOutputSlot(u.name) : o.findInputSlot(u.name);
        break;
      case "number":
        h = u, u = s ? o.outputs[u] : o.inputs[u];
        break;
      default:
        return (L = LiteGraph.warn) == null || L.call(LiteGraph, "Cant get slot information " + u), !1;
    }
    (u === !1 || h === !1) && ((G = LiteGraph.warn) == null || G.call(LiteGraph, "createDefaultNodeForSlot bad slotX " + u + " " + h));
    var l = u.type == LiteGraph.EVENT ? "_event_" : u.type, c = s ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
    if (c && c[l]) {
      u.link;
      var d = !1;
      if (typeof c[l] == "object") {
        for (var f in c[l])
          if (t.nodeType == c[l][f] || t.nodeType == "AUTO") {
            d = c[l][f];
            break;
          }
      } else
        (t.nodeType == c[l] || t.nodeType == "AUTO") && (d = c[l]);
      if (d) {
        var _ = !1;
        typeof d == "object" && d.node && (_ = d, d = d.node);
        var E = LiteGraph.createNode(d);
        if (E) {
          if (_) {
            if (_.properties)
              for (const [b, I] of Object.entries(_.properties))
                E.addProperty(b, I);
            _.inputs && (E.inputs = [], Object.values(_.inputs).forEach((b) => {
              E.addOutput(b[0], b[1]);
            })), _.outputs && (E.outputs = [], Object.values(_.outputs).forEach((b) => {
              E.addOutput(b[0], b[1]);
            })), _.title && (E.title = _.title), _.json && E.configure(_.json);
          }
          return r.graph.add(E), E.pos = [
            t.position[0] + t.posAdd[0] + (t.posSizeFix[0] ? t.posSizeFix[0] * E.size[0] : 0),
            t.position[1] + t.posAdd[1] + (t.posSizeFix[1] ? t.posSizeFix[1] * E.size[1] : 0)
          ], s ? t.nodeFrom.connectByType(h, E, l) : t.nodeTo.connectByTypeOutput(h, E, l), !0;
        } else
          (O = LiteGraph.warn) == null || O.call(LiteGraph, "failed creating " + d);
      }
    }
    return !1;
  }
  showConnectionMenu(n = {}) {
    var _, E;
    var t = Object.assign({
      nodeFrom: null,
      // input
      slotFrom: null,
      // input
      nodeTo: null,
      // output
      slotTo: null,
      // output
      e: null
    }, n), r = this, s = t.nodeFrom && t.slotFrom, a = !s && t.nodeTo && t.slotTo;
    if (!s && !a)
      return (_ = LiteGraph.warn) == null || _.call(LiteGraph, "No data passed to showConnectionMenu"), !1;
    var o = s ? t.nodeFrom : t.nodeTo, u = s ? t.slotFrom : t.slotTo, h = !1;
    switch (typeof u) {
      case "string":
        h = s ? o.findOutputSlot(u, !1) : o.findInputSlot(u, !1), u = s ? o.outputs[u] : o.inputs[u];
        break;
      case "object":
        h = s ? o.findOutputSlot(u.name) : o.findInputSlot(u.name);
        break;
      case "number":
        h = u, u = s ? o.outputs[u] : o.inputs[u];
        break;
      default:
        return (E = LiteGraph.warn) == null || E.call(LiteGraph, "Cant get slot information " + u), !1;
    }
    var l = ["Add Node", null];
    r.allow_searchbox && (l.push("Search"), l.push(null));
    const c = u.type === LiteGraph.EVENT ? "_event_" : u.type, d = s ? LiteGraph.slot_types_default_out : LiteGraph.slot_types_default_in;
    if (d && d[c]) {
      const m = d[c];
      Array.isArray(m) || typeof m == "object" ? Object.values(m).forEach((T) => {
        l.push(T);
      }) : l.push(m);
    }
    var f = new LiteGraph.ContextMenu(l, {
      event: t.e,
      title: (u && u.name != "" ? u.name + (c ? " | " : "") : "") + (u && c ? c : ""),
      callback: (m, T, L) => {
        const G = {
          "Add Node": () => {
            _LGraphCanvas.onMenuAdd(null, null, L, f, (O) => {
              s ? t.nodeFrom.connectByType(h, O, c) : t.nodeTo.connectByTypeOutput(h, O, c);
            });
          },
          Search: () => {
            s ? r.showSearchBox(L, { node_from: t.nodeFrom, slot_from: u, type_filter_in: c }) : r.showSearchBox(L, { node_to: t.nodeTo, slot_from: u, type_filter_out: c });
          },
          default: () => {
            r.createDefaultNodeForSlot(Object.assign(t, { position: [t.e.canvasX, t.e.canvasY], nodeType: m }));
          }
        };
        (G[m] || G.default)();
      }
    });
    return !1;
  }
  // TODO refactor :: this is used fot title but not for properties!
  static onShowPropertyEditor(n, t, r, s, a) {
    var o = n.property || "title", u = a[o], h = document.createElement("div");
    h.is_modified = !1, h.className = "graphdialog", h.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>", h.close = () => {
      var b;
      (b = h.parentNode) == null || b.removeChild(h);
    };
    var l = h.querySelector(".name");
    l.innerText = o;
    var c = h.querySelector(".value");
    const d = () => {
      c && O(c.value);
    };
    c && (c.value = u, c.addEventListener("blur", function(b) {
      this.focus();
    }), c.addEventListener("keydown", function(b) {
      if (h.is_modified = !0, b.keyCode == 27)
        h.close();
      else if (b.keyCode == 13)
        d();
      else if (b.keyCode != 13 && b.target.localName != "textarea")
        return;
      b.preventDefault(), b.stopPropagation();
    }));
    var f = _LGraphCanvas.active_canvas, _ = f.canvas, E = _.getBoundingClientRect(), m = -20, T = -20;
    E && (m -= E.left, T -= E.top), event ? (h.style.left = event.clientX + m + "px", h.style.top = event.clientY + T + "px") : (h.style.left = _.width * 0.5 + m + "px", h.style.top = _.height * 0.5 + T + "px");
    var L = h.querySelector("button");
    L.addEventListener("click", d), _.parentNode.appendChild(h), c && c.focus();
    let G = null;
    h.addEventListener("pointerleave", (b) => {
      LiteGraph.dialog_close_on_mouse_leave && !h.is_modified && (G = setTimeout(h.close, LiteGraph.dialog_close_on_mouse_leave_delay));
    }), h.addEventListener("pointerenter", (b) => {
      LiteGraph.dialog_close_on_mouse_leave && G && clearTimeout(G);
    });
    const O = (b) => {
      var I;
      switch (n.type) {
        case "Number":
          b = Number(b);
          break;
        case "Boolean":
          b = !!b;
          break;
      }
      a[o] = b, (I = h.parentNode) == null || I.removeChild(h), a.setDirtyCanvas(!0, !0);
    };
  }
  // refactor: there are different dialogs, some uses createDialog some dont
  // prompt v2
  prompt(n = "", t, r, s, a) {
    var G;
    var o = document.createElement("div");
    o.is_modified = !1, o.className = "graphdialog rounded", a ? o.innerHTML = "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>" : o.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>", o.close = () => {
      var O;
      this.prompt_box = null, (O = o.parentNode) == null || O.removeChild(o);
    };
    var u = _LGraphCanvas.active_canvas, h = u.canvas;
    h.parentNode.appendChild(o), this.ds.scale > 1 && (o.style.transform = `scale(${this.ds.scale})`);
    var l = null;
    o.addEventListener("pointerleave", (O) => {
      LiteGraph.dialog_close_on_mouse_leave && !o.is_modified && LiteGraph.dialog_close_on_mouse_leave && (l = setTimeout(o.close, LiteGraph.dialog_close_on_mouse_leave_delay));
    }), o.addEventListener("pointerenter", (O) => {
      LiteGraph.dialog_close_on_mouse_leave && l && clearTimeout(l);
    });
    const c = o.querySelectorAll("select");
    c && c.forEach((O) => {
      O.addEventListener("click", (b) => {
      }), O.addEventListener("blur", (b) => {
      }), O.addEventListener("change", (b) => {
      });
    }), (G = this.prompt_box) == null || G.close(), this.prompt_box = o;
    var d = o.querySelector(".name");
    d.innerText = n;
    var f = o.querySelector(".value");
    f.value = t;
    const _ = f;
    _.addEventListener("keydown", (O) => {
      var b;
      switch (o.is_modified = !0, O.keyCode) {
        case 27:
          o.close();
          break;
        case 13:
          O.target.localName !== "textarea" && typeof r == "function" && (r(_.value), this.setDirty(!0)), (b = LiteGraph.debug) == null || b.call(LiteGraph, "prompt v2 ENTER", _.value, O.target.localName, r), o.close();
          break;
        default:
          return;
      }
      O.preventDefault(), O.stopPropagation();
    }), o.querySelector("button").addEventListener("click", (O) => {
      var b;
      typeof r == "function" && (r(_.value), this.setDirty(!0)), (b = LiteGraph.debug) == null || b.call(LiteGraph, "prompt v2 OK", _.value, r), o.close();
    });
    var m = h.getBoundingClientRect(), T = -20, L = -20;
    return m && (T -= m.left, L -= m.top), s ? (o.style.left = s.clientX + T + "px", o.style.top = s.clientY + L + "px") : (o.style.left = h.width * 0.5 + T + "px", o.style.top = h.height * 0.5 + L + "px"), setTimeout(function() {
      _.focus();
    }, 10), o;
  }
  showSearchBox(n, t) {
    var r = {
      slot_from: null,
      node_from: null,
      node_to: null,
      do_type_filter: LiteGraph.search_filter_enabled,
      // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out
      type_filter_in: !1,
      // these are default: pass to set initially set values
      type_filter_out: !1,
      show_general_if_none_on_typefilter: !0,
      show_general_after_typefiltered: !0,
      hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,
      show_all_if_empty: !0,
      show_all_on_open: LiteGraph.search_show_all_on_open
    };
    t = Object.assign(r, t || {});
    var s = this, a = _LGraphCanvas.active_canvas, o = a.canvas, u = o.ownerDocument || document, h = document.createElement("div");
    if (h.className = "litegraph litesearchbox graphdialog rounded", h.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>", t.do_type_filter && (h.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>", h.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>"), t.show_close_button && (h.innerHTML += "<button class='close_searchbox close'>X</button>"), h.innerHTML += "<div class='helper'></div>", u.fullscreenElement ? u.fullscreenElement.appendChild(h) : (u.body.appendChild(h), u.body.style.overflow = "hidden"), t.do_type_filter)
      var l = h.querySelector(".slot_in_type_filter"), c = h.querySelector(".slot_out_type_filter");
    if (h.close = function() {
      s.search_box = null, this.blur(), o.focus(), u.body.style.overflow = "", setTimeout(function() {
        s.canvas.focus();
      }, 20), h.parentNode && h.parentNode.removeChild(h);
    }, this.ds.scale > 1 && (h.style.transform = `scale(${this.ds.scale})`), t.hide_on_mouse_leave) {
      var d = !1, f = null;
      h.addEventListener("pointerenter", function(D) {
        f && (clearTimeout(f), f = null);
      }), h.addEventListener("pointerleave", function(D) {
        d || (f = setTimeout(function() {
          h.close();
        }, 500));
      }), t.do_type_filter && (l.addEventListener("click", function(D) {
        d++;
      }), l.addEventListener("blur", function(D) {
        d = 0;
      }), l.addEventListener("change", function(D) {
        d = -1;
      }), c.addEventListener("click", function(D) {
        d++;
      }), c.addEventListener("blur", function(D) {
        d = 0;
      }), c.addEventListener("change", function(D) {
        d = -1;
      }));
    }
    s.search_box && s.search_box.close(), s.search_box = h;
    var _ = h.querySelector(".helper"), E = null, m = null, T = null, L = h.querySelector("input");
    if (L && (L.addEventListener("blur", function(D) {
      s.search_box && this.focus();
    }), L.addEventListener("keydown", function(D) {
      if (D.keyCode == 38)
        N(!1);
      else if (D.keyCode == 40)
        N(!0);
      else if (D.keyCode == 27)
        h.close();
      else if (D.keyCode == 13)
        C(), T ? S(T.innerHTML) : E ? S(E) : h.close();
      else {
        m && clearInterval(m), m = setTimeout(C, 250);
        return;
      }
      return D.preventDefault(), D.stopPropagation(), D.stopImmediatePropagation(), !0;
    })), t.do_type_filter) {
      if (l) {
        let D = LiteGraph.slot_types_in, M = D.length;
        (t.type_filter_in == LiteGraph.EVENT || t.type_filter_in == LiteGraph.ACTION) && (t.type_filter_in = "_event_");
        for (let P = 0; P < M; P++) {
          let A = document.createElement("option");
          A.value = D[P], A.innerHTML = D[P], l.appendChild(A), t.type_filter_in !== !1 && (t.type_filter_in + "").toLowerCase() == (D[P] + "").toLowerCase() && (A.selected = !0);
        }
        l.addEventListener("change", function() {
          C();
        });
      }
      if (c) {
        let D = LiteGraph.slot_types_out, M = D.length;
        (t.type_filter_out == LiteGraph.EVENT || t.type_filter_out == LiteGraph.ACTION) && (t.type_filter_out = "_event_");
        for (let P = 0; P < M; P++) {
          let A = document.createElement("option");
          A.value = D[P], A.innerHTML = D[P], c.appendChild(A), t.type_filter_out !== !1 && (t.type_filter_out + "").toLowerCase() == (D[P] + "").toLowerCase() && (A.selected = !0);
        }
        c.addEventListener("change", function() {
          C();
        });
      }
    }
    if (t.show_close_button) {
      var G = h.querySelector(".close");
      G.addEventListener("click", h.close);
    }
    var O = o.getBoundingClientRect(), b = (n ? n.clientX : O.left + O.width * 0.5) - 80, I = (n ? n.clientY : O.top + O.height * 0.5) - 20;
    O.width - b < 470 && (b = O.width - 470), O.height - I < 220 && (I = O.height - 220), b < O.left + 20 && (b = O.left + 20), I < O.top + 20 && (I = O.top + 20), h.style.left = b + "px", h.style.top = I + "px", L.focus(), t.show_all_on_open && C();
    function S(D) {
      if (D)
        if (s.onSearchBoxSelection)
          s.onSearchBoxSelection(D, n, a);
        else {
          var M = LiteGraph.searchbox_extras[D.toLowerCase()];
          M && (D = M.type), a.graph.beforeChange();
          var P = LiteGraph.createNode(D);
          if (P && (P.pos = a.convertEventToCanvasOffset(n), a.graph.add(P, !1, { doProcessChange: !1 })), M && M.data) {
            if (M.data.properties)
              for (let R in M.data.properties)
                P.addProperty(R, M.data.properties[R]);
            if (M.data.inputs) {
              P.inputs = [];
              for (let R in M.data.inputs)
                P.addOutput(
                  M.data.inputs[R][0],
                  M.data.inputs[R][1]
                );
            }
            if (M.data.outputs) {
              P.outputs = [];
              for (let R in M.data.outputs)
                P.addOutput(
                  M.data.outputs[R][0],
                  M.data.outputs[R][1]
                );
            }
            M.data.title && (P.title = M.data.title), M.data.json && P.configure(M.data.json);
          }
          let A;
          if (t.node_from) {
            switch (A = !1, typeof t.slot_from) {
              case "string":
                A = t.node_from.findOutputSlot(t.slot_from);
                break;
              case "object":
                t.slot_from.name ? A = t.node_from.findOutputSlot(t.slot_from.name) : A = -1, A == -1 && typeof t.slot_from.slot_index != "undefined" && (A = t.slot_from.slot_index);
                break;
              case "number":
                A = t.slot_from;
                break;
              default:
                A = 0;
            }
            typeof t.node_from.outputs[A] != "undefined" && A !== !1 && A > -1 && t.node_from.connectByType(A, P, t.node_from.outputs[A].type);
          }
          if (t.node_to) {
            switch (A = !1, typeof t.slot_from) {
              case "string":
                A = t.node_to.findInputSlot(t.slot_from);
                break;
              case "object":
                t.slot_from.name ? A = t.node_to.findInputSlot(t.slot_from.name) : A = -1, A == -1 && typeof t.slot_from.slot_index != "undefined" && (A = t.slot_from.slot_index);
                break;
              case "number":
                A = t.slot_from;
                break;
              default:
                A = 0;
            }
            typeof t.node_to.inputs[A] != "undefined" && A !== !1 && A > -1 && t.node_to.connectByTypeOutput(A, P, t.node_to.inputs[A].type);
          }
          a.graph.afterChange();
        }
      h.close();
    }
    function N(D) {
      var M = T;
      T && T.classList.remove("selected"), T ? (T = D ? T.nextSibling : T.previousSibling, T || (T = M)) : T = D ? _.childNodes[0] : _.childNodes[_.childNodes.length], T && (T.classList.add("selected"), T.scrollIntoView({ block: "end", behavior: "smooth" }));
    }
    function C() {
      m = null;
      var D = L.value;
      if (E = null, _.innerHTML = "", !D && !t.show_all_if_empty)
        return;
      if (s.onSearchBox) {
        var M = s.onSearchBox(_, D, a);
        if (M)
          for (let $ = 0; $ < M.length; ++$)
            V(M[$]);
      } else {
        let H = function(z, K = {}) {
          var tt = {
            skipFilter: !1,
            inTypeOverride: !1,
            outTypeOverride: !1
          }, W = Object.assign(tt, K), Q = LiteGraph.registered_node_types[z];
          if (A && Q.filter != A || (!t.show_all_if_empty || D) && z.toLowerCase().indexOf(D) === -1)
            return !1;
          if (t.do_type_filter && !W.skipFilter) {
            var J = z;
            let Z;
            var q = $.value;
            if (W.inTypeOverride !== !1 && (q = W.inTypeOverride), $ && q && LiteGraph.registered_slot_in_types[q] && LiteGraph.registered_slot_in_types[q].nodes && (Z = LiteGraph.registered_slot_in_types[q].nodes.includes(J), Z === !1) || (q = U.value, W.outTypeOverride !== !1 && (q = W.outTypeOverride), U && q && LiteGraph.registered_slot_out_types[q] && LiteGraph.registered_slot_out_types[q].nodes && (Z = LiteGraph.registered_slot_out_types[q].nodes.includes(J), Z === !1)))
              return !1;
          }
          return !0;
        };
        var P = 0;
        D = D.toLowerCase();
        var A = a.filter || a.graph.filter;
        let $, U;
        t.do_type_filter && s.search_box ? ($ = s.search_box.querySelector(".slot_in_type_filter"), U = s.search_box.querySelector(".slot_out_type_filter")) : ($ = !1, U = !1);
        for (let z in LiteGraph.searchbox_extras) {
          var R = LiteGraph.searchbox_extras[z];
          if (!((!t.show_all_if_empty || D) && R.desc.toLowerCase().indexOf(D) === -1)) {
            var B = LiteGraph.registered_node_types[R.type];
            if (!(B && B.filter != A) && H(R.type) && (V(R.desc, "searchbox_extra"), _LGraphCanvas.search_limit !== -1 && P++ > _LGraphCanvas.search_limit))
              break;
          }
        }
        var X = null;
        if (Array.prototype.filter)
          X = Object.keys(LiteGraph.registered_node_types).filter(H);
        else {
          X = [];
          for (let z in LiteGraph.registered_node_types)
            H(z) && X.push(z);
        }
        for (let z = 0; z < X.length && (V(X[z]), !(_LGraphCanvas.search_limit !== -1 && P++ > _LGraphCanvas.search_limit)); z++)
          ;
        if (t.show_general_after_typefiltered && ($.value || U.value)) {
          var F = [];
          for (let z in LiteGraph.registered_node_types)
            H(z, { inTypeOverride: $ && $.value ? "*" : !1, outTypeOverride: U && U.value ? "*" : !1 }) && F.push(z);
          for (let z = 0; z < F.length && (V(F[z], "generic_type"), !(_LGraphCanvas.search_limit !== -1 && P++ > _LGraphCanvas.search_limit)); z++)
            ;
        }
        if (($.value || U.value) && _.childNodes.length == 0 && t.show_general_if_none_on_typefilter) {
          var F = [];
          for (let K in LiteGraph.registered_node_types)
            H(K, { skipFilter: !0 }) && F.push(K);
          for (let K = 0; K < F.length && (V(F[K], "not_in_filter"), !(_LGraphCanvas.search_limit !== -1 && P++ > _LGraphCanvas.search_limit)); K++)
            ;
        }
      }
      function V($, U) {
        var H = document.createElement("div");
        E || (E = $), H.innerText = $, H.dataset.type = escape($), H.className = "litegraph lite-search-item", U && (H.className += " " + U), H.addEventListener("click", function(z) {
          S(unescape(this.dataset.type));
        }), _.appendChild(H);
      }
    }
    return h;
  }
  showEditPropertyValue(n, t, r) {
    var _, E, m, T, L;
    if (!n || n.properties[t] === void 0)
      return;
    r = r || {};
    var s = n.getPropertyInfo(t), a = s.type;
    let o;
    if (a == "string" || a == "number" || a == "array" || a == "object")
      o = "<input autofocus type='text' class='value'/>";
    else if ((a == "enum" || a == "combo") && s.values) {
      (_ = LiteGraph.debug) == null || _.call(LiteGraph, "CREATING showEditPropertyValue ENUM COMBO", l, a, h), o = "<select autofocus type='text' class='value'>";
      for (let G in s.values) {
        var u = G;
        s.values.constructor === Array && (u = s.values[G]), o += "<option value='" + u + "' " + (u == n.properties[t] ? "selected" : "") + ">" + s.values[G] + "</option>";
      }
      o += "</select>";
    } else if (a == "boolean" || a == "toggle")
      o = "<input autofocus type='checkbox' class='value' " + (n.properties[t] ? "checked" : "") + "/>";
    else {
      (E = LiteGraph.warn) == null || E.call(LiteGraph, "unknown type: " + a);
      return;
    }
    var h = this.createDialog(
      "<span class='name'>" + (s.label ? s.label : t) + "</span>" + o + "<button>OK</button>",
      r
    ), l = !1;
    (a == "enum" || a == "combo") && s.values ? ((m = LiteGraph.debug) == null || m.call(LiteGraph, "showEditPropertyValue ENUM COMBO", l, a, h), l = h.querySelector("select"), l.addEventListener("change", function(G) {
      var O;
      h.modified(), (O = LiteGraph.debug) == null || O.call(LiteGraph, "Enum change", l, s, G.target), f(G.target.value);
    })) : a == "boolean" || a == "toggle" ? ((T = LiteGraph.debug) == null || T.call(LiteGraph, "showEditPropertyValue TOGGLE", l, a, h), l = h.querySelector("input"), l && l.addEventListener("click", function(G) {
      h.modified(), f(!!l.checked);
    })) : (l = h.querySelector("input"), (L = LiteGraph.debug) == null || L.call(LiteGraph, "showEditPropertyValue", l, a, h), l && (l.addEventListener("blur", function(G) {
      this.focus();
    }), u = n.properties[t] !== void 0 ? n.properties[t] : "", a !== "string" && (u = JSON.stringify(u)), l.value = u, l.addEventListener("keydown", function(G) {
      if (G.keyCode == 27)
        h.close();
      else if (G.keyCode == 13)
        d();
      else if (G.keyCode != 13) {
        h.modified();
        return;
      }
      G.preventDefault(), G.stopPropagation();
    }))), l && l.focus();
    var c = h.querySelector("button");
    c.addEventListener("click", d);
    function d() {
      f(l.value);
    }
    function f(G) {
      var O;
      s && s.values && s.values.constructor === Object && s.values[G] != null && (G = s.values[G]), typeof n.properties[t] == "number" && (G = Number(G)), (a == "array" || a == "object") && (G = JSON.parse(G)), n.properties[t] = G, (O = n.graph) == null || O.onGraphChanged({ action: "propertyChanged", doSave: !0 }), n.onPropertyChanged && n.onPropertyChanged(t, G), r.onclose && r.onclose(), h.close(), n.setDirtyCanvas(!0, !0);
    }
    return h;
  }
  // TODO refactor, theer are different dialog, some uses createDialog, some dont
  createDialog(n, t) {
    var r = { checkForInput: !1, closeOnLeave: !0, closeOnLeave_checkModified: !0 };
    t = Object.assign(r, t || {});
    var s = document.createElement("div");
    s.className = "graphdialog", s.innerHTML = n, s.is_modified = !1;
    var a = this.canvas.getBoundingClientRect(), o = -20, u = -20;
    if (a && (o -= a.left, u -= a.top), t.position ? (o += t.position[0], u += t.position[1]) : t.event ? (o += t.event.clientX, u += t.event.clientY) : (o += this.canvas.width * 0.5, u += this.canvas.height * 0.5), s.style.left = o + "px", s.style.top = u + "px", this.canvas.parentNode.appendChild(s), t.checkForInput) {
      var h = [], l = !1;
      h = s.querySelectorAll("input"), h && h.forEach(function(_) {
        _.addEventListener("keydown", function(E) {
          if (s.modified(), E.keyCode == 27)
            s.close();
          else if (E.keyCode != 13)
            return;
          E.preventDefault(), E.stopPropagation();
        }), l || _.focus();
      });
    }
    s.modified = function() {
      s.is_modified = !0;
    }, s.close = function() {
      s.parentNode && s.parentNode.removeChild(s);
    };
    var c = null, d = !1;
    s.addEventListener("pointerleave", function(_) {
      d || (t.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) && !s.is_modified && LiteGraph.dialog_close_on_mouse_leave && (c = setTimeout(s.close, LiteGraph.dialog_close_on_mouse_leave_delay));
    }), s.addEventListener("pointerenter", function(_) {
      (t.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) && c && clearTimeout(c);
    });
    var f = s.querySelectorAll("select");
    return f && f.forEach(function(_) {
      _.addEventListener("click", function(E) {
        d++;
      }), _.addEventListener("blur", function(E) {
        d = 0;
      }), _.addEventListener("change", function(E) {
        d = -1;
      });
    }), s;
  }
  createPanel(n, t) {
    t = t || {};
    var r = t.window || window, s = document.createElement("div");
    if (s.className = "litegraph dialog", s.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>", s.header = s.querySelector(".dialog-header"), t.width && (s.style.width = t.width + (t.width.constructor === Number ? "px" : "")), t.height && (s.style.height = t.height + (t.height.constructor === Number ? "px" : "")), t.closable) {
      var a = document.createElement("span");
      a.innerHTML = "&#10005;", a.classList.add("close"), a.addEventListener("click", function() {
        s.close();
      }), s.header.appendChild(a);
    }
    return s.title_element = s.querySelector(".dialog-title"), s.title_element.innerText = n, s.content = s.querySelector(".dialog-content"), s.alt_content = s.querySelector(".dialog-alt-content"), s.footer = s.querySelector(".dialog-footer"), s.close = function() {
      s.onClose && typeof s.onClose == "function" && s.onClose(), s.parentNode && s.parentNode.removeChild(s), this.parentNode && this.parentNode.removeChild(this);
    }, s.toggleAltContent = function(o) {
      let u, h;
      typeof o != "undefined" ? (u = o ? "block" : "none", h = o ? "none" : "block") : (u = s.alt_content.style.display != "block" ? "block" : "none", h = s.alt_content.style.display != "block" ? "none" : "block"), s.alt_content.style.display = u, s.content.style.display = h;
    }, s.toggleFooterVisibility = function(o) {
      let u;
      typeof o != "undefined" ? u = o ? "block" : "none" : u = s.footer.style.display != "block" ? "block" : "none", s.footer.style.display = u;
    }, s.clear = function() {
      this.content.innerHTML = "";
    }, s.addHTML = function(o, u, h) {
      var l = document.createElement("div");
      return u && (l.className = u), l.innerHTML = o, h ? s.footer.appendChild(l) : s.content.appendChild(l), l;
    }, s.addButton = function(o, u, h) {
      var l = document.createElement("button");
      return l.innerText = o, l.options = h, l.classList.add("btn"), l.addEventListener("click", u), s.footer.appendChild(l), l;
    }, s.addSeparator = function() {
      var o = document.createElement("div");
      o.className = "separator", s.content.appendChild(o);
    }, s.addWidget = function(o, u, h, l, c) {
      var m, T;
      l = l || {};
      var d = String(h);
      o = o.toLowerCase(), o == "number" && (d = h.toFixed(3));
      var f = document.createElement("div");
      f.className = "property", f.innerHTML = "<span class='property_name'></span><span class='property_value'></span>", f.querySelector(".property_name").innerText = l.label || u;
      var _ = f.querySelector(".property_value");
      _.innerText = d, f.dataset.property = u, f.dataset.type = l.type || o, f.options = l, f.value = h, (m = LiteGraph.debug) == null || m.call(LiteGraph, "addWidget", o, h, _, l), o == "code" ? f.addEventListener("click", function(L) {
        s.inner_showCodePad(this.dataset.property);
      }) : o == "boolean" ? (f.classList.add("boolean"), h && f.classList.add("bool-on"), f.addEventListener("click", function() {
        var L = this.dataset.property;
        this.value = !this.value, this.classList.toggle("bool-on"), this.querySelector(".property_value").innerText = this.value ? "true" : "false", E(L, this.value);
      })) : o == "string" || o == "number" ? (_.setAttribute("contenteditable", !0), _.addEventListener("keydown", function(L) {
        L.code == "Enter" && (o != "string" || !L.shiftKey) && (L.preventDefault(), this.blur());
      }), _.addEventListener("blur", function() {
        var L = this.innerText, G = this.parentNode.dataset.property, O = this.parentNode.dataset.type;
        O == "number" && (L = Number(L)), E(G, L);
      })) : (o == "enum" || o == "combo") && (d = _LGraphCanvas.getPropertyPrintableValue(h, l.values), _.innerText = d, (T = LiteGraph.debug) == null || T.call(LiteGraph, "addWidget ENUM COMBO", o, d, _, l), _.addEventListener("click", function(L) {
        var G = l.values || [], O = this.parentNode.dataset.property, b = this;
        new LiteGraph.ContextMenu(
          G,
          {
            event: L,
            className: "dark",
            callback: I
          },
          r
        );
        function I(S) {
          return b.innerText = S, E(O, S), !1;
        }
      })), s.content.appendChild(f);
      function E(L, G) {
        var O;
        (O = LiteGraph.debug) == null || O.call(LiteGraph, "widgetInnerChange", L, G, l), l.callback && l.callback(L, G, l), c && c(L, G, l);
      }
      return f;
    }, s.onOpen && typeof s.onOpen == "function" && s.onOpen(), s;
  }
  static getPropertyPrintableValue(n, t) {
    if (!t || t.constructor === Array)
      return String(n);
    if (t.constructor === Object) {
      var r = "";
      for (var s in t)
        if (t[s] == n) {
          r = s;
          break;
        }
      return String(n) + " (" + r + ")";
    }
  }
  closePanels() {
    var n = document.querySelector("#node-panel");
    n && n.close(), n = document.querySelector("#option-panel"), n && n.close();
  }
  showShowGraphOptionsPanel(n, t) {
    var o, u, h, l;
    let r;
    if (this.constructor && this.constructor.name == "HTMLDivElement") {
      if (!((u = (o = t == null ? void 0 : t.event) == null ? void 0 : o.target) != null && u.lgraphcanvas)) {
        (h = LiteGraph.warn) == null || h.call(LiteGraph, "References not found to add optionPanel", n, t), LiteGraph.debug && ((l = LiteGraph.debug) == null || l.call(LiteGraph, "!obEv || !obEv.event || !obEv.event.target || !obEv.event.target.lgraphcanvas", t, t.event, t.event.target, t.event.target.lgraphcanvas));
        return;
      }
      r = t.event.target.lgraphcanvas;
    } else
      r = this;
    r.closePanels();
    var s = r.getCanvasWindow();
    panel = r.createPanel("Options", {
      closable: !0,
      window: s,
      onOpen: function() {
        r.OPTIONPANEL_IS_OPEN = !0;
      },
      onClose: function() {
        r.OPTIONPANEL_IS_OPEN = !1, r.options_panel = null;
      }
    }), r.options_panel = panel, panel.id = "option-panel", panel.classList.add("settings");
    function a() {
      panel.content.innerHTML = "";
      const c = (E, m, T) => {
        T && T.key && (E = T.key), T.values && (m = Object.values(T.values).indexOf(m)), r[E] = m;
      };
      var d = LiteGraph.availableCanvasOptions;
      d.sort();
      for (var f in d) {
        var _ = d[f];
        panel.addWidget("boolean", _, r[_], { key: _, on: "True", off: "False" }, c);
      }
      panel.addWidget("combo", "Render mode", LiteGraph.LINK_RENDER_MODES[r.links_render_mode], { key: "links_render_mode", values: LiteGraph.LINK_RENDER_MODES }, c), panel.addSeparator(), panel.footer.innerHTML = "";
    }
    a(), r.canvas.parentNode.appendChild(panel);
  }
  showShowNodePanel(n) {
    this.SELECTED_NODE = n, this.closePanels();
    var t = this.getCanvasWindow(), r = this, s = this.createPanel(n.title || "", {
      closable: !0,
      window: t,
      onOpen: function() {
        r.NODEPANEL_IS_OPEN = !0;
      },
      onClose: function() {
        r.NODEPANEL_IS_OPEN = !1, r.node_panel = null;
      }
    });
    r.node_panel = s, s.id = "node-panel", s.node = n, s.classList.add("settings");
    function a() {
      s.content.innerHTML = "", s.addHTML("<span class='node_type'>" + n.type + "</span><span class='node_desc'>" + (n.constructor.desc || "") + "</span><span class='separator'></span>"), s.addHTML("<h3>Properties</h3>");
      const o = (d, f) => {
        var E, m;
        switch (r.graph.beforeChange(n), d) {
          case "Title":
            n.title = f;
            break;
          case "Mode":
            var _ = Object.values(LiteGraph.NODE_MODES).indexOf(f);
            _ >= 0 && LiteGraph.NODE_MODES[_] ? n.changeMode(_) : (E = LiteGraph.warn) == null || E.call(LiteGraph, "unexpected mode: " + f);
            break;
          case "Color":
            _LGraphCanvas.node_colors[f] ? (n.color = _LGraphCanvas.node_colors[f].color, n.bgcolor = _LGraphCanvas.node_colors[f].bgcolor) : (m = LiteGraph.warn) == null || m.call(LiteGraph, "unexpected color: " + f);
            break;
          default:
            n.setProperty(d, f);
            break;
        }
        r.graph.afterChange(), r.dirty_canvas = !0;
      };
      s.addWidget("string", "Title", n.title, {}, o), s.addWidget("combo", "Mode", LiteGraph.NODE_MODES[n.mode], { values: LiteGraph.NODE_MODES }, o);
      var u = "";
      n.color !== void 0 && (u = Object.keys(_LGraphCanvas.node_colors).filter(function(d) {
        return _LGraphCanvas.node_colors[d].color == n.color;
      })), s.addWidget("combo", "Color", u, { values: Object.keys(_LGraphCanvas.node_colors) }, o);
      for (var h in n.properties) {
        var l = n.properties[h], c = n.getPropertyInfo(h);
        n.onAddPropertyToPanel && n.onAddPropertyToPanel(h, s, l, c, o) || s.addWidget(c.widget || c.type, h, l, c, o);
      }
      s.addSeparator(), n.onShowCustomPanelInfo && n.onShowCustomPanelInfo(s), s.footer.innerHTML = "", s.addButton("Delete", function() {
        n.block_delete || (n.graph.remove(n), s.close());
      }).classList.add("delete");
    }
    s.inner_showCodePad = function(o) {
      s.classList.remove("settings"), s.classList.add("centered"), s.alt_content.innerHTML = "<textarea class='code'></textarea>";
      var u = s.alt_content.querySelector("textarea"), h = () => {
        s.toggleAltContent(!1), s.toggleFooterVisibility(!0), u.parentNode.removeChild(u), s.classList.add("settings"), s.classList.remove("centered"), a();
      };
      u.value = n.properties[o], u.addEventListener("keydown", function(d) {
        d.code == "Enter" && d.ctrlKey && (n.setProperty(o, u.value), h());
      }), s.toggleAltContent(!0), s.toggleFooterVisibility(!1), u.style.height = "calc(100% - 40px)";
      var l = s.addButton("Assign", function() {
        n.setProperty(o, u.value), h();
      });
      s.alt_content.appendChild(l);
      var c = s.addButton("Close", h);
      c.style.float = "right", s.alt_content.appendChild(c);
    }, a(), this.canvas.parentNode.appendChild(s);
  }
  showSubgraphPropertiesDialog(n) {
    var u;
    (u = LiteGraph.log) == null || u.call(LiteGraph, "showing subgraph properties dialog");
    var t = this.canvas.parentNode.querySelector(".subgraph_dialog");
    t && t.close();
    var r = this.createPanel("Subgraph Inputs", { closable: !0, width: 500 });
    r.node = n, r.classList.add("subgraph_dialog");
    function s() {
      if (r.clear(), n.inputs)
        for (let d = 0; d < n.inputs.length; ++d) {
          var h = n.inputs[d];
          if (!h.not_subgraph_input) {
            var l = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", c = r.addHTML(l, "subgraph_property");
            c.dataset.name = h.name, c.dataset.slot = d, c.querySelector(".name").innerText = h.name, c.querySelector(".type").innerText = h.type, c.querySelector("button").addEventListener("click", function(f) {
              n.removeInput(Number(this.parentNode.dataset.slot)), s();
            });
          }
        }
    }
    var a = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>", o = r.addHTML(a, "subgraph_property extra", !0);
    return o.querySelector("button").addEventListener("click", function(h) {
      var l = this.parentNode, c = l.querySelector(".name").value, d = l.querySelector(".type").value;
      !c || n.findInputSlot(c) != -1 || (n.addInput(c, d), l.querySelector(".name").value = "", l.querySelector(".type").value = "", s());
    }), s(), this.canvas.parentNode.appendChild(r), r;
  }
  showSubgraphPropertiesDialogRight(n) {
    var t = this.canvas.parentNode.querySelector(".subgraph_dialog");
    t && t.close();
    var r = this.createPanel("Subgraph Outputs", { closable: !0, width: 500 });
    r.node = n, r.classList.add("subgraph_dialog");
    function s() {
      if (r.clear(), n.outputs)
        for (let d = 0; d < n.outputs.length; ++d) {
          var h = n.outputs[d];
          if (!h.not_subgraph_output) {
            var l = "<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", c = r.addHTML(l, "subgraph_property");
            c.dataset.name = h.name, c.dataset.slot = d, c.querySelector(".name").innerText = h.name, c.querySelector(".type").innerText = h.type, c.querySelector("button").addEventListener("click", function(f) {
              n.removeOutput(Number(this.parentNode.dataset.slot)), s();
            });
          }
        }
    }
    var a = " + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>", o = r.addHTML(a, "subgraph_property extra", !0);
    o.querySelector(".name").addEventListener("keydown", function(h) {
      e.keyCode == 13 && u.apply(this);
    }), o.querySelector("button").addEventListener("click", function(h) {
      u.apply(this);
    });
    function u() {
      var h = this.parentNode, l = h.querySelector(".name").value, c = h.querySelector(".type").value;
      !l || n.findOutputSlot(l) != -1 || (n.addOutput(l, c), h.querySelector(".name").value = "", h.querySelector(".type").value = "", s());
    }
    return s(), this.canvas.parentNode.appendChild(r), r;
  }
  checkPanels() {
    if (this.canvas) {
      var n = this.canvas.parentNode.querySelectorAll(".litegraph.dialog");
      for (let r = 0; r < n.length; ++r) {
        var t = n[r];
        t.node && (!t.node.graph || t.graph != this.graph) && t.close();
      }
    }
  }
  static onMenuNodeCollapse(n, t, r, s, a) {
    a.graph.beforeChange(
      /* ?*/
    );
    var o = function(h) {
      h.collapse();
    }, u = _LGraphCanvas.active_canvas;
    if (!u.selected_nodes || Object.keys(u.selected_nodes).length <= 1)
      o(a);
    else
      for (let h in u.selected_nodes)
        o(u.selected_nodes[h]);
    a.graph.afterChange(
      /* ?*/
    );
  }
  static onMenuNodePin(n, t, r, s, a) {
    a.pin();
  }
  static onMenuNodeMode(n, t, r, s, a) {
    new LiteGraph.ContextMenu(
      LiteGraph.NODE_MODES,
      { event: r, callback: o, parentMenu: s, node: a }
    );
    function o(u) {
      if (!a)
        return;
      var h = Object.values(LiteGraph.NODE_MODES).indexOf(u);
      const l = (d) => {
        var f;
        h >= 0 && LiteGraph.NODE_MODES[h] ? d.changeMode(h) : ((f = LiteGraph.warn) == null || f.call(LiteGraph, "unexpected mode: " + u), d.changeMode(LiteGraph.ALWAYS));
      };
      var c = _LGraphCanvas.active_canvas;
      if (!c.selected_nodes || Object.keys(c.selected_nodes).length <= 1)
        l(a);
      else
        for (let d in c.selected_nodes)
          l(c.selected_nodes[d]);
    }
    return !1;
  }
  static onMenuNodeColors(n, t, r, s, a) {
    if (!a)
      throw new Error("no node for color");
    var o = [];
    o.push({
      value: null,
      content: "<span style='display: block; padding-left: 4px;'>No color</span>"
    });
    for (let h in _LGraphCanvas.node_colors) {
      let l = _LGraphCanvas.node_colors[h];
      n = {
        value: h,
        content: "<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + l.color + "; background-color:" + l.bgcolor + "'>" + h + "</span>"
      }, o.push(n);
    }
    new LiteGraph.ContextMenu(o, {
      event: r,
      callback: u,
      parentMenu: s,
      node: a
    });
    function u(h) {
      if (!a)
        return;
      let l = h.value ? _LGraphCanvas.node_colors[h.value] : null;
      const c = (f) => {
        l ? f.constructor === LiteGraph.LGraphGroup ? f.color = l.groupcolor : (f.color = l.color, f.bgcolor = l.bgcolor) : (delete f.color, delete f.bgcolor);
      };
      var d = _LGraphCanvas.active_canvas;
      if (!d.selected_nodes || Object.keys(d.selected_nodes).length <= 1)
        c(a);
      else
        for (let f in d.selected_nodes)
          c(d.selected_nodes[f]);
      a.setDirtyCanvas(!0, !0);
    }
    return !1;
  }
  static onMenuNodeShapes(n, t, r, s, a) {
    if (!a)
      throw new Error("no node passed");
    new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {
      event: r,
      callback: o,
      parentMenu: s,
      node: a
    });
    function o(u) {
      if (!a)
        return;
      a.graph.beforeChange(
        /* ?*/
      );
      const h = (c) => {
        c.shape = u;
      };
      var l = _LGraphCanvas.active_canvas;
      if (!l.selected_nodes || Object.keys(l.selected_nodes).length <= 1)
        h(a);
      else
        for (let c in l.selected_nodes)
          h(l.selected_nodes[c]);
      a.graph.afterChange(
        /* ?*/
      ), a.setDirtyCanvas(!0);
    }
    return !1;
  }
  static onMenuNodeRemove(n, t, r, s, a) {
    if (!a)
      throw new Error("no node passed");
    var o = a.graph;
    o.beforeChange();
    const u = (l) => {
      l.removable !== !1 && o.remove(l);
    };
    var h = _LGraphCanvas.active_canvas;
    if (!h.selected_nodes || Object.keys(h.selected_nodes).length <= 1)
      u(a);
    else
      for (let l in h.selected_nodes)
        u(h.selected_nodes[l]);
    o.afterChange(), a.setDirtyCanvas(!0, !0);
  }
  static onMenuNodeToSubgraph(n, t, r, s, a) {
    var o = a.graph, u = _LGraphCanvas.active_canvas;
    if (u) {
      var h = Object.values(u.selected_nodes || {});
      h.length || (h = [a]);
      var l = LiteGraph.createNode("graph/subgraph");
      l.pos = a.pos.concat(), o.add(l), l.buildFromNodes(h), u.deselectAllNodes(), a.setDirtyCanvas(!0, !0);
    }
  }
  static onMenuNodeClone(n, t, r, s, a) {
    a.graph.beforeChange();
    var o = {};
    const u = (l) => {
      if (l.clonable !== !1) {
        var c = l.clone();
        c && (c.pos = [l.pos[0] + 5, l.pos[1] + 5], l.graph.add(c), o[c.id] = c);
      }
    };
    var h = _LGraphCanvas.active_canvas;
    if (!h.selected_nodes || Object.keys(h.selected_nodes).length <= 1)
      u(a);
    else
      for (let l in h.selected_nodes)
        u(h.selected_nodes[l]);
    Object.keys(o).length && h.selectNodes(o), a.graph.afterChange(), a.setDirtyCanvas(!0, !0);
  }
  getCanvasMenuOptions() {
    var n = null;
    if (this.getMenuOptions ? n = this.getMenuOptions() : (n = [
      {
        content: "Add Node",
        has_submenu: !0,
        callback: _LGraphCanvas.onMenuAdd
      },
      { content: "Add Group", callback: _LGraphCanvas.onGroupAdd }
      // { content: "Arrange", callback: that.graph.arrange },
      // {content:"Collapse All", callback: LGraphCanvas.onMenuCollapseAll }
    ], LiteGraph.showCanvasOptions && n.push({ content: "Options", callback: this.showShowGraphOptionsPanel }), Object.keys(this.selected_nodes).length > 1 && n.push({
      content: "Align",
      has_submenu: !0,
      callback: _LGraphCanvas.onGroupAlign
    }), this._graph_stack && this._graph_stack.length > 0 && n.push(null, {
      content: "Close subgraph",
      callback: this.closeSubgraph.bind(this)
    })), this.getExtraMenuOptions) {
      var t = this.getExtraMenuOptions(this, n);
      t && (n = n.concat(t));
    }
    return n;
  }
  // called by processContextMenu to extract the menu list
  getNodeMenuOptions(n) {
    var t = null;
    if (n.getMenuOptions ? t = n.getMenuOptions(this) : (t = [
      {
        content: "Inputs",
        has_submenu: !0,
        disabled: !0,
        callback: _LGraphCanvas.showMenuNodeOptionalInputs
      },
      {
        content: "Outputs",
        has_submenu: !0,
        disabled: !0,
        callback: _LGraphCanvas.showMenuNodeOptionalOutputs
      },
      null,
      {
        content: "Properties",
        has_submenu: !0,
        callback: _LGraphCanvas.onShowMenuNodeProperties
      },
      null,
      {
        content: "Title",
        callback: _LGraphCanvas.onShowPropertyEditor
      },
      {
        content: "Mode",
        has_submenu: !0,
        callback: _LGraphCanvas.onMenuNodeMode
      }
    ], n.resizable !== !1 && t.push({
      content: "Resize",
      callback: _LGraphCanvas.onMenuResizeNode
    }), t.push(
      {
        content: "Collapse",
        callback: _LGraphCanvas.onMenuNodeCollapse
      },
      { content: "Pin", callback: _LGraphCanvas.onMenuNodePin },
      {
        content: "Colors",
        has_submenu: !0,
        callback: _LGraphCanvas.onMenuNodeColors
      },
      {
        content: "Shapes",
        has_submenu: !0,
        callback: _LGraphCanvas.onMenuNodeShapes
      },
      null
    )), n.onGetInputs) {
      var r = n.onGetInputs();
      r && r.length && (t[0].disabled = !1);
    }
    if (n.onGetOutputs) {
      var s = n.onGetOutputs();
      s && s.length && (t[1].disabled = !1);
    }
    if (LiteGraph.do_add_triggers_slots && (t[1].disabled = !1), n.getExtraMenuOptions) {
      var a = n.getExtraMenuOptions(this, t);
      a && (a.push(null), t = a.concat(t));
    }
    return n.clonable !== !1 && t.push({
      content: "Clone",
      callback: _LGraphCanvas.onMenuNodeClone
    }), Object.keys(this.selected_nodes).length > 1 && t.push({
      content: "Align Selected To",
      has_submenu: !0,
      callback: _LGraphCanvas.onNodeAlign
    }), t.push(null, {
      content: "Remove",
      disabled: !(n.removable !== !1 && !n.block_delete),
      callback: _LGraphCanvas.onMenuNodeRemove
    }), n.graph && n.graph.onGetNodeMenuOptions && n.graph.onGetNodeMenuOptions(t, n), t;
  }
  getGroupMenuOptions() {
    var n = [
      { content: "Title", callback: _LGraphCanvas.onShowPropertyEditor },
      {
        content: "Color",
        has_submenu: !0,
        callback: _LGraphCanvas.onMenuNodeColors
      },
      {
        content: "Font size",
        property: "font_size",
        type: "Number",
        callback: _LGraphCanvas.onShowPropertyEditor
      },
      null,
      { content: "Remove", callback: _LGraphCanvas.onMenuNodeRemove }
    ];
    return n;
  }
  processContextMenu(n, t) {
    var _, E, m;
    var r = this, s = _LGraphCanvas.active_canvas, a = s.getCanvasWindow(), o = null, u = {
      event: t,
      callback: f,
      extra: n
    };
    n && (u.title = n.type);
    var h = null;
    if (n && (h = n.getSlotInPosition(t.canvasX, t.canvasY), _LGraphCanvas.active_node = n), h) {
      if (o = [], n.getSlotMenuOptions)
        o = n.getSlotMenuOptions(h);
      else {
        ((E = (_ = h == null ? void 0 : h.output) == null ? void 0 : _.links) != null && E.length || (m = h.input) != null && m.link) && o.push({ content: "Disconnect Links", slot: h });
        var l = h.input || h.output;
        l.removable && LiteGraph.canRemoveSlots && o.push(l.locked ? "Cannot remove" : { content: "Remove Slot", slot: h }), !l.nameLocked && LiteGraph.canRenameSlots && o.push({ content: "Rename Slot", slot: h });
      }
      var c = h.input || h.output;
      u.title = c.type || "*", c.type == LiteGraph.ACTION ? u.title = "Action" : c.type == LiteGraph.EVENT && (u.title = "Event");
    } else if (n)
      o = this.getNodeMenuOptions(n);
    else {
      o = this.getCanvasMenuOptions();
      var d = this.graph.getGroupOnPos(
        t.canvasX,
        t.canvasY
      );
      d && o.push(null, {
        content: "Edit Group",
        has_submenu: !0,
        submenu: {
          title: "Group",
          extra: d,
          options: this.getGroupMenuOptions(d)
        }
      });
    }
    if (!o)
      return;
    new LiteGraph.ContextMenu(o, u, a);
    function f(T, L) {
      if (!T)
        return;
      let G;
      if (T.content == "Remove Slot") {
        G = T.slot, n.graph.beforeChange(), G.input ? n.removeInput(G.slot) : G.output && n.removeOutput(G.slot), n.graph.afterChange();
        return;
      } else if (T.content == "Disconnect Links") {
        G = T.slot, n.graph.beforeChange(), G.output ? n.disconnectOutput(G.slot) : G.input && n.disconnectInput(G.slot), n.graph.afterChange();
        return;
      } else if (T.content == "Rename Slot") {
        G = T.slot;
        var O = G.input ? n.getInputInfo(G.slot) : n.getOutputInfo(G.slot), b = r.createDialog(
          "<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>",
          L
        ), I = b.querySelector("input");
        I && O && (I.value = O.label || "");
        var S = function() {
          n.graph.beforeChange(), I.value && (O && (O.label = I.value), r.setDirty(!0)), b.close(), n.graph.afterChange();
        };
        b.querySelector("button").addEventListener("click", S), I.addEventListener("keydown", function(N) {
          if (b.is_modified = !0, N.keyCode == 27)
            b.close();
          else if (N.keyCode == 13)
            S();
          else if (N.keyCode != 13 && N.target.localName != "textarea")
            return;
          N.preventDefault(), N.stopPropagation();
        }), I.focus();
      }
    }
  }
  /**
   * returns ture if low qualty rendering requered at requested scale
   * */
  lowQualityRenderingRequired(n) {
    return this.ds.scale < n ? this.low_quality_rendering_counter > this.low_quality_rendering_threshold : !1;
  }
};
g(_LGraphCanvas, "DEFAULT_BACKGROUND_IMAGE", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII="), g(_LGraphCanvas, "link_type_colors", {
  "-1": "#A86",
  number: "#AAA",
  node: "#DCA",
  string: "#77F",
  boolean: "#F77"
}), g(_LGraphCanvas, "gradients", {}), // cache of gradients
g(_LGraphCanvas, "search_limit", -1), g(_LGraphCanvas, "node_colors", {
  red: { color: "#322", bgcolor: "#533", groupcolor: "#A88" },
  brown: { color: "#332922", bgcolor: "#593930", groupcolor: "#b06634" },
  green: { color: "#232", bgcolor: "#353", groupcolor: "#8A8" },
  blue: { color: "#223", bgcolor: "#335", groupcolor: "#88A" },
  pale_blue: { color: "#2a363b", bgcolor: "#3f5159", groupcolor: "#3f789e" },
  cyan: { color: "#233", bgcolor: "#355", groupcolor: "#8AA" },
  purple: { color: "#323", bgcolor: "#535", groupcolor: "#a1309b" },
  yellow: { color: "#432", bgcolor: "#653", groupcolor: "#b58b2a" },
  black: { color: "#222", bgcolor: "#000", groupcolor: "#444" }
});
let LGraphCanvas = _LGraphCanvas;
var temp = new Float32Array(4), temp_vec2 = new Float32Array(2), tmp_area = new Float32Array(4), margin_area = new Float32Array(4), link_bounding = new Float32Array(4), tempA = new Float32Array(2), tempB = new Float32Array(2);
class DragAndScale {
  /**
   * Creates an instance of DragAndScale.
   * @param {HTMLElement} element - The HTML element to apply scale and offset transformations.
   * @param {boolean} skip_events - Flag indicating whether to skip binding mouse and wheel events.
   *
   * Rendering:
   * toCanvasContext() is HTMLCanvas, and onredraw is probably also.  The rest is all HTML+CSS+JS
   */
  constructor(t, r) {
    g(this, "onMouseDown", (t) => {
      if (!this.enabled)
        return;
      const s = this.element.getBoundingClientRect();
      var a = t.clientX - s.left, o = t.clientY - s.top;
      t.canvasx = a, t.canvasy = o, t.dragging = this.dragging;
      var u = !this.viewport || this.viewport && a >= this.viewport[0] && a < this.viewport[0] + this.viewport[2] && o >= this.viewport[1] && o < this.viewport[1] + this.viewport[3];
      u && (this.dragging = !0, this.abortController = new AbortController(), document.addEventListener("pointermove", this.onMouseMove, { signal: this.abortController.signal }), document.addEventListener("pointerup", this.onMouseUp, { signal: this.abortController.signal })), this.last_mouse[0] = a, this.last_mouse[1] = o;
    });
    g(this, "onMouseMove", (t) => {
      if (!this.enabled)
        return;
      const s = this.element.getBoundingClientRect();
      var a = t.clientX - s.left, o = t.clientY - s.top;
      t.canvasx = a, t.canvasy = o, t.dragging = this.dragging;
      var u = a - this.last_mouse[0], h = o - this.last_mouse[1];
      this.dragging && this.mouseDrag(u, h), this.last_mouse[0] = a, this.last_mouse[1] = o;
    });
    g(this, "onMouseUp", (t) => {
      var r;
      this.dragging = !1, (r = this.abortController) == null || r.abort();
    });
    g(this, "onWheel", (t) => {
      t.wheel = -t.deltaY, t.delta = t.wheelDelta ? t.wheelDelta / 40 : t.deltaY ? -t.deltaY / 3 : 0, this.changeDeltaScale(1 + t.delta * 0.05);
    });
    this.offset = new Float32Array([0, 0]), this.scale = 1, this.max_scale = 10, this.min_scale = 0.1, this.onredraw = null, this.enabled = !0, this.last_mouse = [0, 0], this.element = null, this.visible_area = new Float32Array(4), t && (this.element = t, r || this.bindEvents(t));
  }
  /**
   * Binds mouse and wheel events to the specified HTML element.
   *
   * @param {HTMLElement} element - The HTML element to bind the events to.
   */
  bindEvents(t) {
    this.last_mouse = new Float32Array(2), t.addEventListener("pointerdown", this.onMouseDown), t.addEventListener("wheel", this.onWheel);
  }
  /**
   * Computes the visible area of the DragAndScale element based on the viewport.
   *
   * If the element is not set, the visible area will be reset to zero.
   *
   * @param {Array<number>} [viewport] - The viewport configuration to calculate the visible area.
   */
  computeVisibleArea(t) {
    if (!this.element) {
      this.visible_area.set([0, 0, 0, 0]);
      return;
    }
    let r = this.element.width, s = this.element.height, a = -this.offset[0], o = -this.offset[1];
    if (t) {
      a += t[0] / this.scale, o += t[1] / this.scale;
      const [l, c] = t.slice(2);
      r = l, s = c;
    }
    const u = a + r / this.scale, h = o + s / this.scale;
    this.visible_area.set([a, o, u - a, h - o]);
  }
  /**
   * Applies the scale and offset transformations to the given 2D canvas rendering context.
   *
   * @param {CanvasRenderingContext2D} ctx - The 2D canvas rendering context to apply transformations to.
   */
  toCanvasContext(t) {
    t.scale(this.scale, this.scale), t.translate(this.offset[0], this.offset[1]);
  }
  /**
   * Converts a position from DragAndScale offset coordinates to canvas coordinates.
   *
   * @param {Array<number>} pos - The position in DragAndScale offset coordinates to convert.
   * @returns {Array<number>} The converted position in canvas coordinates.
   */
  convertOffsetToCanvas(t) {
    return [
      (t[0] + this.offset[0]) * this.scale,
      (t[1] + this.offset[1]) * this.scale
    ];
  }
  /**
   * Converts a position from canvas coordinates to DragAndScale offset coordinates.
   *
   * @param {Array<number>} pos - The position in canvas coordinates to convert.
   * @param {Array<number>} [out=[0, 0]] - The output array to store the converted position in DragAndScale offset coordinates.
   * @returns {Array<number>} The converted position in DragAndScale offset coordinates.
   */
  convertCanvasToOffset(t, r = [0, 0]) {
    return r[0] = t[0] / this.scale - this.offset[0], r[1] = t[1] / this.scale - this.offset[1], r;
  }
  mouseDrag(t, r) {
    var s;
    this.offset[0] += t / this.scale, this.offset[1] += r / this.scale, (s = this.onredraw) == null || s.call(this, this);
  }
  /**
   * Changes the scale of the DragAndScale element to the specified value around the zooming center.
   *
   * @param {number} value - The new scale value to set, clamped between min_scale and max_scale.
   * @param {Array<number>} zooming_center - The center point for zooming, defaulting to the middle of the element.
   */
  changeScale(t, r) {
    var h;
    if (t = LiteGraph.clamp(t, this.min_scale, this.max_scale), t == this.scale || !this.element)
      return;
    const s = this.element.getBoundingClientRect();
    if (s) {
      r = r || [
        s.width * 0.5,
        s.height * 0.5
      ];
      var a = this.convertCanvasToOffset(r);
      this.scale = t, Math.abs(this.scale - 1) < 0.01 && (this.scale = 1);
      var o = this.convertCanvasToOffset(r), u = [
        o[0] - a[0],
        o[1] - a[1]
      ];
      this.offset[0] += u[0], this.offset[1] += u[1], (h = this.onredraw) == null || h.call(this, this);
    }
  }
  /**
   * Changes the scale of the DragAndScale element by a delta value relative to the current scale.
   *
   * @param {number} value - The delta value by which to scale the element.
   * @param {Array<number>} zooming_center - The center point for zooming the element.
   */
  changeDeltaScale(t, r) {
    this.changeScale(this.scale * t, r);
  }
  reset() {
    this.scale = 1, this.offset[0] = 0, this.offset[1] = 0;
  }
}
var gt, Pe, Be, ke, Ue, $e, ze;
const Te = class Te {
  /**
  * @constructor
  * @param {Array<Object>} values (allows object { title: "Nice text", callback: function ... })
  * @param {Object} options [optional] Some options:\
  * - title: title to show on top of the menu
  * - callback: function to call when an option is clicked, it receives the item information
  * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback
  * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position
  *
  *   Rendering notes: This is only relevant to rendered graphs, and is rendered using HTML+CSS+JS.
  */
  constructor(t, r = {}) {
    Se(this, gt);
    var s;
    this.options = r, (s = r.scroll_speed) != null || (r.scroll_speed = 0.1), this.menu_elements = [], oe(this, gt, ke).call(this), oe(this, gt, Ue).call(this), oe(this, gt, Pe).call(this), oe(this, gt, Be).call(this), this.setTitle(this.options.title), this.addItems(t), oe(this, gt, $e).call(this), oe(this, gt, ze).call(this);
  }
  /**
   * Creates a title element if it doesn't have one.
   * Sets the title of the menu.
   * @param {string} title - The title to be set.
   */
  setTitle(t) {
    var s;
    if (!t)
      return;
    (s = this.titleElement) != null || (this.titleElement = document.createElement("div"));
    const r = this.titleElement;
    r.className = "litemenu-title", r.innerHTML = t, this.root.parentElement || this.root.appendChild(r);
  }
  /**
   * Adds a set of values to the menu.
   * @param {Array<string|object>} values - An array of values to be added.
   */
  addItems(t) {
    for (let r = 0; r < t.length; r++) {
      let s = t[r];
      typeof s != "string" && (s = s && s.content !== void 0 ? String(s.content) : String(s));
      let a = t[r];
      this.menu_elements.push(this.addItem(s, a, this.options));
    }
  }
  /**
   * Adds an item to the menu.
   * @param {string} name - The name of the item.
   * @param {object | null} value - The value associated with the item.
   * @param {object} [options={}] - Additional options for the item.
   * @returns {HTMLElement} - The created HTML element representing the added item.
   */
  addItem(t, r, s = {}) {
    var l;
    const a = document.createElement("div");
    a.className = "litemenu-entry submenu";
    let o = !1;
    r === null ? a.classList.add("separator") : (a.innerHTML = (l = r == null ? void 0 : r.title) != null ? l : t, a.value = r, r && (r.disabled && (o = !0, a.classList.add("disabled")), (r.submenu || r.has_submenu) && a.classList.add("has_submenu")), typeof r == "function" ? (a.dataset.value = t, a.onclick_callback = r) : a.dataset.value = r, r.className && (a.className += " " + r.className)), this.root.appendChild(a), o || a.addEventListener("click", h), !o && s.autoopen && a.addEventListener("pointerenter", (c) => {
      const d = this.value;
      !d || !d.has_submenu || h.call(this, c);
    });
    var u = this;
    function h(c) {
      var _, E, m, T, L;
      const d = this.value;
      let f = !0;
      if ((_ = LiteGraph.debug) == null || _.call(LiteGraph, "ContextMenu handleMenuItemClick", d, s, f, this.current_submenu, this), (E = u.current_submenu) == null || E.close(c), s.callback && ((m = LiteGraph.debug) == null || m.call(LiteGraph, "ContextMenu handleMenuItemClick callback", this, d, s, c, u, s.node), s.callback.call(this, d, s, c, u, s.node) === !0 && (f = !1)), d && (d.callback && !s.ignore_item_callbacks && d.disabled !== !0 && ((T = LiteGraph.debug) == null || T.call(LiteGraph, "ContextMenu using value callback and !ignore_item_callbacks", this, d, s, c, u, s.node), d.callback.call(this, d, s, c, u, s.extra) === !0 && (f = !1)), d.submenu)) {
        if ((L = LiteGraph.debug) == null || L.call(LiteGraph, "ContextMenu SUBMENU", this, d, d.submenu.options, e, u, s), !d.submenu.options)
          throw new Error("ContextMenu submenu needs options");
        new u.constructor(d.submenu.options, {
          callback: d.submenu.callback,
          event: c,
          parentMenu: u,
          ignore_item_callbacks: d.submenu.ignore_item_callbacks,
          title: d.submenu.title,
          extra: d.submenu.extra,
          autoopen: s.autoopen
        }), f = !1;
      }
      f && !u.lock && u.close();
    }
    return a;
  }
  /**
   * Closes this menu.
   * @param {Event} [e] - The event that triggered the close action.
   * @param {boolean} [ignore_parent_menu=false] - Whether to ignore the parent menu when closing.
   */
  close(t, r) {
    var s;
    if (this.root.f_textfilter) {
      let a = document;
      a.removeEventListener("keydown", this.root.f_textfilter, !0), a.removeEventListener("keydown", this.root.f_textfilter, !1), t && t.target && (a = t.target.ownerDocument), a || (a = document), a.removeEventListener("keydown", this.root.f_textfilter, !0), a.removeEventListener("keydown", this.root.f_textfilter, !1);
    }
    this.parentMenu && !r && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, t === void 0 ? this.parentMenu.close() : t && !Te.isCursorOverElement(t, this.parentMenu.root) && Te.trigger(this.parentMenu.root, "pointerleave", t)), (s = this.current_submenu) == null || s.close(t, !0), this.root.closing_timer && clearTimeout(this.root.closing_timer), this.root.parentNode && this.root.parentNode.removeChild(this.root);
  }
  /**
   * Triggers an event on the specified element with the given event name and parameters.
   * @param {HTMLElement} element - The element on which to trigger the event.
   * @param {string} event_name - The name of the event to trigger.
   * @param {Object} params - Additional parameters to include in the event.
   * @param {HTMLElement} origin - The origin of the event <currently not supported as CustomEvent can't have a target!>
   * @returns {CustomEvent} - The created CustomEvent instance.
   * @BUG: Probable bug related to params, origin not being configured/populated correctly
   */
  static trigger(t, r, s, a) {
    const o = new CustomEvent(r, {
      bubbles: !0,
      cancelable: !0,
      detail: s
    });
    return Object.defineProperty(o, "target", { value: a }), t.dispatchEvent ? t.dispatchEvent(o) : t.__events && t.__events.dispatchEvent(o), o;
  }
  // returns the top most menu
  getTopMenu() {
    var t, r;
    return (r = (t = this.options.parentMenu) == null ? void 0 : t.getTopMenu()) != null ? r : this;
  }
  getFirstEvent() {
    var t, r;
    return (r = (t = this.options.parentMenu) == null ? void 0 : t.getFirstEvent()) != null ? r : this.options.event;
  }
  static isCursorOverElement(t, r) {
    return LiteGraph.isInsideRectangle(t.clientX, t.clientY, r.left, r.top, r.width, r.height);
  }
};
gt = new WeakSet(), Pe = function() {
  const t = this.root = document.createElement("div");
  return this.options.className && (t.className = this.options.className), t.classList.add("litegraph", "litecontextmenu", "litemenubar-panel"), t.style.minWidth = "80px", t.style.minHeight = "10px", t;
}, Be = function() {
  const t = this.root;
  t.style.pointerEvents = "none", setTimeout(() => {
    t.style.pointerEvents = "auto";
  }, 100), t.addEventListener("pointerup", (r) => (r.preventDefault(), !0)), t.addEventListener("contextmenu", (r) => (r.button != 2 || r.preventDefault(), !1)), t.addEventListener("pointerdown", (r) => {
    if (r.button == 2)
      return this.close(), r.preventDefault(), !0;
  }), t.addEventListener("wheel", (r) => {
    var s = parseInt(t.style.top);
    return t.style.top = (s + r.deltaY * this.options.scroll_speed).toFixed() + "px", r.preventDefault(), !0;
  }), t.addEventListener("pointerenter", (r) => {
    t.closing_timer && clearTimeout(t.closing_timer);
  });
}, ke = function() {
  var r;
  const t = this.options.parentMenu;
  if (t) {
    if (t.constructor !== this.constructor) {
      (r = LiteGraph.error) == null || r.call(LiteGraph, "parentMenu must be of class ContextMenu, ignoring it"), this.options.parentMenu = null;
      return;
    }
    this.parentMenu = t, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this;
  }
}, Ue = function() {
  var r;
  if (!this.options.event)
    return;
  const t = this.options.event.constructor.name;
  t !== "MouseEvent" && t !== "CustomEvent" && t !== "PointerEvent" && ((r = LiteGraph.error) == null || r.call(LiteGraph, `Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (${t})`), this.options.event = null);
}, $e = function() {
  var o, u, h, l;
  const t = (u = (o = this.options.event) == null ? void 0 : o.target.ownerDocument) != null ? u : document, r = (h = t.fullscreenElement) != null ? h : t.body, s = this.root, a = this;
  LiteGraph.context_menu_filter_enabled && (t ? (s.f_textfilter && (t.removeEventListener("keydown", s.f_textfilter, !1), t.removeEventListener("keydown", s.f_textfilter, !0), s.f_textfilter = !1), s.f_textfilter = function(c) {
    var S, N, C, D, M, P, A;
    if (a.current_submenu) {
      (S = LiteGraph.debug) == null || S.call(LiteGraph, "Prevent filtering on ParentMenu", a);
      return;
    }
    if (a.allOptions || (a.allOptions = a.menu_elements, a.selectedOption = !1), a.currentOptions || (a.currentOptions = a.allOptions), a.filteringText || (a.filteringText = ""), c.key) {
      var d = !1;
      switch (c.key) {
        case "Backspace":
          a.filteringText.length && (a.filteringText = a.filteringText.substring(0, a.filteringText.length - 1), d = !0);
          break;
        case "Escape":
          s.f_textfilter && (t.removeEventListener("keydown", s.f_textfilter, !1), t.removeEventListener("keydown", s.f_textfilter, !0), s.f_textfilter = !1), a.close();
          break;
        case "ArrowDown":
          do
            a.selectedOption = a.selectedOption !== !1 ? Math.min(Math.max(a.selectedOption + 1, 0), a.allOptions.length - 1) : 0;
          while (a.allOptions[a.selectedOption] && a.allOptions[a.selectedOption].hidden && a.selectedOption < a.allOptions.length - 1);
          a.allOptions[a.selectedOption] && a.allOptions[a.selectedOption].hidden && (a.selectedOption = a.currentOptions[a.currentOptions.length - 1].menu_index), d = !0;
          break;
        case "ArrowUp":
          do
            a.selectedOption = a.selectedOption !== !1 ? Math.min(Math.max(a.selectedOption - 1, 0), a.allOptions.length - 1) : 0;
          while (a.allOptions[a.selectedOption] && a.allOptions[a.selectedOption].hidden && a.selectedOption > 0);
          a.allOptions[a.selectedOption] && a.allOptions[a.selectedOption].hidden && (a.currentOptions && a.currentOptions.length ? a.selectedOption = a.currentOptions[0].menu_index : a.selectedOption = !1), d = !0;
          break;
        case "ArrowLeft":
          break;
        case "ArrowRight":
        // right do same as enter
        case "Enter":
          if (a.selectedOption !== !1)
            a.allOptions[a.selectedOption] ? ((N = LiteGraph.debug) == null || N.call(LiteGraph, "ContextElement simCLICK", a.allOptions[iO]), a.allOptions[a.selectedOption].do_click && a.allOptions[a.selectedOption].do_click(a.options.event, f)) : ((C = LiteGraph.debug) == null || C.call(LiteGraph, "ContextElement selection wrong", a.selectedOption), a.selectedOption = a.selectedOption !== !1 ? Math.min(Math.max(a.selectedOption, 0), a.allOptions.length - 1) : 0);
          else if (a.filteringText.length) {
            for (let R in a.allOptions)
              if (a.allOptions[R].style.display !== "none" && !(a.allOptions[R].classList + "").includes("separator") && a.allOptions[R].textContent !== "Search") {
                (D = LiteGraph.debug) == null || D.call(LiteGraph, "ContextElement simCLICK", a.allOptions[R]), s.f_textfilter && t && (t.removeEventListener("keydown", s.f_textfilter, !1), t.removeEventListener("keydown", s.f_textfilter, !0), (M = LiteGraph.debug) == null || M.call(LiteGraph, "Cleaned ParentContextMenu listener", t, a));
                var f = !1;
                a.allOptions[R].do_click(c, f);
                break;
              }
          }
          d = !0;
          break;
        default:
          (P = LiteGraph.debug) == null || P.call(LiteGraph, "ContextMenu filter: keyEvent", c.keyCode, c.key), String.fromCharCode(c.key).match(/(\w|\s)/g);
          break;
      }
      !d && c.key.length == 1 && (a.filteringText += c.key, a.parentMenu);
    }
    if (a.filteringText && a.filteringText !== "") {
      var _ = [];
      a.currentOptions = [];
      for (let R in a.allOptions) {
        var E = a.allOptions[R].textContent, m = E.toLocaleLowerCase().includes(a.filteringText.toLocaleLowerCase()), T = E.toLocaleLowerCase().startsWith(a.filteringText.toLocaleLowerCase()), L = E.split("/"), G = !1;
        G = L.length > 1 && L[L.length - 1].toLocaleLowerCase().startsWith(a.filteringText.toLocaleLowerCase()) || L.length == 1 && T;
        var O = (a.allOptions[R].classList + "").includes("separator") || E === "Search";
        a.allOptions[R].menu_index = R, m && !O ? (_.push(a.allOptions[R]), a.allOptions[R].style.display = "block", a.allOptions[R].hidden = !1, a.currentOptions.push(a.allOptions[R]), a.allOptions[R].filtered_index = a.currentOptions.length - 1) : (a.allOptions[R].hidden = !0, a.allOptions[R].style.display = "none", a.allOptions[R].filtered_index = !1), G ? a.allOptions[R].style.fontWeight = "bold" : T && (a.allOptions[R].style.fontStyle = "italic");
      }
      a.selectedOption = a.selectedOption !== !1 ? Math.min(Math.max(a.selectedOption, 0), a.allOptions.length - 1) : 0, a.allOptions[a.selectedOption] && a.allOptions[a.selectedOption].hidden && a.currentOptions.length && (a.selectedOption = a.currentOptions[0].menu_index);
    } else {
      _ = a.allOptions, a.currentOptions = a.allOptions;
      for (let R in a.allOptions)
        a.allOptions[R].style.display = "block", a.allOptions[R].style.fontStyle = "inherit", a.allOptions[R].style.fontWeight = "inherit", a.allOptions[R].hidden = !1, a.allOptions[R].filtered_index = !1, a.allOptions[R].menu_index = R;
    }
    var b = a.selectedOption !== !1;
    if (b) {
      (A = LiteGraph.debug) == null || A.call(LiteGraph, "ContextMenu selection: ", a.selectedOption);
      for (let R in a.allOptions) {
        var I = a.selectedOption + "" == R + "";
        I ? a.allOptions[R].classList.add("selected") : a.allOptions[R].classList.remove("selected");
      }
    }
    document.body.getBoundingClientRect(), s.getBoundingClientRect(), s.style.top = a.top_original + "px";
  }, t.addEventListener(
    "keydown",
    s.f_textfilter,
    !0
  )) : (l = LiteGraph.warn) == null || l.call(LiteGraph, "NO root document to add context menu and event", t, options)), r.appendChild(this.root);
}, ze = function() {
  var o;
  const t = this.options, r = this.root;
  let s = t.left || 0, a = t.top || 0;
  if (this.top_original = a, t.event) {
    if (s = t.event.clientX - 10, a = t.event.clientY - 10, t.title && (a -= 20), this.top_original = a, t.parentMenu) {
      const l = t.parentMenu.root.getBoundingClientRect();
      s = l.left + l.width;
    }
    const u = document.body.getBoundingClientRect(), h = r.getBoundingClientRect();
    u.height === 0 && ((o = LiteGraph.error) == null || o.call(LiteGraph, "document.body height is 0. That is dangerous, set html,body { height: 100%; }")), u.width && s > u.width - h.width - 10 && (s = u.width - h.width - 10), u.height && a > u.height - h.height - 10 && (a = u.height - h.height - 10);
  }
  r.style.left = `${s}px`, r.style.top = `${a}px`, t.scale && (r.style.transform = `scale(${t.scale})`);
}, /**
 * Closes all open ContextMenus in the specified window.
 * @param {Window} [ref_window=window] - The window object to search for open menus.
 */
g(Te, "closeAll", (t = window) => {
  const r = t.document.querySelectorAll(".litecontextmenu");
  r.length && r.forEach((s) => {
    var a;
    s.close ? s.close() : (a = s.parentNode) == null || a.removeChild(s);
  });
});
let ContextMenu = Te;
var LiteGraph = new class {
  constructor() {
    g(this, "extendClass", (n, t) => {
      for (let r in t)
        n.hasOwnProperty(r) || (n[r] = t[r]);
      if (t.prototype)
        for (let r in t.prototype)
          t.prototype.hasOwnProperty(r) && (n.prototype.hasOwnProperty(r) || (t.prototype.__lookupGetter__(r) ? n.prototype.__defineGetter__(
            r,
            t.prototype.__lookupGetter__(r)
          ) : n.prototype[r] = t.prototype[r], t.prototype.__lookupSetter__(r) && n.prototype.__defineSetter__(
            r,
            t.prototype.__lookupSetter__(r)
          )));
    });
    // used to create nodes from wrapping functions
    g(this, "getParameterNames", (n) => (n + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean));
    g(this, "clamp", (n, t, r) => t > n ? t : r < n ? r : n);
    // @BUG: Re-add these
    g(this, "pointerAddListener", () => {
      var n;
      (n = console.error) == null || n.call(console, "Removed and being re-integrated sorta");
    });
    g(this, "pointerRemoveListener", () => {
      var n;
      (n = console.error) == null || n.call(console, "Removed and being re-integrated sorta");
    });
    g(this, "closeAllContextMenus", () => {
      LiteGraph.warn("LiteGraph.closeAllContextMenus is deprecated in favor of ContextMenu.closeAll()"), ContextMenu.closeAll();
    });
    this.VERSION = "0.10.2", this.LLink = LLink, this.LGraph = LGraph, this.LGraphNode = LGraphNode, this.LGraphGroup = LGraphGroup, this.LGraphCanvas = LGraphCanvas, this.DragAndScale = DragAndScale, this.ContextMenu = ContextMenu, this.CANVAS_GRID_SIZE = 10, this.NODE_TITLE_HEIGHT = 30, this.NODE_TITLE_TEXT_Y = 20, this.NODE_SLOT_HEIGHT = 20, this.NODE_WIDGET_HEIGHT = 20, this.NODE_WIDTH = 140, this.NODE_MIN_WIDTH = 50, this.NODE_COLLAPSED_RADIUS = 10, this.NODE_COLLAPSED_WIDTH = 80, this.NODE_TITLE_COLOR = "#999", this.NODE_SELECTED_TITLE_COLOR = "#FFF", this.NODE_TEXT_SIZE = 14, this.NODE_TEXT_COLOR = "#AAA", this.NODE_SUBTEXT_SIZE = 12, this.NODE_DEFAULT_COLOR = "#333", this.NODE_DEFAULT_BGCOLOR = "#353535", this.NODE_DEFAULT_BOXCOLOR = "#666", this.NODE_DEFAULT_SHAPE = "box", this.NODE_BOX_OUTLINE_COLOR = "#FFF", this.DEFAULT_SHADOW_COLOR = "rgba(0,0,0,0.5)", this.DEFAULT_GROUP_FONT = 24, this.WIDGET_BGCOLOR = "#222", this.WIDGET_OUTLINE_COLOR = "#666", this.WIDGET_TEXT_COLOR = "#DDD", this.WIDGET_SECONDARY_TEXT_COLOR = "#999", this.LINK_COLOR = "#9A9", this.EVENT_LINK_COLOR = "#A86", this.CONNECTING_LINK_COLOR = "#AFA", this.MAX_NUMBER_OF_NODES = 1e3, this.DEFAULT_POSITION = [100, 100], this.VALID_SHAPES = ["default", "box", "round", "card"], this.BOX_SHAPE = 1, this.ROUND_SHAPE = 2, this.CIRCLE_SHAPE = 3, this.CARD_SHAPE = 4, this.ARROW_SHAPE = 5, this.GRID_SHAPE = 6, this.INPUT = 1, this.OUTPUT = 2, this.EVENT = -1, this.ACTION = -1, this.NODE_MODES = ["Always", "On Event", "Never", "On Trigger", "On Request"], this.NODE_MODES_COLORS = ["#666", "#422", "#333", "#224", "#626"], this.ALWAYS = 0, this.ON_EVENT = 1, this.NEVER = 2, this.ON_TRIGGER = 3, this.ON_REQUEST = 4, this.UP = 1, this.DOWN = 2, this.LEFT = 3, this.RIGHT = 4, this.CENTER = 5, this.LINK_RENDER_MODES = ["Straight", "Linear", "Spline"], this.STRAIGHT_LINK = 0, this.LINEAR_LINK = 1, this.SPLINE_LINK = 2, this.NORMAL_TITLE = 0, this.NO_TITLE = 1, this.TRANSPARENT_TITLE = 2, this.AUTOHIDE_TITLE = 3, this.VERTICAL_LAYOUT = "vertical", this.proxy = null, this.node_images_path = "", this.catch_exceptions = !0, this.throw_errors = !0, this.allow_scripts = !1, this.use_deferred_actions = !0, this.registered_node_types = {}, this.node_types_by_file_extension = {}, this.Nodes = {}, this.Globals = {}, this.searchbox_extras = {}, this.auto_sort_node_types = !1, this.node_box_coloured_when_on = !1, this.node_box_coloured_by_mode = !1, this.dialog_close_on_mouse_leave = !0, this.dialog_close_on_mouse_leave_delay = 500, this.shift_click_do_break_link_from = !1, this.click_do_break_link_to = !1, this.search_hide_on_mouse_leave = !0, this.search_filter_enabled = !1, this.search_show_all_on_open = !0, this.show_node_tooltip = !1, this.show_node_tooltip_use_descr_property = !1, this.auto_load_slot_types = !1, this.registered_slot_in_types = {}, this.registered_slot_out_types = {}, this.slot_types_in = [], this.slot_types_out = [], this.slot_types_default_in = [], this.slot_types_default_out = [], this.graphDefaultConfig = {
      align_to_grid: !0,
      links_ontop: !1
    }, this.alt_drag_do_clone_nodes = !1, this.alt_shift_drag_connect_clone_with_input = !0, this.do_add_triggers_slots = !1, this.allow_multi_output_for_events = !0, this.middle_click_slot_add_default_node = !1, this.release_link_on_empty_shows_menu = !1, this.two_fingers_opens_menu = !1, this.backspace_delete = !0, this.ctrl_shift_v_paste_connect_unselected_outputs = !1, this.actionHistory_enabled = !1, this.actionHistoryMaxSave = 40, this.refreshAncestorsOnTriggers = !1, this.refreshAncestorsOnActions = !1, this.ensureUniqueExecutionAndActionCall = !1, this.use_uuids = !1, this.context_menu_filter_enabled = !1, this.showCanvasOptions = !1, this.availableCanvasOptions = [
      "allow_addOutSlot_onExecuted",
      "free_resize",
      "highquality_render",
      "use_gradients",
      // set to true to render titlebar with gradients
      "pause_rendering",
      "clear_background",
      "read_only",
      // if set to true users cannot modify the graph
      // "render_only_selected", // not implemented
      "live_mode",
      "show_info",
      "allow_dragcanvas",
      "allow_dragnodes",
      "allow_interaction",
      // allow to control widgets, buttons, collapse, etc
      "allow_searchbox",
      "move_destination_link_without_shift",
      // rename: old allow_reconnect_links //allows to change a connection, no need to hold shift
      "set_canvas_dirty_on_mouse_event",
      // forces to redraw the canvas if the mouse does anything
      "always_render_background",
      "render_shadows",
      "render_canvas_border",
      "render_connections_shadows",
      // too much cpu
      "render_connections_border",
      // ,"render_curved_connections", // always on, or specific fixed graph
      "render_connection_arrows",
      "render_collapsed_slots",
      "render_execution_order",
      "render_title_colored",
      "render_link_tooltip"
    ], this.actionHistoryMaxSave = 40, this.canRemoveSlots = !0, this.canRemoveSlots_onlyOptional = !0, this.canRenameSlots = !0, this.canRenameSlots_onlyOptional = !0, this.ensureNodeSingleExecution = !1, this.ensureNodeSingleAction = !1, this.preventAncestorRecalculation = !1, this.ensureUniqueExecutionAndActionCall = !0, this.allowMultiOutputForEvents = !1, this.log_methods = ["error", "warn", "info", "log", "debug"], this.logging_set_level(2);
  }
  // get and set debug (log)level
  // from -1 (none), 0 (error), .. to 4 (debug) based on console methods 'error', 'warn', 'info', 'log', 'debug'
  logging_set_level(n) {
    this.debug_level = Number(n);
  }
  // entrypoint to debug log
  logging(n) {
    if (n > this.debug_level)
      return;
    function t(s) {
      let a = [];
      for (let o = 1; o < s.length; o++)
        typeof s[o] != "undefined" && a.push(s[o]);
      return a;
    }
    let r = "debug";
    if (n >= 0 && n <= 4 && (r = ["error", "warn", "info", "log", "debug"][n]), typeof console[r] != "function")
      throw console.warn("[LG-log] invalid console method", r, t(arguments)), new RangeError();
    console[r]("[LG]", ...t(arguments));
  }
  error() {
    this.logging(0, ...arguments);
  }
  warn() {
    this.logging(1, ...arguments);
  }
  info() {
    this.logging(2, ...arguments);
  }
  log() {
    this.logging(3, ...arguments);
  }
  debug() {
    this.logging(4, ...arguments);
  }
  /**
   * Register a node class so it can be listed when the user wants to create a new one
   * @method registerNodeType
   * @param {String} type name of the node and path
   * @param {Class} base_class class containing the structure of a node
   */
  registerNodeType(n, t) {
    var l, c, d, f, _, E, m;
    if (!t.prototype)
      throw new Error("Cannot register a simple object, it must be a class with a prototype");
    t.type = n, (l = this.debug) == null || l.call(this, "registerNodeType", "start", n);
    const r = t.name, s = n.lastIndexOf("/");
    t.category = n.substring(0, s), t.title || (t.title = r);
    const a = Object.getOwnPropertyDescriptors(LGraphNode.prototype);
    Object.keys(a).forEach((T) => {
      t.prototype.hasOwnProperty(T) || Object.defineProperty(t.prototype, T, a[T]);
    });
    const o = this.registered_node_types[n];
    if (o && ((c = this.debug) == null || c.call(this, "registerNodeType", "replacing node type", n, o)), !Object.prototype.hasOwnProperty.call(t.prototype, "shape") && (Object.defineProperty(t.prototype, "shape", {
      set: function(T) {
        switch (T) {
          case "default":
            delete this._shape;
            break;
          case "box":
            this._shape = LiteGraph.BOX_SHAPE;
            break;
          case "round":
            this._shape = LiteGraph.ROUND_SHAPE;
            break;
          case "circle":
            this._shape = LiteGraph.CIRCLE_SHAPE;
            break;
          case "card":
            this._shape = LiteGraph.CARD_SHAPE;
            break;
          default:
            this._shape = T;
        }
      },
      get: function() {
        return this._shape;
      },
      enumerable: !0,
      configurable: !0
    }), t.supported_extensions))
      for (let T in t.supported_extensions) {
        const L = t.supported_extensions[T];
        L && L.constructor === String && (this.node_types_by_file_extension[L.toLowerCase()] = t);
      }
    if (this.registered_node_types[n] = t, t.constructor.name && (this.Nodes[r] = t), (d = LiteGraph.onNodeTypeRegistered) == null || d.call(LiteGraph, n, t), o && ((f = LiteGraph.onNodeTypeReplaced) == null || f.call(LiteGraph, n, t, o)), t.prototype.onPropertyChange && LiteGraph.warn("LiteGraph node class " + n + " has onPropertyChange method, it must be called onPropertyChanged with d at the end"), t.supported_extensions)
      for (var u = 0; u < t.supported_extensions.length; u++) {
        var h = t.supported_extensions[u];
        h && h.constructor === String && (this.node_types_by_file_extension[h.toLowerCase()] = t);
      }
    (_ = this.debug) == null || _.call(this, "registerNodeType", "type registered", n), this.auto_load_slot_types && ((E = this.debug) == null || E.call(this, "registerNodeType", "do auto_load_slot_types", n)), new t((m = t.title) != null ? m : "tmpnode");
  }
  /**
   * removes a node type from the system
   * @method unregisterNodeType
   * @param {String|Object} type name of the node or the node constructor itself
   */
  unregisterNodeType(n) {
    const t = n.constructor === String ? this.registered_node_types[n] : n;
    if (!t)
      throw new Error("node type not found: " + n);
    delete this.registered_node_types[t.type], t.constructor.name && delete this.Nodes[t.constructor.name];
  }
  /**
  * Save a slot type and his node
  * @method registerSlotType
  * @param {String|Object} type name of the node or the node constructor itself
  * @param {String} slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..
  */
  registerNodeAndSlotType(n, t, r = !1) {
    const a = (n.constructor === String && this.registered_node_types[n] !== "anonymous" ? this.registered_node_types[n] : n).constructor.type;
    let o = [];
    typeof t == "string" ? o = t.split(",") : t == this.EVENT || t == this.ACTION ? o = ["_event_"] : o = ["*"];
    for (let u = 0; u < o.length; ++u) {
      let h = o[u];
      h === "" && (h = "*");
      const l = r ? "registered_slot_out_types" : "registered_slot_in_types";
      this[l][h] === void 0 && (this[l][h] = { nodes: [] }), this[l][h].nodes.includes(a) || this[l][h].nodes.push(a), r ? this.slot_types_out.includes(h.toLowerCase()) || (this.slot_types_out.push(h.toLowerCase()), this.slot_types_out.sort()) : this.slot_types_in.includes(h.toLowerCase()) || (this.slot_types_in.push(h.toLowerCase()), this.slot_types_in.sort());
    }
  }
  /**
   * Create a new nodetype by passing an object with some properties
   * like onCreate, inputs:Array, outputs:Array, properties, onExecute
   * @method buildNodeClassFromObject
   * @param {String} name node name with namespace (p.e.: 'math/sum')
   * @param {Object} object methods expected onCreate, inputs, outputs, properties, onExecute
   */
  buildNodeClassFromObject(n, t) {
    var r = "";
    if (t.inputs)
      for (let a = 0; a < t.inputs.length; ++a) {
        let o = t.inputs[a][0], u = t.inputs[a][1];
        u && u.constructor === String && (u = '"' + u + '"'), r += "this.addInput('" + o + "'," + u + `);
`;
      }
    if (t.outputs)
      for (let a = 0; a < t.outputs.length; ++a) {
        let o = t.outputs[a][0], u = t.outputs[a][1];
        u && u.constructor === String && (u = '"' + u + '"'), r += "this.addOutput('" + o + "'," + u + `);
`;
      }
    if (t.properties)
      for (let a in t.properties) {
        let o = t.properties[a];
        o && o.constructor === String && (o = '"' + o + '"'), r += "this.addProperty('" + a + "'," + o + `);
`;
      }
    r += "if(this.onCreate)this.onCreate()";
    var s = Function(r);
    for (let a in t)
      a != "inputs" && a != "outputs" && a != "properties" && (s.prototype[a] = t[a]);
    return s.title = t.title || n.split("/").pop(), s.desc = t.desc || "Generated from object", this.registerNodeType(n, s), s;
  }
  /**
   * Create a new nodetype by passing a function, it wraps it with a proper class and generates inputs according to the parameters of the function.
   * Useful to wrap simple methods that do not require properties, and that only process some input to generate an output.
   * @method wrapFunctionAsNode
   * @param {String} name node name with namespace (p.e.: 'math/sum')
   * @param {Function} func
   * @param {Array} param_types [optional] an array containing the type of every parameter, otherwise parameters will accept any type
   * @param {String} return_type [optional] string with the return type, otherwise it will be generic
   * @param {Object} properties [optional] properties to be configurable
   */
  wrapFunctionAsNode(n, t, r, s, a) {
    const o = LiteGraph.getParameterNames(t), u = o.map((d, f) => {
      const _ = r != null && r[f] ? `'${r[f]}'` : "0";
      return `this.addInput('${d}', ${_});`;
    }).join(`
`), h = s ? `'${s}'` : 0, l = a ? `this.properties = ${JSON.stringify(a)};` : "", c = new Function(`
            ${u}
            this.addOutput('out', ${h});
            ${l}
        `);
    return c.title = n.split("/").pop(), c.desc = `Generated from ${t.name}`, c.prototype.onExecute = function() {
      const d = o.map((_, E) => this.getInputData(E)), f = t.apply(this, d);
      this.setOutputData(0, f);
    }, this.registerNodeType(n, c), c;
  }
  /**
   * Removes all previously registered node's types
   */
  clearRegisteredTypes() {
    this.registered_node_types = {}, this.node_types_by_file_extension = {}, this.Nodes = {}, this.searchbox_extras = {};
  }
  /**
   * Adds this method to all nodetypes, existing and to be created
   * (You can add it to LGraphNode.prototype but then existing node types wont have it)
   * @method addNodeMethod
   * @param {Function} func
   */
  addNodeMethod(n, t) {
    LGraphNode.prototype[n] = t;
    for (var r in this.registered_node_types) {
      var s = this.registered_node_types[r];
      s.prototype[n] && (s.prototype["_" + n] = s.prototype[n]), s.prototype[n] = t;
    }
  }
  /**
   * Create a node of a given type with a name. The node is not attached to any graph yet.
   * @method createNode
   * @param {String} type full name of the node class. p.e. "math/sin"
   * @param {String} name a name to distinguish from other nodes
   * @param {Object} options to set options
   */
  createNode(n, t, r = {}) {
    var o, u, h, l, c, d, f, _, E, m, T, L;
    const s = (o = this.registered_node_types[n]) != null ? o : null;
    if (!s)
      return (u = this.log) == null || u.call(this, `GraphNode type "${n}" not registered.`), null;
    t = (h = t != null ? t : s.title) != null ? h : n;
    let a = null;
    if (LiteGraph.catch_exceptions)
      try {
        a = new s(t);
      } catch (G) {
        return (l = this.error) == null || l.call(this, G), null;
      }
    else
      a = new s(t);
    return a.type = n, (c = a.title) != null || (a.title = t), (d = a.properties) != null || (a.properties = {}), (f = a.properties_info) != null || (a.properties_info = []), (_ = a.flags) != null || (a.flags = {}), (E = a.size) != null || (a.size = a.computeSize()), (m = a.pos) != null || (a.pos = LiteGraph.DEFAULT_POSITION.concat()), (T = a.mode) != null || (a.mode = LiteGraph.ALWAYS), Object.assign(a, r), (L = a.onNodeCreated) == null || L.call(a), a;
  }
  /**
   * Returns a registered node type with a given name
   * @method getNodeType
   * @param {String} type full name of the node class. p.e. "math/sin"
   * @return {Class} the node class
   */
  getNodeType(n) {
    return this.registered_node_types[n];
  }
  /**
   * Returns a list of node types matching one category
   * @method getNodeType
   * @param {String} category category name
   * @return {Array} array with all the node classes
   */
  getNodeTypesInCategory(n, t) {
    const r = Object.values(this.registered_node_types).filter((s) => s.filter !== t ? !1 : n === "" ? s.category === null : s.category === n);
    return this.auto_sort_node_types && r.sort((s, a) => s.title.localeCompare(a.title)), r;
  }
  /**
   * Returns a list with all the node type categories
   * @method getNodeTypesCategories
   * @param {String} filter only nodes with ctor.filter equal can be shown
   * @return {Array} array with all the names of the categories
   */
  getNodeTypesCategories(n) {
    const t = { "": 1 };
    Object.values(this.registered_node_types).forEach((s) => {
      s.category && !s.skip_list && s.filter === n && (t[s.category] = 1);
    });
    const r = Object.keys(t);
    return this.auto_sort_node_types ? r.sort() : r;
  }
  // debug purposes: reloads all the js scripts that matches a wildcard
  reloadNodes(n) {
    var u, h, l;
    var t = document.getElementsByTagName("script"), r = [];
    for (let c = 0; c < t.length; c++)
      r.push(t[c]);
    var s = document.getElementsByTagName("head")[0];
    n = document.location.href + n;
    for (let c = 0; c < r.length; c++) {
      var a = r[c].src;
      if (!(!a || a.substr(0, n.length) != n))
        try {
          (u = this.log) == null || u.call(this, "Reloading: " + a);
          var o = document.createElement("script");
          o.type = "text/javascript", o.src = a, s.appendChild(o), s.removeChild(r[c]);
        } catch (d) {
          if (LiteGraph.throw_errors)
            throw d;
          (h = this.log) == null || h.call(this, "Error while reloading " + a);
        }
    }
    (l = this.log) == null || l.call(this, "Nodes reloaded");
  }
  // separated just to improve if it doesn't work
  cloneObject(n, t) {
    if (n == null)
      return null;
    const r = JSON.parse(JSON.stringify(n));
    if (!t)
      return r;
    for (const s in r)
      Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    return t;
  }
  /*
      * https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670
      */
  uuidv4() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (n) => (n ^ Math.random() * 16 >> n / 4).toString(16));
  }
  /**
   * Returns if the types of two slots are compatible (taking into account wildcards, etc)
   * @method isValidConnection
   * @param {String} type_a
   * @param {String} type_b
   * @return {Boolean} true if they can be connected
   */
  isValidConnection(n, t) {
    if ((n === "" || n === "*") && (n = 0), (t === "" || t === "*") && (t = 0), !n || !t || n === t || n === LiteGraph.EVENT && t === LiteGraph.ACTION)
      return !0;
    if (n = String(n).toLowerCase(), t = String(t).toLowerCase(), !n.includes(",") && !t.includes(","))
      return n === t;
    const r = n.split(","), s = t.split(",");
    for (const a of r)
      for (const o of s)
        if (this.isValidConnection(a, o))
          return !0;
    return !1;
  }
  /**
   * Register a string in the search box so when the user types it it will recommend this node
   * @method registerSearchboxExtra
   * @param {String} node_type the node recommended
   * @param {String} description text to show next to it
   * @param {Object} data it could contain info of how the node should be configured
   * @return {Boolean} true if they can be connected
   */
  registerSearchboxExtra(n, t, r) {
    this.searchbox_extras[t.toLowerCase()] = {
      type: n,
      desc: t,
      data: r
    };
  }
  /**
   * Wrapper to load files (from url using fetch or from file using FileReader)
   * @method fetchFile
   * @param {String|File|Blob} url the url of the file (or the file itself)
   * @param {String} type an string to know how to fetch it: "text","arraybuffer","json","blob"
   * @param {Function} on_complete callback(data)
   * @param {Function} on_error in case of an error
   * @return {FileReader|Promise} returns the object used to
   */
  fetchFile(n, t, r, s) {
    if (!n)
      return null;
    if (t = t || "text", n.constructor === String)
      return n.substr(0, 4) == "http" && LiteGraph.proxy && (n = LiteGraph.proxy + n.substr(n.indexOf(":") + 3)), fetch(n).then((o) => {
        if (!o.ok)
          throw new Error("File not found");
        if (t == "arraybuffer")
          return o.arrayBuffer();
        if (t == "text" || t == "string")
          return o.text();
        if (t == "json")
          return o.json();
        if (t == "blob")
          return o.blob();
      }).then((o) => {
        r && r(o);
      }).catch((o) => {
        var u;
        (u = this.error) == null || u.call(this, "error fetching file:", n), s && s(o);
      });
    if (n.constructor === File || n.constructor === Blob) {
      var a = new FileReader();
      if (a.onload = (o) => {
        var u = o.target.result;
        t == "json" && (u = JSON.parse(u)), r && r(u);
      }, t == "arraybuffer")
        return a.readAsArrayBuffer(n);
      if (t == "text" || t == "json")
        return a.readAsText(n);
      if (t == "blob")
        return a.readAsBinaryString(n);
    }
    return null;
  }
  // @TODO These weren't even directly bound, so could be used as free functions
  compareObjects(n, t) {
    const r = Object.keys(n);
    return r.length !== Object.keys(t).length ? !1 : r.every((s) => n[s] === t[s]);
  }
  distance(n, t) {
    const [r, s] = n, [a, o] = t;
    return Math.sqrt((a - r) ** 2 + (o - s) ** 2);
  }
  colorToString(n) {
    return "rgba(" + Math.round(n[0] * 255).toFixed() + "," + Math.round(n[1] * 255).toFixed() + "," + Math.round(n[2] * 255).toFixed() + "," + (n.length == 4 ? n[3].toFixed(2) : "1.0") + ")";
  }
  canvasFillTextMultiline(n, t, r, s, a, o) {
    var u = (t + "").trim().split(" "), h = "", l = { lines: [], maxW: 0, height: 0 };
    if (u.length > 1)
      for (var c = 0; c < u.length; c++) {
        var d = h + u[c] + " ", f = n.measureText(d), _ = f.width;
        _ > a && c > 0 ? (n.fillText(h, r, s + o * l.lines.length), h = u[c] + " ", l.max = _, l.lines.push(h)) : h = d;
      }
    else
      h = u[0];
    return n.fillText(h, r, s + o * l.lines.length), l.lines.push(h), l.height = o * l.lines.length || o, l;
  }
  isInsideRectangle(n, t, r, s, a, o) {
    return n > r && n < r + a && t > s && t < s + o;
  }
  // [minx,miny,maxx,maxy]
  growBounding(n, t, r) {
    t < n[0] ? n[0] = t : t > n[2] && (n[2] = t), r < n[1] ? n[1] = r : r > n[3] && (n[3] = r);
  }
  // point inside bounding box
  isInsideBounding(n, t) {
    return n[0] >= t[0][0] && n[1] >= t[0][1] && n[0] <= t[1][0] && n[1] <= t[1][1];
  }
  // bounding overlap, format: [ startx, starty, width, height ]
  overlapBounding(n, t) {
    const r = n[0] + n[2], s = n[1] + n[3], a = t[0] + t[2], o = t[1] + t[3];
    return !(n[0] > a || n[1] > o || r < t[0] || s < t[1]);
  }
  // Convert a hex value to its decimal value - the inputted hex must be in the
  //	format of a hex triplet - the kind we use for HTML colours. The function
  //	will return an array with three values.
  hex2num(n) {
    n.charAt(0) == "#" && (n = n.slice(1)), n = n.toUpperCase();
    for (var t = "0123456789ABCDEF", r = new Array(3), s = 0, a, o, u = 0; u < 6; u += 2)
      a = t.indexOf(n.charAt(u)), o = t.indexOf(n.charAt(u + 1)), r[s] = a * 16 + o, s++;
    return r;
  }
  // Give a array with three values as the argument and the function will return
  //	the corresponding hex triplet.
  num2hex(n) {
    for (var t = "0123456789ABCDEF", r = "#", s, a, o = 0; o < 3; o++)
      s = n[o] / 16, a = n[o] % 16, r += t.charAt(s) + t.charAt(a);
    return r;
  }
  set pointerevents_method(n) {
    var t;
    (t = console.error) == null || t.call(console, "Removed and being re-integrated sorta");
  }
  get pointerevents_method() {
    var n;
    (n = console.error) == null || n.call(console, "Removed and being re-integrated sorta");
  }
}();
typeof performance != "undefined" ? LiteGraph.getTime = performance.now.bind(performance) : typeof Date != "undefined" && Date.now ? LiteGraph.getTime = Date.now.bind(Date) : typeof process != "undefined" ? LiteGraph.getTime = () => {
  var n = process.hrtime();
  return n[0] * 1e-3 + n[1] * 1e-6;
} : LiteGraph.getTime = function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
typeof window != "undefined" && !window.requestAnimationFrame && (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || ((n) => {
  window.setTimeout(n, 1e3 / 60);
}));
class Time {
  constructor() {
    this.addOutput("in ms", "number"), this.addOutput("in sec", "number");
  }
  onExecute() {
    this.setOutputData(0, this.graph.globaltime * 1e3), this.setOutputData(1, this.graph.globaltime);
  }
}
g(Time, "title", "Time"), g(Time, "desc", "Time");
LiteGraph.registerNodeType("basic/time", Time);
class Subgraph {
  constructor() {
    this.size = [140, 80], this.properties = { enabled: !0 }, this.enabled = !0, this.subgraph = new LiteGraph.LGraph(), this.subgraph._subgraph_node = this, this.subgraph._is_subgraph = !0, this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this), this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this), this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this), this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this), this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this), this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this), this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this), this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this), this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
  }
  onGetInputs() {
    return [["enabled", "boolean"]];
  }
  /*
      Subgraph.prototype.onDrawTitle = function(ctx) {
          if (this.flags.collapsed) {
              return;
          }
  
          ctx.fillStyle = "#555";
          var w = LiteGraph.NODE_TITLE_HEIGHT;
          var x = this.size[0] - w;
          ctx.fillRect(x, -w, w, w);
          ctx.fillStyle = "#333";
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, -w * 0.6);
          ctx.lineTo(x + w * 0.8, -w * 0.6);
          ctx.lineTo(x + w * 0.5, -w * 0.3);
          ctx.fill();
      };
      */
  onDblClick(t, r, s) {
    var a = this;
    setTimeout(function() {
      s.openSubgraph(a.subgraph);
    }, 10);
  }
  /*
  Subgraph.prototype.onMouseDown = function(e, pos, graphcanvas) {
      if (
          !this.flags.collapsed &&
          pos[0] > this.size[0] - LiteGraph.NODE_TITLE_HEIGHT &&
          pos[1] < 0
      ) {
          var that = this;
          setTimeout(function() {
              graphcanvas.openSubgraph(that.subgraph);
          }, 10);
      }
  };
  */
  onAction(t, r) {
    this.subgraph.onAction(t, r);
  }
  onExecute() {
    if (this.enabled = this.getInputOrProperty("enabled"), !!this.enabled) {
      if (this.inputs)
        for (let t = 0; t < this.inputs.length; t++) {
          let r = this.inputs[t], s = this.getInputData(t);
          this.subgraph.setInputData(r.name, s);
        }
      if (this.subgraph.runStep(), this.outputs)
        for (let t = 0; t < this.outputs.length; t++) {
          let r = this.outputs[t], s = this.subgraph.getOutputData(r.name);
          this.setOutputData(t, s);
        }
    }
  }
  sendEventToAllNodes(t, r, s) {
    this.enabled && this.subgraph.sendEventToAllNodes(t, r, s);
  }
  onDrawBackground(t, r, s, a) {
    if (this.flags.collapsed) return;
    var o = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5, u = LiteGraph.isInsideRectangle(
      a[0],
      a[1],
      this.pos[0],
      this.pos[1] + o,
      this.size[0],
      LiteGraph.NODE_TITLE_HEIGHT
    );
    let h = LiteGraph.isInsideRectangle(
      a[0],
      a[1],
      this.pos[0],
      this.pos[1] + o,
      this.size[0] / 2,
      LiteGraph.NODE_TITLE_HEIGHT
    );
    t.fillStyle = u ? "#555" : "#222", t.beginPath(), this._shape == LiteGraph.BOX_SHAPE ? h ? t.rect(0, o, this.size[0] / 2 + 1, LiteGraph.NODE_TITLE_HEIGHT) : t.rect(
      this.size[0] / 2,
      o,
      this.size[0] / 2 + 1,
      LiteGraph.NODE_TITLE_HEIGHT
    ) : h ? t.roundRect(
      0,
      o,
      this.size[0] / 2 + 1,
      LiteGraph.NODE_TITLE_HEIGHT,
      [0, 0, 8, 8]
    ) : t.roundRect(
      this.size[0] / 2,
      o,
      this.size[0] / 2 + 1,
      LiteGraph.NODE_TITLE_HEIGHT,
      [0, 0, 8, 8]
    ), u ? t.fill() : t.fillRect(0, o, this.size[0] + 1, LiteGraph.NODE_TITLE_HEIGHT), t.textAlign = "center", t.font = "24px Arial", t.fillStyle = u ? "#DDD" : "#999", t.fillText("+", this.size[0] * 0.25, o + 24), t.fillText("+", this.size[0] * 0.75, o + 24);
  }
  // Subgraph.prototype.onMouseDown = function(e, localpos, graphcanvas)
  // {
  // 	var y = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
  // 	if(localpos[1] > y)
  // 	{
  // 		graphcanvas.showSubgraphPropertiesDialog(this);
  // 	}
  // }
  onMouseDown(t, r, s) {
    var o, u, h;
    var a = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
    (o = console.log) == null || o.call(console, 0), r[1] > a && (r[0] < this.size[0] / 2 ? ((u = console.log) == null || u.call(console, 1), s.showSubgraphPropertiesDialog(this)) : ((h = console.log) == null || h.call(console, 2), s.showSubgraphPropertiesDialogRight(this)));
  }
  computeSize() {
    var t = this.inputs ? this.inputs.length : 0, r = this.outputs ? this.outputs.length : 0;
    return [
      200,
      Math.max(t, r) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT
    ];
  }
  //* *** INPUTS ***********************************
  onSubgraphTrigger(t) {
    var r = this.findOutputSlot(t);
    r != -1 && this.triggerSlot(r);
  }
  onSubgraphNewInput(t, r) {
    var s = this.findInputSlot(t);
    s == -1 && this.addInput(t, r);
  }
  onSubgraphRenamedInput(t, r) {
    var s = this.findInputSlot(t);
    if (s != -1) {
      var a = this.getInputInfo(s);
      a.name = r;
    }
  }
  onSubgraphTypeChangeInput(t, r) {
    var s = this.findInputSlot(t);
    if (s != -1) {
      var a = this.getInputInfo(s);
      a.type = r;
    }
  }
  onSubgraphRemovedInput(t) {
    var r = this.findInputSlot(t);
    r != -1 && this.removeInput(r);
  }
  //* *** OUTPUTS ***********************************
  onSubgraphNewOutput(t, r) {
    var s = this.findOutputSlot(t);
    s == -1 && this.addOutput(t, r);
  }
  onSubgraphRenamedOutput(t, r) {
    var s = this.findOutputSlot(t);
    if (s != -1) {
      var a = this.getOutputInfo(s);
      a.name = r;
    }
  }
  onSubgraphTypeChangeOutput(t, r) {
    var s = this.findOutputSlot(t);
    if (s != -1) {
      var a = this.getOutputInfo(s);
      a.type = r;
    }
  }
  onSubgraphRemovedOutput(t) {
    var r = this.findOutputSlot(t);
    r != -1 && this.removeOutput(r);
  }
  getExtraMenuOptions(t) {
    var r = this;
    return [
      {
        content: "Open",
        callback: function() {
          t.openSubgraph(r.subgraph);
        }
      }
    ];
  }
  onResize(t) {
    t[1] += 20;
  }
  serialize() {
    var t = LiteGraph.LGraphNode.prototype.serialize.call(this);
    return t.subgraph = this.subgraph.serialize(), t;
  }
  // no need to define node.configure, the default method detects node.subgraph and passes the object to node.subgraph.configure()
  reassignSubgraphUUIDs(t) {
    const r = { nodeIDs: {}, linkIDs: {} };
    for (const s of t.nodes) {
      const a = s.id, o = LiteGraph.uuidv4();
      if (s.id = o, r.nodeIDs[a] || r.nodeIDs[o])
        throw new Error(`New/old node UUID wasn't unique in changed map! ${a} ${o}`);
      r.nodeIDs[a] = o, r.nodeIDs[o] = a;
    }
    for (const s of t.links) {
      const a = s[0], o = LiteGraph.uuidv4();
      if (s[0] = o, r.linkIDs[a] || r.linkIDs[o])
        throw new Error(`New/old link UUID wasn't unique in changed map! ${a} ${o}`);
      r.linkIDs[a] = o, r.linkIDs[o] = a;
      const u = s[1], h = s[3];
      if (!r.nodeIDs[u])
        throw new Error(`Old node UUID not found in mapping! ${u}`);
      if (s[1] = r.nodeIDs[u], !r.nodeIDs[h])
        throw new Error(`Old node UUID not found in mapping! ${h}`);
      s[3] = r.nodeIDs[h];
    }
    for (const s of t.nodes) {
      if (s.inputs)
        for (const a of s.inputs)
          a.link && (a.link = r.linkIDs[a.link]);
      if (s.outputs)
        for (const a of s.outputs)
          a.links && (a.links = a.links.map((o) => r.linkIDs[o]));
    }
    for (const s of t.nodes)
      if (s.type === "graph/subgraph") {
        const a = reassignGraphUUIDs(s.subgraph);
        r.nodeIDs.assign(a.nodeIDs), r.linkIDs.assign(a.linkIDs);
      }
  }
  clone() {
    var t = LiteGraph.createNode(this.type), r = this.serialize();
    if (LiteGraph.use_uuids) {
      const s = LiteGraph.cloneObject(r.subgraph);
      this.reassignSubgraphUUIDs(s), r.subgraph = s;
    }
    return delete r.id, delete r.inputs, delete r.outputs, t.configure(r), t;
  }
  buildFromNodes(t) {
    var r = {};
    for (let s = 0; s < t.length; ++s)
      r[node.id] = t[s];
    for (let s = 0; s < t.length; ++s) {
      let a = t[s];
      if (a.inputs)
        for (let o = 0; o < a.inputs.length; ++o) {
          let u = a.inputs[o];
          if (!u || !u.link) continue;
          let h = a.graph.links[u.link];
          h && (r[h.origin_id] || this.subgraph.addInput(u.name, h.type));
        }
      if (a.outputs)
        for (let o = 0; o < a.outputs.length; ++o) {
          let u = a.outputs[o];
          if (!(!u || !u.links || !u.links.length))
            for (let h = 0; h < u.links.length; ++h) {
              let l = a.graph.links[u.links[h]];
              if (l && !r[l.target_id])
                break;
            }
        }
    }
  }
}
g(Subgraph, "title", "Subgraph"), g(Subgraph, "desc", "Graph inside a node"), g(Subgraph, "title_color", "#334");
LiteGraph.Subgraph = Subgraph;
LiteGraph.registerNodeType("graph/subgraph", Subgraph);
class GraphInput {
  constructor() {
    this.addOutput("", "number"), this.name_in_graph = "", this.properties = {
      name: "",
      type: "number",
      value: 0
    };
    var t = this;
    this.name_widget = this.addWidget(
      "text",
      "Name",
      this.properties.name,
      function(r) {
        r && t.setProperty("name", r);
      }
    ), this.type_widget = this.addWidget(
      "text",
      "Type",
      this.properties.type,
      function(r) {
        t.setProperty("type", r);
      }
    ), this.value_widget = this.addWidget(
      "number",
      "Value",
      this.properties.value,
      function(r) {
        t.setProperty("value", r);
      }
    ), this.widgets_up = !0, this.size = [180, 90];
  }
  onConfigure() {
    this.updateType();
  }
  // ensures the type in the node output and the type in the associated graph input are the same
  updateType() {
    var t = this.properties.type;
    this.type_widget.value = t, this.outputs[0].type != t && (LiteGraph.isValidConnection(this.outputs[0].type, t) || this.disconnectOutput(0), this.outputs[0].type = t), t == "number" ? (this.value_widget.type = "number", this.value_widget.value = 0) : t == "boolean" ? (this.value_widget.type = "toggle", this.value_widget.value = !0) : t == "string" ? (this.value_widget.type = "text", this.value_widget.value = "") : (this.value_widget.type = null, this.value_widget.value = null), this.properties.value = this.value_widget.value, this.graph && this.name_in_graph && this.graph.changeInputType(this.name_in_graph, t);
  }
  // this is executed AFTER the property has changed
  onPropertyChanged(t, r) {
    if (t == "name") {
      if (r == "" || r == this.name_in_graph || r == "enabled")
        return !1;
      this.graph && (this.name_in_graph ? this.graph.renameInput(this.name_in_graph, r) : this.graph.addInput(r, this.properties.type)), this.name_widget.value = r, this.name_in_graph = r;
    } else t == "type" && this.updateType();
  }
  getTitle() {
    return this.flags.collapsed ? this.properties.name : this.title;
  }
  onAction(t, r) {
    this.properties.type == LiteGraph.EVENT && this.triggerSlot(0, r);
  }
  onExecute() {
    var t = this.properties.name, r = this.graph.inputs[t];
    if (!r) {
      this.setOutputData(0, this.properties.value);
      return;
    }
    this.setOutputData(
      0,
      r.value !== void 0 ? r.value : this.properties.value
    );
  }
  onRemoved() {
    this.name_in_graph && this.graph.removeInput(this.name_in_graph);
  }
}
g(GraphInput, "title", "Input"), g(GraphInput, "desc", "Input of the graph");
LiteGraph.GraphInput = GraphInput;
LiteGraph.registerNodeType("graph/input", GraphInput);
class GraphOutput {
  constructor() {
    this.addInput("", ""), this.name_in_graph = "", this.properties = { name: "", type: "" }, this.name_widget = this.addWidget(
      "text",
      "Name",
      this.properties.name,
      "name"
    ), this.type_widget = this.addWidget(
      "text",
      "Type",
      this.properties.type,
      "type"
    ), this.widgets_up = !0, this.size = [180, 60];
  }
  onPropertyChanged(t, r) {
    if (t == "name") {
      if (r == "" || r == this.name_in_graph || r == "enabled")
        return !1;
      this.graph && (this.name_in_graph ? this.graph.renameOutput(this.name_in_graph, r) : this.graph.addOutput(r, this.properties.type)), this.name_widget.value = r, this.name_in_graph = r;
    } else t == "type" && this.updateType();
  }
  updateType() {
    var t = this.properties.type;
    this.type_widget && (this.type_widget.value = t), this.inputs[0].type != t && ((t == "action" || t == "event") && (t = LiteGraph.EVENT), LiteGraph.isValidConnection(this.inputs[0].type, t) || this.disconnectInput(0), this.inputs[0].type = t), this.graph && this.name_in_graph && this.graph.changeOutputType(this.name_in_graph, t);
  }
  onExecute() {
    this._value = this.getInputData(0), this.graph.setOutputData(this.properties.name, this._value);
  }
  onAction(t, r) {
    this.properties.type == LiteGraph.ACTION && this.graph.trigger(this.properties.name, r);
  }
  onRemoved() {
    this.name_in_graph && this.graph.removeOutput(this.name_in_graph);
  }
  getTitle() {
    return this.flags.collapsed ? this.properties.name : this.title;
  }
}
g(GraphOutput, "title", "Output"), g(GraphOutput, "desc", "Output of the graph");
LiteGraph.GraphOutput = GraphOutput;
LiteGraph.registerNodeType("graph/output", GraphOutput);
class ConstantNumber {
  constructor() {
    this.addOutput("value", "number"), this.addProperty("value", 1), this.widget = this.addWidget("number", "value", 1, "value"), this.widgets_up = !0, this.size = [180, 30];
  }
  onExecute() {
    this.setOutputData(0, parseFloat(this.properties.value));
  }
  getTitle() {
    return this.flags.collapsed ? this.properties.value : this.title;
  }
  setValue(t) {
    this.setProperty("value", t);
  }
  onDrawBackground() {
    this.outputs[0].label = this.properties.value.toFixed(3);
  }
}
g(ConstantNumber, "title", "Const Number"), g(ConstantNumber, "desc", "Constant number");
LiteGraph.registerNodeType("basic/const", ConstantNumber);
class ConstantBoolean {
  constructor() {
    this.addOutput("bool", "boolean"), this.addProperty("value", !0), this.widget = this.addWidget("toggle", "value", !0, "value"), this.serialize_widgets = !0, this.widgets_up = !0, this.size = [140, 30];
  }
  onExecute() {
    this.setOutputData(0, this.properties.value);
  }
  onGetInputs() {
    return [["toggle", LiteGraph.ACTION]];
  }
  onAction() {
    this.setValue(!this.properties.value);
  }
}
g(ConstantBoolean, "title", "Const Boolean"), g(ConstantBoolean, "desc", "Constant boolean");
ConstantBoolean.prototype.getTitle = ConstantNumber.prototype.getTitle;
ConstantBoolean.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/boolean", ConstantBoolean);
class ConstantString {
  constructor() {
    this.addOutput("string", "string"), this.addProperty("value", ""), this.widget = this.addWidget("text", "value", "", "value"), this.widgets_up = !0, this.size = [180, 30];
  }
  onExecute() {
    this.setOutputData(0, this.properties.value);
  }
  onDropFile(t) {
    var r = this, s = new FileReader();
    s.onload = function(a) {
      r.setProperty("value", a.target.result);
    }, s.readAsText(t);
  }
}
g(ConstantString, "title", "Const String"), g(ConstantString, "desc", "Constant string");
ConstantString.prototype.getTitle = ConstantNumber.prototype.getTitle;
ConstantString.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/string", ConstantString);
class ConstantObject {
  constructor() {
    this.addOutput("obj", "object"), this.size = [120, 30], this._object = {};
  }
  onExecute() {
    this.setOutputData(0, this._object);
  }
}
g(ConstantObject, "title", "Const Object"), g(ConstantObject, "desc", "Constant Object");
LiteGraph.registerNodeType("basic/object", ConstantObject);
class ConstantFile {
  constructor() {
    this.addInput("url", "string"), this.addOutput("file", "string"), this.addProperty("url", ""), this.addProperty("type", "text"), this.widget = this.addWidget("text", "url", "", "url"), this._data = null;
  }
  onPropertyChanged(t, r) {
    t == "url" && (r == null || r == "" ? this._data = null : this.fetchFile(r));
  }
  onExecute() {
    var t = this.getInputData(0) || this.properties.url;
    t && (t != this._url || this._type != this.properties.type) && this.fetchFile(t), this.setOutputData(0, this._data);
  }
  fetchFile(t) {
    var r = this;
    if (!t || t.constructor !== String) {
      r._data = null, r.boxcolor = null;
      return;
    }
    this._url = t, this._type = this.properties.type, t.substr(0, 4) == "http" && LiteGraph.proxy && (t = LiteGraph.proxy + t.substr(t.indexOf(":") + 3)), fetch(t).then(function(s) {
      if (!s.ok) throw new Error("File not found");
      if (r.properties.type == "arraybuffer")
        return s.arrayBuffer();
      if (r.properties.type == "text") return s.text();
      if (r.properties.type == "json") return s.json();
      if (r.properties.type == "blob") return s.blob();
    }).then(function(s) {
      r._data = s, r.boxcolor = "#AEA";
    }).catch((s) => {
      var a;
      r._data = null, r.boxcolor = "red", (a = console.error) == null || a.call(console, "error fetching file:", t);
    });
  }
  onDropFile(t) {
    var r = this;
    this._url = t.name, this._type = this.properties.type, this.properties.url = t.name;
    var s = new FileReader();
    if (s.onload = function(a) {
      r.boxcolor = "#AEA";
      var o = a.target.result;
      r.properties.type == "json" && (o = JSON.parse(o)), r._data = o;
    }, r.properties.type == "arraybuffer") s.readAsArrayBuffer(t);
    else if (r.properties.type == "text" || r.properties.type == "json")
      s.readAsText(t);
    else if (r.properties.type == "blob")
      return s.readAsBinaryString(t);
  }
}
g(ConstantFile, "title", "Const File"), g(ConstantFile, "desc", "Fetches a file from an url"), g(ConstantFile, "@type", {
  type: "enum",
  values: ["text", "arraybuffer", "blob", "json"]
});
ConstantFile.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/file", ConstantFile);
class JSONParse {
  constructor() {
    this.addInput("parse", LiteGraph.ACTION), this.addInput("json", "string"), this.addOutput("done", LiteGraph.EVENT), this.addOutput("object", "object"), this.widget = this.addWidget("button", "parse", "", this.parse.bind(this)), this._str = null, this._obj = null;
  }
  parse() {
    if (this._str)
      try {
        this._str = this.getInputData(1), this._obj = JSON.parse(this._str), this.boxcolor = "#AEA", this.triggerSlot(0);
      } catch {
        this.boxcolor = "red";
      }
  }
  onExecute() {
    this._str = this.getInputData(1), this.setOutputData(1, this._obj);
  }
  onAction(t) {
    t == "parse" && this.parse();
  }
}
g(JSONParse, "title", "JSON Parse"), g(JSONParse, "desc", "Parses JSON String into object");
LiteGraph.registerNodeType("basic/jsonparse", JSONParse);
class ConstantData {
  constructor() {
    this.addOutput("data", "object"), this.addProperty("value", ""), this.widget = this.addWidget("text", "json", "", "value"), this.widgets_up = !0, this.size = [140, 30], this._value = null;
  }
  onPropertyChanged(t, r) {
    if (this.widget.value = r, !(r == null || r == ""))
      try {
        this._value = JSON.parse(r), this.boxcolor = "#AEA";
      } catch {
        this.boxcolor = "red";
      }
  }
  onExecute() {
    this.setOutputData(0, this._value);
  }
}
g(ConstantData, "title", "Const Data"), g(ConstantData, "desc", "Constant Data");
ConstantData.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/data", ConstantData);
class ConstantArray {
  constructor() {
    this._value = [], this.addInput("json", ""), this.addOutput("arrayOut", "array"), this.addOutput("length", "number"), this.addProperty("value", "[]"), this.widget = this.addWidget(
      "text",
      "array",
      this.properties.value,
      "value"
    ), this.widgets_up = !0, this.size = [140, 50];
  }
  onPropertyChanged(t, r) {
    if (this.widget.value = r, !(r == null || r == ""))
      try {
        r[0] != "[" ? this._value = JSON.parse("[" + r + "]") : this._value = JSON.parse(r), this.boxcolor = "#AEA";
      } catch {
        this.boxcolor = "red";
      }
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && t.length) {
      this._value || (this._value = new Array()), this._value.length = t.length;
      for (var r = 0; r < t.length; ++r)
        this._value[r] = t[r];
      this.changeOutputType("arrayOut", "array");
    }
    this.setOutputData(0, this._value), this.setOutputData(1, this._value && this._value.length || 0);
  }
}
g(ConstantArray, "title", "Const Array"), g(ConstantArray, "desc", "Constant Array");
ConstantArray.prototype.setValue = ConstantNumber.prototype.setValue;
LiteGraph.registerNodeType("basic/array", ConstantArray);
class ArrayLength {
  constructor() {
    this.addInput("arr", "array"), this.addOutput("length", "number");
  }
  onExecute() {
    var r;
    var t = this.getInputData(0);
    t && (["array", "object"].includes(typeof t) && typeof t.length != "undefined" ? this.setOutputData(0, t.length) : ((r = console.debug) == null || r.call(console, "Not an array or object", typeof t, t), this.setOutputData(0, null)));
  }
}
g(ArrayLength, "title", "aLength"), g(ArrayLength, "desc", "Get the length of an array");
LiteGraph.registerNodeType("basic/array_length", ArrayLength);
class SetArray {
  constructor() {
    this.addInput("arr", "array"), this.addInput("value", ""), this.addOutput("arr", "array"), this.properties = { index: 0 }, this.widget = this.addWidget(
      "number",
      "i",
      this.properties.index,
      "index",
      { precision: 0, step: 10, min: 0 }
    );
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      var r = this.getInputData(1);
      r !== void 0 && (this.properties.index && (t[Math.floor(this.properties.index)] = r), this.setOutputData(0, t));
    }
  }
}
g(SetArray, "title", "Set Array"), g(SetArray, "desc", "Sets index of array");
LiteGraph.registerNodeType("basic/set_array", SetArray);
class ArrayElement {
  constructor() {
    this.addInput("array", "array,table,string"), this.addInput("index", "number"), this.addOutput("value", ""), this.addProperty("index", 0);
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1);
    r == null && (r = this.properties.index), !(t == null || r == null) && this.setOutputData(0, t[Math.floor(Number(r))]);
  }
}
g(ArrayElement, "title", "Array[i]"), g(ArrayElement, "desc", "Returns an element from an array");
LiteGraph.registerNodeType("basic/array[]", ArrayElement);
class TableElement {
  constructor() {
    this.addInput("table", "table"), this.addInput("row", "number"), this.addInput("col", "number"), this.addOutput("value", ""), this.addProperty("row", 0), this.addProperty("column", 0);
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1), s = this.getInputData(2);
    r == null && (r = this.properties.row), s == null && (s = this.properties.column), !(t == null || r == null || s == null) && (r = t[Math.floor(Number(r))], r ? this.setOutputData(0, r[Math.floor(Number(s))]) : this.setOutputData(0, null));
  }
}
g(TableElement, "title", "Table[row][col]"), g(TableElement, "desc", "Returns an element from a table");
LiteGraph.registerNodeType("basic/table[][]", TableElement);
class ObjectProperty {
  constructor() {
    this.addInput("obj", "object"), this.addOutput("property", 0), this.addProperty("value", 0), this.widget = this.addWidget("text", "prop.", "", this.setValue.bind(this)), this.widgets_up = !0, this.size = [140, 30], this._value = null;
  }
  setValue(t) {
    this.properties.value = t, this.widget.value = t;
  }
  getTitle() {
    return this.flags.collapsed ? "in." + this.properties.value : this.title;
  }
  onPropertyChanged(t, r) {
    this.widget.value = r;
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && this.setOutputData(0, t[this.properties.value]);
  }
}
g(ObjectProperty, "title", "Object property"), g(ObjectProperty, "desc", "Outputs the property of an object");
LiteGraph.registerNodeType("basic/object_property", ObjectProperty);
class ObjectKeys {
  constructor() {
    this.addInput("obj", ""), this.addOutput("keys", "array"), this.size = [140, 30];
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && this.setOutputData(0, Object.keys(t));
  }
}
g(ObjectKeys, "title", "Object keys"), g(ObjectKeys, "desc", "Outputs an array with the keys of an object");
LiteGraph.registerNodeType("basic/object_keys", ObjectKeys);
class SetObject {
  constructor() {
    this.addInput("obj", ""), this.addInput("value", ""), this.addOutput("obj", ""), this.properties = { property: "" }, this.name_widget = this.addWidget(
      "text",
      "prop.",
      this.properties.property,
      "property"
    );
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      var r = this.getInputData(1);
      r !== void 0 && (this.properties.property && (t[this.properties.property] = r), this.setOutputData(0, t));
    }
  }
}
g(SetObject, "title", "Set Object"), g(SetObject, "desc", "Adds propertiesrty to object");
LiteGraph.registerNodeType("basic/set_object", SetObject);
class MergeObjects {
  constructor() {
    this.addInput("A", "object"), this.addInput("B", "object"), this.addOutput("out", "object"), this._result = {};
    var t = this;
    this.addWidget("button", "clear", "", function() {
      t._result = {};
    }), this.size = this.computeSize();
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1), s = this._result;
    if (t)
      for (let a in t)
        s[a] = t[a];
    if (r)
      for (let a in r)
        s[a] = r[a];
    this.setOutputData(0, s);
  }
}
g(MergeObjects, "title", "Merge Objects"), g(MergeObjects, "desc", "Creates an object copying properties from others");
LiteGraph.registerNodeType("basic/merge_objects", MergeObjects);
const ue = class ue {
  constructor() {
    this.size = [60, 30], this.addInput("in"), this.addOutput("out"), this.properties = { varname: "myname", container: ue.LITEGRAPH }, this.value = null;
  }
  onExecute() {
    var t = this.getContainer();
    if (this.isInputConnected(0)) {
      this.value = this.getInputData(0), t[this.properties.varname] = this.value, this.setOutputData(0, this.value);
      return;
    }
    this.setOutputData(0, t[this.properties.varname]);
  }
  getContainer() {
    switch (this.properties.container) {
      case ue.GRAPH:
        return this.graph ? this.graph.vars : {};
      case ue.GLOBALSCOPE:
        return global;
      // @BUG: not sure what to do with this now
      default:
        return LiteGraph.Globals;
    }
  }
  getTitle() {
    return this.properties.varname;
  }
};
g(ue, "title", "Variable"), g(ue, "desc", "store/read variable value");
let Variable = ue;
Variable.LITEGRAPH = 0;
Variable.GRAPH = 1;
Variable.GLOBALSCOPE = 2;
Variable["@container"] = {
  type: "enum",
  values: {
    litegraph: Variable.LITEGRAPH,
    graph: Variable.GRAPH,
    global: Variable.GLOBALSCOPE
  }
};
LiteGraph.registerNodeType("basic/variable", Variable);
function length(n) {
  return n && n.length != null ? Number(n.length) : 0;
}
LiteGraph.wrapFunctionAsNode("basic/length", length, [""], "number");
LiteGraph.wrapFunctionAsNode(
  "basic/not",
  function(n) {
    return !n;
  },
  [""],
  "boolean"
);
class DownloadData {
  constructor() {
    this.size = [60, 30], this.addInput("data", 0), this.addInput("download", LiteGraph.ACTION), this.properties = { filename: "data.json" }, this.value = null;
    var t = this;
    this.addWidget("button", "Download", "", () => {
      t.value && t.downloadAsFile();
    });
  }
  downloadAsFile() {
    if (this.value != null) {
      var t = null;
      this.value.constructor === String ? t = this.value : t = JSON.stringify(this.value);
      var r = new Blob([t]), s = URL.createObjectURL(r), a = document.createElement("a");
      a.setAttribute("href", s), a.setAttribute("download", this.properties.filename), a.style.display = "none", document.body.appendChild(a), a.click(), document.body.removeChild(a), setTimeout(function() {
        URL.revokeObjectURL(s);
      }, 1e3 * 60);
    }
  }
  onAction() {
    var t = this;
    setTimeout(function() {
      t.downloadAsFile();
    }, 100);
  }
  onExecute() {
    this.inputs[0] && (this.value = this.getInputData(0));
  }
  getTitle() {
    return this.flags.collapsed ? this.properties.filename : this.title;
  }
}
g(DownloadData, "title", "Download"), g(DownloadData, "desc", "Download some data");
LiteGraph.registerNodeType("basic/download", DownloadData);
const ge = class ge {
  constructor() {
    this.size = [60, 30], this.addInput("value", 0, { label: "" }), this.value = 0;
  }
  onExecute() {
    this.inputs[0] && (this.value = this.getInputData(0));
  }
  getTitle() {
    return this.flags.collapsed ? this.inputs[0].label : this.title;
  }
  static toString(t) {
    if (t == null)
      return "null";
    if (t.constructor === Number)
      return t.toFixed(3);
    if (t.constructor === Array) {
      for (var r = "[", s = 0; s < t.length; ++s)
        r += ge.toString(t[s]) + (s + 1 != t.length ? "," : "");
      return r += "]", r;
    } else
      return String(t);
  }
  onDrawBackground() {
    this.inputs[0].label = ge.toString(this.value);
  }
};
g(ge, "title", "Watch"), g(ge, "desc", "Show value of input");
let Watch = ge;
LiteGraph.registerNodeType("basic/watch", Watch);
class Cast {
  constructor() {
    this.addInput("in", 0), this.addOutput("out", 0), this.size = [40, 30];
  }
  onExecute() {
    this.setOutputData(0, this.getInputData(0));
  }
}
g(Cast, "title", "Cast"), g(Cast, "desc", "Allows to connect different types");
LiteGraph.registerNodeType("basic/cast", Cast);
class Console {
  // @BUG: Didn't output text to console, either in browser or cmd
  constructor() {
    this.mode = LiteGraph.ON_EVENT, this.size = [80, 30], this.addProperty("msg", ""), this.addInput("log", LiteGraph.EVENT), this.addInput("msg", 0);
  }
  onAction(t, r) {
    var a, o, u;
    var s = this.getInputData(1);
    s || (s = this.properties.msg), s || (s = "Event: " + r), t == "log" ? (a = console.log) == null || a.call(console, s) : t == "warn" ? (o = console.warn) == null || o.call(console, s) : t == "error" && ((u = console.error) == null || u.call(console, s));
  }
  onExecute() {
    var r;
    var t = this.getInputData(1);
    t || (t = this.properties.msg), t != null && typeof t != "undefined" && (this.properties.msg = t, (r = console.log) == null || r.call(console, t));
  }
  onGetInputs() {
    return [
      ["log", LiteGraph.ACTION],
      ["warn", LiteGraph.ACTION],
      ["error", LiteGraph.ACTION]
    ];
  }
}
g(Console, "title", "Console"), g(Console, "desc", "Show value inside the console");
LiteGraph.registerNodeType("basic/console", Console);
class Alert {
  constructor() {
    this.mode = LiteGraph.ON_EVENT, this.addProperty("msg", ""), this.addInput("", LiteGraph.EVENT), this.widget = this.addWidget("text", "Text", "", "msg"), this.widgets_up = !0, this.size = [200, 30];
  }
  onConfigure(t) {
    this.widget.value = t.properties.msg;
  }
  onAction() {
    var t = this.properties.msg;
    setTimeout(function() {
      alert(t);
    }, 10);
  }
}
g(Alert, "title", "Alert"), g(Alert, "desc", "Show an alert window"), g(Alert, "color", "#510");
LiteGraph.registerNodeType("basic/alert", Alert);
class NodeScript {
  constructor() {
    this.size = [60, 30], this.addProperty("onExecute", "return A;"), this.addInput("A", 0), this.addInput("B", 0), this.addOutput("out", 0), this._func = null, this.data = {};
  }
  onConfigure(t) {
    var r;
    t.properties.onExecute && LiteGraph.allow_scripts ? this.compileCode(t.properties.onExecute) : (r = console.warn) == null || r.call(console, "Script not compiled, LiteGraph.allow_scripts is false");
  }
  onPropertyChanged(t, r) {
    var s;
    t == "onExecute" && LiteGraph.allow_scripts ? this.compileCode(r) : (s = console.warn) == null || s.call(console, "Script not compiled, LiteGraph.allow_scripts is false");
  }
  compileCode(t) {
    var o, u, h, l;
    if (this._func = null, t.length > 256)
      (o = console.warn) == null || o.call(console, "Script too long, max 256 chars");
    else {
      for (var r = t.toLowerCase(), s = [
        "script",
        "body",
        "document",
        "eval",
        "nodescript",
        "function"
      ], a = 0; a < s.length; ++a)
        if (r.indexOf(s[a]) != -1) {
          (u = console.warn) == null || u.call(console, "invalid script");
          return;
        }
      try {
        this._func = new Function("A", "B", "C", "DATA", "node", t);
      } catch (c) {
        (h = console.error) == null || h.call(console, "Error parsing script"), (l = console.error) == null || l.call(console, c);
      }
    }
  }
  onExecute() {
    var a, o;
    if (this._func)
      try {
        var t = this.getInputData(0), r = this.getInputData(1), s = this.getInputData(2);
        this.setOutputData(0, this._func(t, r, s, this.data, this));
      } catch (u) {
        (a = console.error) == null || a.call(console, "Error in script"), (o = console.error) == null || o.call(console, u);
      }
  }
  onGetOutputs() {
    return [["C", ""]];
  }
}
g(NodeScript, "title", "Script"), g(NodeScript, "desc", "executes a code (max 256 characters)"), g(NodeScript, "widgets_info", { onExecute: { type: "code" } });
LiteGraph.registerNodeType("basic/script", NodeScript);
const kt = class kt {
  constructor() {
    this.addInput("A", 0), this.addInput("B", 0), this.addOutput("true", "boolean"), this.addOutput("false", "boolean"), this.addProperty("A", 1), this.addProperty("B", 1), this.addProperty("OP", "==", "enum", { values: kt.values }), this.addWidget("combo", "Op.", this.properties.OP, {
      property: "OP",
      values: kt.values
    }), this.size = [80, 60];
  }
  getTitle() {
    return "*A " + this.properties.OP + " *B";
  }
  onExecute() {
    var t = this.getInputData(0);
    t === void 0 ? t = this.properties.A : this.properties.A = t;
    var r = this.getInputData(1);
    r === void 0 ? r = this.properties.B : this.properties.B = r;
    var s = !1;
    if (typeof t == typeof r)
      switch (this.properties.OP) {
        case "==":
        case "!=":
          switch (s = !0, typeof t) {
            case "object":
              var a = Object.getOwnPropertyNames(t), o = Object.getOwnPropertyNames(r);
              if (a.length != o.length) {
                s = !1;
                break;
              }
              for (var u = 0; u < a.length; u++) {
                var h = a[u];
                if (t[h] !== r[h]) {
                  s = !1;
                  break;
                }
              }
              break;
            default:
              s = t == r;
          }
          this.properties.OP == "!=" && (s = !s);
          break;
      }
    this.setOutputData(0, s), this.setOutputData(1, !s);
  }
};
g(kt, "title", "Compare *"), g(kt, "desc", "evaluates condition between A and B"), g(kt, "values", ["==", "!="]), // [">", "<", "==", "!=", "<=", ">=", "||", "&&" ];
g(kt, "@OP", {
  type: "enum",
  title: "operation",
  values: kt.values
});
let GenericCompare = kt;
LiteGraph.registerNodeType("basic/CompareValues", GenericCompare);
class LogEvent {
  constructor() {
    this.size = [60, 30], this.addInput("event", LiteGraph.ACTION);
  }
  onAction(t, r) {
    var s;
    (s = console.log) == null || s.call(console, t, r);
  }
}
g(LogEvent, "title", "Log Event"), g(LogEvent, "desc", "Log event in console");
LiteGraph.registerNodeType("events/log", LogEvent);
class TriggerEvent {
  constructor() {
    this.size = [60, 30], this.addInput("if", ""), this.addOutput("true", LiteGraph.EVENT), this.addOutput("change", LiteGraph.EVENT), this.addOutput("false", LiteGraph.EVENT), this.properties = {
      only_on_change: !0,
      tooltip: "Triggers event if input evaluates to true"
    }, this.prev = 0;
  }
  onExecute(t, r) {
    var s = this.getInputData(0), a = s != this.prev;
    this.prev === 0 && (a = !1);
    var o = a && this.properties.only_on_change || !a && !this.properties.only_on_change;
    s && o && this.triggerSlot(0, t, null, r), !s && o && this.triggerSlot(2, t, null, r), a && this.triggerSlot(1, t, null, r), this.prev = s;
  }
}
g(TriggerEvent, "title", "TriggerEvent"), g(TriggerEvent, "desc", "Triggers event if input evaluates to true");
LiteGraph.registerNodeType("events/trigger", TriggerEvent);
var Ge;
let Sequence$1 = (Ge = class {
  // @ BUG: fails to construct Node
  constructor() {
    var t = this;
    this.addInput("", LiteGraph.ACTION), this.addInput("", LiteGraph.ACTION), this.addInput("", LiteGraph.ACTION), this.addOutput("", LiteGraph.EVENT), this.addOutput("", LiteGraph.EVENT), this.addOutput("", LiteGraph.EVENT), this.addWidget("button", "+", null, function() {
      t.addInput("", LiteGraph.ACTION), t.addOutput("", LiteGraph.EVENT);
    }), this.size = [90, 70], this.flags = { horizontal: !0, render_box: !1 };
  }
  getTitle() {
    return "";
  }
  onAction(t, r, s) {
    if (this.outputs) {
      s = s || {};
      for (var a = 0; a < this.outputs.length; ++a)
        s.action_call ? s.action_call = s.action_call + "_seq_" + a : s.action_call = this.id + "_" + (t || "action") + "_seq_" + a + "_" + Math.floor(Math.random() * 9999), this.triggerSlot(a, r, null, s);
    }
  }
}, g(Ge, "title", "Sequence"), g(Ge, "desc", "Triggers a sequence of events when an event arrives"), Ge);
LiteGraph.registerNodeType("events/sequence", Sequence$1);
class WaitAll {
  constructor() {
    var t = this;
    this.addInput("", LiteGraph.ACTION), this.addInput("", LiteGraph.ACTION), this.addOutput("", LiteGraph.EVENT), this.addWidget("button", "+", null, function() {
      t.addInput("", LiteGraph.ACTION), t.size[0] = 90;
    }), this.size = [90, 70], this.ready = [];
  }
  getTitle() {
    return "";
  }
  onDrawBackground(t) {
    if (!this.flags.collapsed)
      for (var r = 0; r < this.inputs.length; ++r) {
        var s = r * LiteGraph.NODE_SLOT_HEIGHT + 10;
        t.fillStyle = this.ready[r] ? "#AFB" : "#000", t.fillRect(20, s, 10, 10);
      }
  }
  onAction(t, r, s, a) {
    if (a != null) {
      this.ready.length = this.outputs.length, this.ready[a] = !0;
      for (var o = 0; o < this.ready.length; ++o)
        if (!this.ready[o])
          return;
      this.reset(), this.triggerSlot(0);
    }
  }
  reset() {
    this.ready.length = 0;
  }
}
g(WaitAll, "title", "WaitAll"), g(WaitAll, "desc", "Wait until all input events arrive then triggers output");
LiteGraph.registerNodeType("events/waitAll", WaitAll);
class Stepper {
  constructor() {
    var t = this;
    this.properties = { index: 0 }, this.addInput("index", "number"), this.addInput("step", LiteGraph.ACTION), this.addInput("reset", LiteGraph.ACTION), this.addOutput("index", "number"), this.addOutput("", LiteGraph.EVENT), this.addOutput("", LiteGraph.EVENT), this.addOutput("", LiteGraph.EVENT, { removable: !0 }), this.addWidget("button", "+", null, function() {
      t.addOutput("", LiteGraph.EVENT, { removable: !0 });
    }), this.size = [120, 120], this.flags = { render_box: !1 };
  }
  onDrawBackground(t) {
    if (!this.flags.collapsed) {
      var r = this.properties.index || 0;
      t.fillStyle = "#AFB";
      var s = this.size[0], a = (r + 1) * LiteGraph.NODE_SLOT_HEIGHT + 4;
      t.beginPath(), t.moveTo(s - 30, a), t.lineTo(s - 30, a + LiteGraph.NODE_SLOT_HEIGHT), t.lineTo(s - 15, a + LiteGraph.NODE_SLOT_HEIGHT * 0.5), t.fill();
    }
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (t = Math.floor(t), t = LiteGraph.clamp(
      t,
      0,
      this.outputs ? this.outputs.length - 2 : 0
    ), t != this.properties.index && (this.properties.index = t, this.triggerSlot(t + 1))), this.setOutputData(0, this.properties.index);
  }
  onAction(t, r) {
    if (t == "reset") this.properties.index = 0;
    else if (t == "step") {
      this.triggerSlot(this.properties.index + 1, r);
      var s = this.outputs ? this.outputs.length - 1 : 0;
      this.properties.index = (this.properties.index + 1) % s;
    }
  }
}
g(Stepper, "title", "Stepper"), g(Stepper, "desc", "Trigger events sequentially when an tick arrives");
LiteGraph.registerNodeType("events/stepper", Stepper);
class FilterEvent {
  constructor() {
    this.size = [60, 30], this.addInput("event", LiteGraph.ACTION), this.addOutput("event", LiteGraph.EVENT), this.properties = {
      equal_to: "",
      has_property: "",
      property_equal_to: ""
    };
  }
  onAction(t, r, s) {
    if (r != null && !(this.properties.equal_to && this.properties.equal_to != r)) {
      if (this.properties.has_property) {
        var a = r[this.properties.has_property];
        if (a == null || this.properties.property_equal_to && this.properties.property_equal_to != a)
          return;
      }
      this.triggerSlot(0, r, null, s);
    }
  }
}
g(FilterEvent, "title", "Filter Event"), g(FilterEvent, "desc", "Blocks events that do not match the filter");
LiteGraph.registerNodeType("events/filter", FilterEvent);
class EventBranch {
  constructor() {
    this.addInput("in", LiteGraph.ACTION), this.addInput("cond", "boolean"), this.addOutput("true", LiteGraph.EVENT), this.addOutput("false", LiteGraph.EVENT), this.size = [120, 60], this._value = !1;
  }
  onExecute() {
    this._value = this.getInputData(1);
  }
  onAction(t, r, s) {
    this._value = this.getInputData(1), this.triggerSlot(this._value ? 0 : 1, r, null, s);
  }
}
g(EventBranch, "title", "Branch"), g(EventBranch, "desc", "If condition is true, outputs triggers true, otherwise false");
LiteGraph.registerNodeType("events/branch", EventBranch);
class EventCounter {
  constructor() {
    this.addInput("inc", LiteGraph.ACTION), this.addInput("dec", LiteGraph.ACTION), this.addInput("reset", LiteGraph.ACTION), this.addOutput("change", LiteGraph.EVENT), this.addOutput("num", "number"), this.addProperty(
      "doCountExecution",
      !1,
      "boolean",
      { name: "Count Executions" }
    ), this.addWidget(
      "toggle",
      "Count Exec.",
      this.properties.doCountExecution,
      "doCountExecution"
    ), this.num = 0;
  }
  getTitle() {
    return this.flags.collapsed ? String(this.num) : this.title;
  }
  onAction(t) {
    var r = this.num;
    t == "inc" ? this.num += 1 : t == "dec" ? this.num -= 1 : t == "reset" && (this.num = 0), this.num != r && this.trigger("change", this.num);
  }
  onDrawBackground(t) {
    this.flags.collapsed || (t.fillStyle = "#AAA", t.font = "20px Arial", t.textAlign = "center", t.fillText(this.num, this.size[0] * 0.5, this.size[1] * 0.5));
  }
  onExecute() {
    this.properties.doCountExecution && (this.num += 1), this.setOutputData(1, this.num);
  }
}
g(EventCounter, "title", "Counter"), g(EventCounter, "desc", "Counts events");
LiteGraph.registerNodeType("events/counter", EventCounter);
class DelayEvent {
  constructor() {
    this.size = [60, 30], this.addProperty("time_in_ms", 1e3), this.addInput("event", LiteGraph.ACTION), this.addOutput("on_time", LiteGraph.EVENT), this._pending = [];
  }
  onAction(t, r, s) {
    var a = this.properties.time_in_ms;
    a <= 0 ? this.trigger(null, r, s) : this._pending.push([a, r]);
  }
  onExecute(t, r) {
    var s = this.graph.elapsed_time * 1e3;
    this.isInputConnected(1) && (this.properties.time_in_ms = this.getInputData(1));
    for (var a = 0; a < this._pending.length; ++a) {
      var o = this._pending[a];
      o[0] -= s, !(o[0] > 0) && (this._pending.splice(a, 1), --a, this.trigger(null, o[1], r));
    }
  }
  onGetInputs() {
    return [
      ["event", LiteGraph.ACTION],
      ["time_in_ms", "number"]
    ];
  }
}
g(DelayEvent, "title", "Delay"), g(DelayEvent, "desc", "Delays one event");
LiteGraph.registerNodeType("events/delay", DelayEvent);
const _e = class _e {
  constructor() {
    this.addProperty("interval", 1e3), this.addProperty("event", "tick"), this.addOutput("on_tick", LiteGraph.EVENT), this.time = 0, this.last_interval = 1e3, this.triggered = !1;
  }
  onStart() {
    this.time = 0;
  }
  getTitle() {
    return "Timer: " + this.last_interval.toString() + "ms";
  }
  onDrawBackground() {
    this.boxcolor = this.triggered ? _e.on_color : _e.off_color, this.triggered = !1;
  }
  onExecute() {
    var t = this.graph.elapsed_time * 1e3, r = this.time == 0;
    if (this.time += t, this.last_interval = Math.max(1, this.getInputOrProperty("interval") | 0), !r && (this.time < this.last_interval || isNaN(this.last_interval))) {
      this.inputs && this.inputs.length > 1 && this.inputs[1] && this.setOutputData(1, !1);
      return;
    }
    this.triggered = !0, this.time = this.time % this.last_interval, this.trigger("on_tick", this.properties.event), this.inputs && this.inputs.length > 1 && this.inputs[1] && this.setOutputData(1, !0);
  }
  onGetInputs() {
    return [["interval", "number"]];
  }
  onGetOutputs() {
    return [["tick", "boolean"]];
  }
};
g(_e, "title", "Timer"), g(_e, "desc", "Sends an event every N milliseconds");
let TimerEvent = _e;
TimerEvent.on_color = "#AAA";
TimerEvent.off_color = "#222";
LiteGraph.registerNodeType("events/timer", TimerEvent);
class SemaphoreEvent {
  constructor() {
    this.addInput("go", LiteGraph.ACTION), this.addInput("green", LiteGraph.ACTION), this.addInput("red", LiteGraph.ACTION), this.addOutput("continue", LiteGraph.EVENT), this.addOutput("blocked", LiteGraph.EVENT), this.addOutput("is_green", "boolean"), this._ready = !1, this.properties = {};
    var t = this;
    this.addWidget("button", "reset", "", function() {
      t._ready = !1;
    });
  }
  onExecute() {
    this.setOutputData(1, this._ready), this.boxcolor = this._ready ? "#9F9" : "#FA5";
  }
  onAction(t) {
    t == "go" ? this.triggerSlot(this._ready ? 0 : 1) : t == "green" ? this._ready = !0 : t == "red" && (this._ready = !1);
  }
}
g(SemaphoreEvent, "title", "Semaphore Event"), g(SemaphoreEvent, "desc", "Until both events are not triggered, it doesnt continue.");
LiteGraph.registerNodeType("events/semaphore", SemaphoreEvent);
class OnceEvent {
  constructor() {
    this.addInput("in", LiteGraph.ACTION), this.addInput("reset", LiteGraph.ACTION), this.addOutput("out", LiteGraph.EVENT), this._once = !1, this.properties = {};
    var t = this;
    this.addWidget("button", "reset", "", function() {
      t._once = !1;
    });
  }
  onAction(t, r) {
    t == "in" && !this._once ? (this._once = !0, this.triggerSlot(0, r)) : t == "reset" && (this._once = !1);
  }
}
g(OnceEvent, "title", "Once"), g(OnceEvent, "desc", "Only passes an event once, then gets locked");
LiteGraph.registerNodeType("events/once", OnceEvent);
class DataStore {
  constructor() {
    this.addInput("data", 0), this.addInput("assign", LiteGraph.ACTION), this.addOutput("data", 0), this._last_value = null, this.properties = { data: null, serialize: !0 };
    var t = this;
    this.addWidget("button", "store", "", function() {
      t.properties.data = t._last_value;
    });
  }
  onExecute() {
    this._last_value = this.getInputData(0), this.setOutputData(0, this.properties.data);
  }
  onAction() {
    this.properties.data = this._last_value;
  }
  onSerialize(t) {
    t.data != null && (!this.properties.serialize || t.data.constructor !== String && t.data.constructor !== Number && t.data.constructor !== Boolean && t.data.constructor !== Array && t.data.constructor !== Object) && (t.data = null);
  }
}
g(DataStore, "title", "Data Store"), g(DataStore, "desc", "Stores data and only changes when event is received");
LiteGraph.registerNodeType("basic/data_store", DataStore);
const me = class me {
  constructor() {
    this.addOutput("", LiteGraph.EVENT), this.addOutput("", "boolean"), this.addProperty("text", "DO"), this.addProperty("font_size", 30), this.addProperty("message", ""), this.size = [84, 84], this.clicked = !1;
  }
  onDrawForeground(t) {
    if (!this.flags.collapsed) {
      var r = 10;
      if (t.fillStyle = "black", t.fillRect(
        r + 1,
        r + 1,
        this.size[0] - r * 2,
        this.size[1] - r * 2
      ), t.fillStyle = "#AAF", t.fillRect(
        r - 1,
        r - 1,
        this.size[0] - r * 2,
        this.size[1] - r * 2
      ), t.fillStyle = this.clicked ? "white" : this.mouseOver ? "#668" : "#334", t.fillRect(
        r,
        r,
        this.size[0] - r * 2,
        this.size[1] - r * 2
      ), this.properties.text || this.properties.text === 0) {
        var s = this.properties.font_size || 30;
        t.textAlign = "center", t.fillStyle = this.clicked ? "black" : "white", t.font = s + "px " + me.font, t.fillText(
          this.properties.text,
          this.size[0] * 0.5,
          this.size[1] * 0.5 + s * 0.3
        ), t.textAlign = "left";
      }
    }
  }
  onMouseDown(t, r) {
    if (r[0] > 1 && r[1] > 1 && r[0] < this.size[0] - 2 && r[1] < this.size[1] - 2)
      return this.clicked = !0, this.setOutputData(1, this.clicked), this.triggerSlot(0, this.properties.message), !0;
  }
  onExecute() {
    this.setOutputData(1, this.clicked);
  }
  onMouseUp(t) {
    this.clicked = !1;
  }
};
g(me, "title", "Button"), g(me, "desc", "Triggers an event"), g(me, "font", "Arial");
let WidgetButton = me;
LiteGraph.registerNodeType("widget/button", WidgetButton);
class WidgetToggle {
  constructor() {
    this.addInput("", "boolean"), this.addInput("e", LiteGraph.ACTION), this.addOutput("v", "boolean"), this.addOutput("e", LiteGraph.EVENT), this.properties = { font: "", value: !1 }, this.size = [160, 44];
  }
  onDrawForeground(t) {
    if (!this.flags.collapsed) {
      var r = this.size[1] * 0.5, s = 0.25, a = this.size[1] * 0.8;
      t.font = this.properties.font || (r * 0.8).toFixed(0) + "px Arial";
      var o = t.measureText(this.title).width, u = (this.size[0] - (o + r)) * 0.5;
      t.fillStyle = "#AAA", t.fillRect(u, a - r, r, r), t.fillStyle = this.properties.value ? "#AEF" : "#000", t.fillRect(
        u + r * s,
        a - r + r * s,
        r * (1 - s * 2),
        r * (1 - s * 2)
      ), t.textAlign = "left", t.fillStyle = "#AAA", t.fillText(this.title, r * 1.2 + u, a * 0.85), t.textAlign = "left";
    }
  }
  onAction(t) {
    this.properties.value = !this.properties.value, this.trigger("e", this.properties.value);
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (this.properties.value = t), this.setOutputData(0, this.properties.value);
  }
  onMouseDown(t, r) {
    if (r[0] > 1 && r[1] > 1 && r[0] < this.size[0] - 2 && r[1] < this.size[1] - 2)
      return this.properties.value = !this.properties.value, this.graph._version++, this.trigger("e", this.properties.value), !0;
  }
}
g(WidgetToggle, "title", "Toggle"), g(WidgetToggle, "desc", "Toggles between true or false");
LiteGraph.registerNodeType("widget/toggle", WidgetToggle);
const Kt = class Kt {
  constructor() {
    this.addOutput("", "number"), this.size = [80, 60], this.properties = { min: -1e3, max: 1e3, value: 1, step: 1 }, this.old_y = -1, this._remainder = 0, this._precision = 0, this.mouse_captured = !1;
  }
  onDrawForeground(t) {
    var r = this.size[0] * 0.5, s = this.size[1];
    s > 30 ? (t.fillStyle = Kt.markers_color, t.beginPath(), t.moveTo(r, s * 0.1), t.lineTo(r + s * 0.1, s * 0.2), t.lineTo(r + s * -0.1, s * 0.2), t.fill(), t.beginPath(), t.moveTo(r, s * 0.9), t.lineTo(r + s * 0.1, s * 0.8), t.lineTo(r + s * -0.1, s * 0.8), t.fill(), t.font = (s * 0.7).toFixed(1) + "px Arial") : t.font = (s * 0.8).toFixed(1) + "px Arial", t.textAlign = "center", t.font = (s * 0.7).toFixed(1) + "px Arial", t.fillStyle = "#EEE", t.fillText(this.properties.value.toFixed(this._precision), r, s * 0.75);
  }
  onExecute() {
    this.setOutputData(0, this.properties.value);
  }
  onPropertyChanged(t, r) {
    var s = (this.properties.step + "").split(".");
    this._precision = s.length > 1 ? s[1].length : 0;
  }
  onMouseDown(t, r) {
    if (!(r[1] < 0))
      return this.old_y = t.canvasY, this.captureInput(!0), this.mouse_captured = !0, !0;
  }
  onMouseMove(t) {
    if (this.mouse_captured) {
      var r = this.old_y - t.canvasY;
      t.shiftKey && (r *= 10), (t.metaKey || t.altKey) && (r *= 0.1), this.old_y = t.canvasY;
      var s = this._remainder + r / Kt.pixels_threshold;
      this._remainder = s % 1, s = s | 0;
      var a = LiteGraph.clamp(
        this.properties.value + s * this.properties.step,
        this.properties.min,
        this.properties.max
      );
      this.properties.value = a, this.graph._version++, this.setDirtyCanvas(!0);
    }
  }
  onMouseUp(t, r) {
    if (t.click_time < 200) {
      var s = r[1] > this.size[1] * 0.5 ? -1 : 1;
      this.properties.value = LiteGraph.clamp(
        this.properties.value + s * this.properties.step,
        this.properties.min,
        this.properties.max
      ), this.graph._version++, this.setDirtyCanvas(!0);
    }
    this.mouse_captured && (this.mouse_captured = !1, this.captureInput(!1));
  }
};
g(Kt, "title", "Number"), g(Kt, "desc", "Widget to select number value"), g(Kt, "pixels_threshold", 10), g(Kt, "markers_color", "#666");
let WidgetNumber = Kt;
LiteGraph.registerNodeType("widget/number", WidgetNumber);
class WidgetCombo {
  constructor() {
    this.addOutput("", "string"), this.addOutput("change", LiteGraph.EVENT), this.size = [80, 60], this.properties = { value: "A", values: "A;B;C" }, this.old_y = -1, this.mouse_captured = !1, this._values = this.properties.values.split(";");
    var t = this;
    this.widgets_up = !0, this.widget = this.addWidget(
      "combo",
      "",
      this.properties.value,
      function(r) {
        t.properties.value = r, t.triggerSlot(1, r);
      },
      { property: "value", values: this._values }
    );
  }
  onExecute() {
    this.setOutputData(0, this.properties.value);
  }
  onPropertyChanged(t, r) {
    t == "values" ? (this._values = r.split(";"), this.widget.options.values = this._values) : t == "value" && (this.widget.value = r);
  }
}
g(WidgetCombo, "title", "Combo"), g(WidgetCombo, "desc", "Widget to select from a list");
LiteGraph.registerNodeType("widget/combo", WidgetCombo);
class WidgetKnob {
  constructor() {
    this.addOutput("", "number"), this.size = [64, 84], this.properties = {
      min: 0,
      max: 1,
      value: 0.5,
      color: "#7AF",
      precision: 2
    }, this.value = -1;
  }
  onDrawForeground(t) {
    if (!this.flags.collapsed) {
      this.value == -1 && (this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min));
      var r = this.size[0] * 0.5, s = this.size[1] * 0.5, a = Math.min(this.size[0], this.size[1]) * 0.5 - 5;
      t.globalAlpha = 1, t.save(), t.translate(r, s), t.rotate(Math.PI * 0.75), t.fillStyle = "rgba(0,0,0,0.5)", t.beginPath(), t.moveTo(0, 0), t.arc(0, 0, a, 0, Math.PI * 1.5), t.fill(), t.strokeStyle = "black", t.fillStyle = this.properties.color, t.lineWidth = 2, t.beginPath(), t.moveTo(0, 0), t.arc(0, 0, a - 4, 0, Math.PI * 1.5 * Math.max(0.01, this.value)), t.closePath(), t.fill(), t.lineWidth = 1, t.globalAlpha = 1, t.restore(), t.fillStyle = "black", t.beginPath(), t.arc(r, s, a * 0.75, 0, Math.PI * 2, !0), t.fill(), t.fillStyle = this.mouseOver ? "white" : this.properties.color, t.beginPath();
      var o = this.value * Math.PI * 1.5 + Math.PI * 0.75;
      t.arc(
        r + Math.cos(o) * a * 0.65,
        s + Math.sin(o) * a * 0.65,
        a * 0.05,
        0,
        Math.PI * 2,
        !0
      ), t.fill(), t.fillStyle = this.mouseOver ? "white" : "#AAA", t.font = Math.floor(a * 0.5) + "px Arial", t.textAlign = "center", t.fillText(
        this.properties.value.toFixed(this.properties.precision),
        r,
        s + a * 0.15
      );
    }
  }
  onExecute() {
    this.setOutputData(0, this.properties.value), this.boxcolor = LiteGraph.colorToString([
      this.value,
      this.value,
      this.value
    ]);
  }
  onMouseDown(t) {
    return this.center = [this.size[0] * 0.5, this.size[1] * 0.5 + 20], this.radius = this.size[0] * 0.5, t.canvasY - this.pos[1] < 20 || LiteGraph.distance(
      [t.canvasX, t.canvasY],
      [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]
    ) > this.radius ? !1 : (this.oldmouse = [t.canvasX - this.pos[0], t.canvasY - this.pos[1]], this.captureInput(!0), !0);
  }
  onMouseMove(t) {
    if (this.oldmouse) {
      var r = [t.canvasX - this.pos[0], t.canvasY - this.pos[1]], s = this.value;
      s -= (r[1] - this.oldmouse[1]) * 0.01, s > 1 ? s = 1 : s < 0 && (s = 0), this.value = s, this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value, this.oldmouse = r, this.setDirtyCanvas(!0);
    }
  }
  onMouseUp(t) {
    this.oldmouse && (this.oldmouse = null, this.captureInput(!1));
  }
  onPropertyChanged(t, r) {
    if (t == "min" || t == "max" || t == "value")
      return this.properties[t] = parseFloat(r), !0;
  }
}
g(WidgetKnob, "title", "Knob"), g(WidgetKnob, "desc", "Circular controller"), g(WidgetKnob, "size", [80, 100]);
LiteGraph.registerNodeType("widget/knob", WidgetKnob);
class WidgetSliderGUI {
  constructor() {
    this.addOutput("", "number"), this.properties = {
      value: 0.5,
      min: 0,
      max: 1,
      text: "V"
    };
    var t = this;
    this.size = [140, 40], this.slider = this.addWidget(
      "slider",
      "V",
      this.properties.value,
      function(r) {
        t.properties.value = r;
      },
      this.properties
    ), this.widgets_up = !0;
  }
  onPropertyChanged(t, r) {
    t == "value" && (this.slider.value = r);
  }
  onExecute() {
    this.setOutputData(0, this.properties.value);
  }
}
g(WidgetSliderGUI, "title", "Inner Slider");
LiteGraph.registerNodeType("widget/internal_slider", WidgetSliderGUI);
class WidgetHSlider {
  constructor() {
    this.size = [160, 26], this.addOutput("", "number"), this.properties = { color: "#7AF", min: 0, max: 1, value: 0.5 }, this.value = -1;
  }
  onDrawForeground(t) {
    this.value == -1 && (this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min)), t.globalAlpha = 1, t.lineWidth = 1, t.fillStyle = "#000", t.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4), t.fillStyle = this.properties.color, t.beginPath(), t.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8), t.fill();
  }
  onExecute() {
    this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value, this.setOutputData(0, this.properties.value), this.boxcolor = LiteGraph.colorToString([
      this.value,
      this.value,
      this.value
    ]);
  }
  onMouseDown(t) {
    return t.canvasY - this.pos[1] < 0 ? !1 : (this.oldmouse = [t.canvasX - this.pos[0], t.canvasY - this.pos[1]], this.captureInput(!0), !0);
  }
  onMouseMove(t) {
    if (this.oldmouse) {
      var r = [t.canvasX - this.pos[0], t.canvasY - this.pos[1]], s = this.value, a = r[0] - this.oldmouse[0];
      s += a / this.size[0], s > 1 ? s = 1 : s < 0 && (s = 0), this.value = s, this.oldmouse = r, this.setDirtyCanvas(!0);
    }
  }
  onMouseUp(t) {
    this.oldmouse = null, this.captureInput(!1);
  }
}
g(WidgetHSlider, "title", "H.Slider"), g(WidgetHSlider, "desc", "Linear slider controller");
LiteGraph.registerNodeType("widget/hslider", WidgetHSlider);
class WidgetProgress {
  constructor() {
    this.size = [160, 26], this.addInput("", "number"), this.properties = { min: 0, max: 1, value: 0, color: "#AAF" };
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (this.properties.value = t);
  }
  onDrawForeground(t) {
    t.lineWidth = 1, t.fillStyle = this.properties.color;
    var r = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    r = Math.min(1, r), r = Math.max(0, r), t.fillRect(2, 2, (this.size[0] - 4) * r, this.size[1] - 4);
  }
}
g(WidgetProgress, "title", "Progress"), g(WidgetProgress, "desc", "Shows data in linear progress");
LiteGraph.registerNodeType("widget/progress", WidgetProgress);
class WidgetText {
  // @BUG: Will draw text straight off the node with no wrapping
  constructor() {
    this.addInputs("", 0), this.properties = {
      value: "...",
      font: "Arial",
      fontsize: 18,
      color: "#AAA",
      align: "left",
      glowSize: 0,
      decimals: 1
    };
  }
  onDrawForeground(t) {
    t.fillStyle = this.properties.color;
    var r = this.properties.value;
    this.properties.glowSize ? (t.shadowColor = this.properties.color, t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = this.properties.glowSize) : t.shadowColor = "transparent";
    var s = this.properties.fontsize;
    if (t.textAlign = this.properties.align, t.font = s.toString() + "px " + this.properties.font, this.str = typeof r == "number" ? r.toFixed(this.properties.decimals) : r, typeof this.str == "string")
      for (var a = this.str.replace(/[\r\n]/g, "\\n").split("\\n"), o = 0; o < a.length; o++)
        t.fillText(
          a[o],
          this.properties.align == "left" ? 15 : this.size[0] - 15,
          s * -0.15 + s * (parseInt(o) + 1)
        );
    t.shadowColor = "transparent", this.last_ctx = t, t.textAlign = "left";
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (this.properties.value = t);
  }
  resize() {
    if (this.last_ctx) {
      var t = this.str.split("\\n");
      this.last_ctx.font = this.properties.fontsize + "px " + this.properties.font;
      for (var r = 0, s = 0; s < t.length; s++) {
        var a = this.last_ctx.measureText(t[s]).width;
        r < a && (r = a);
      }
      this.size[0] = r + 20, this.size[1] = 4 + t.length * this.properties.fontsize, this.setDirtyCanvas(!0);
    }
  }
  onPropertyChanged(t, r) {
    return this.properties[t] = r, this.str = typeof r == "number" ? r.toFixed(3) : r, !0;
  }
}
g(WidgetText, "title", "Text"), g(WidgetText, "desc", "Shows the input value"), g(WidgetText, "widgets", [
  { name: "resize", text: "Resize box", type: "button" },
  { name: "led_text", text: "LED", type: "minibutton" },
  { name: "normal_text", text: "Normal", type: "minibutton" }
]);
LiteGraph.registerNodeType("widget/text", WidgetText);
class WidgetPanel {
  constructor() {
    g(this, "widgets", [{ name: "update", text: "Update", type: "button" }]);
    this.size = [200, 100], this.properties = {
      borderColor: "#ffffff",
      bgcolorTop: "#f0f0f0",
      bgcolorBottom: "#e0e0e0",
      shadowSize: 2,
      borderRadius: 3
    };
  }
  createGradient(t) {
    if (this.properties.bgcolorTop == "" || this.properties.bgcolorBottom == "") {
      this.lineargradient = 0;
      return;
    }
    this.lineargradient = t.createLinearGradient(0, 0, 0, this.size[1]), this.lineargradient.addColorStop(0, this.properties.bgcolorTop), this.lineargradient.addColorStop(1, this.properties.bgcolorBottom);
  }
  onDrawForeground(t) {
    this.flags.collapsed || (this.lineargradient == null && this.createGradient(t), this.lineargradient && (t.lineWidth = 1, t.strokeStyle = this.properties.borderColor, t.fillStyle = this.lineargradient, this.properties.shadowSize ? (t.shadowColor = "#000", t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = this.properties.shadowSize) : t.shadowColor = "transparent", t.roundRect(
      0,
      0,
      this.size[0] - 1,
      this.size[1] - 1,
      this.properties.shadowSize
    ), t.fill(), t.shadowColor = "transparent", t.stroke()));
  }
}
g(WidgetPanel, "title", "Panel"), g(WidgetPanel, "desc", "Non interactive panel");
LiteGraph.registerNodeType("widget/panel", WidgetPanel);
const at = class at {
  constructor() {
    this.addOutput("left_x_axis", "number"), this.addOutput("left_y_axis", "number"), this.addOutput("button_pressed", LiteGraph.EVENT), this.properties = { gamepad_index: 0, threshold: 0.1 }, this._left_axis = new Float32Array(2), this._right_axis = new Float32Array(2), this._triggers = new Float32Array(2), this._previous_buttons = new Uint8Array(17), this._current_buttons = new Uint8Array(17);
  }
  onExecute() {
    var t = this.getGamepad(), r = this.properties.threshold || 0;
    if (t && (this._left_axis[0] = Math.abs(t.xbox.axes.lx) > r ? t.xbox.axes.lx : 0, this._left_axis[1] = Math.abs(t.xbox.axes.ly) > r ? t.xbox.axes.ly : 0, this._right_axis[0] = Math.abs(t.xbox.axes.rx) > r ? t.xbox.axes.rx : 0, this._right_axis[1] = Math.abs(t.xbox.axes.ry) > r ? t.xbox.axes.ry : 0, this._triggers[0] = Math.abs(t.xbox.axes.ltrigger) > r ? t.xbox.axes.ltrigger : 0, this._triggers[1] = Math.abs(t.xbox.axes.rtrigger) > r ? t.xbox.axes.rtrigger : 0), this.outputs)
      for (var s = 0; s < this.outputs.length; s++) {
        var a = this.outputs[s];
        if (!(!a.links || !a.links.length)) {
          var o = null;
          if (t)
            switch (a.name) {
              case "left_axis":
                o = this._left_axis;
                break;
              case "right_axis":
                o = this._right_axis;
                break;
              case "left_x_axis":
                o = this._left_axis[0];
                break;
              case "left_y_axis":
                o = this._left_axis[1];
                break;
              case "right_x_axis":
                o = this._right_axis[0];
                break;
              case "right_y_axis":
                o = this._right_axis[1];
                break;
              case "trigger_left":
                o = this._triggers[0];
                break;
              case "trigger_right":
                o = this._triggers[1];
                break;
              case "a_button":
                o = t.xbox.buttons.a ? 1 : 0;
                break;
              case "b_button":
                o = t.xbox.buttons.b ? 1 : 0;
                break;
              case "x_button":
                o = t.xbox.buttons.x ? 1 : 0;
                break;
              case "y_button":
                o = t.xbox.buttons.y ? 1 : 0;
                break;
              case "lb_button":
                o = t.xbox.buttons.lb ? 1 : 0;
                break;
              case "rb_button":
                o = t.xbox.buttons.rb ? 1 : 0;
                break;
              case "ls_button":
                o = t.xbox.buttons.ls ? 1 : 0;
                break;
              case "rs_button":
                o = t.xbox.buttons.rs ? 1 : 0;
                break;
              case "hat_left":
                o = t.xbox.hatmap & at.LEFT;
                break;
              case "hat_right":
                o = t.xbox.hatmap & at.RIGHT;
                break;
              case "hat_up":
                o = t.xbox.hatmap & at.UP;
                break;
              case "hat_down":
                o = t.xbox.hatmap & at.DOWN;
                break;
              case "hat":
                o = t.xbox.hatmap;
                break;
              case "start_button":
                o = t.xbox.buttons.start ? 1 : 0;
                break;
              case "back_button":
                o = t.xbox.buttons.back ? 1 : 0;
                break;
              case "button_pressed":
                for (var u = 0; u < this._current_buttons.length; ++u)
                  this._current_buttons[u] && !this._previous_buttons[u] && this.triggerSlot(s, at.buttons[u]);
                break;
            }
          else
            switch (a.name) {
              case "button_pressed":
                break;
              case "left_axis":
              case "right_axis":
                o = at.zero;
                break;
              default:
                o = 0;
            }
          this.setOutputData(s, o);
        }
      }
  }
  getGamepad() {
    var t = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
    if (!t)
      return null;
    var r = t.call(navigator), s = null;
    this._previous_buttons.set(this._current_buttons);
    for (var a = this.properties.gamepad_index; a < 4; a++)
      if (r[a]) {
        s = r[a];
        var o = this.xbox_mapping;
        o || (o = this.xbox_mapping = {
          axes: [],
          buttons: {},
          hat: "",
          hatmap: at.CENTER
        }), o.axes.lx = s.axes[0], o.axes.ly = s.axes[1], o.axes.rx = s.axes[2], o.axes.ry = s.axes[3], o.axes.ltrigger = s.buttons[6].value, o.axes.rtrigger = s.buttons[7].value, o.hat = "", o.hatmap = at.CENTER;
        for (var u = 0; u < s.buttons.length; u++)
          if (this._current_buttons[u] = s.buttons[u].pressed, u < 12)
            o.buttons[at.mapping_array[u]] = s.buttons[u].pressed, s.buttons[u].was_pressed && this.trigger(at.mapping_array[u] + "_button_event");
          else
            switch (u) {
              case 12:
                s.buttons[u].pressed && (o.hat += "up", o.hatmap |= at.UP);
                break;
              case 13:
                s.buttons[u].pressed && (o.hat += "down", o.hatmap |= at.DOWN);
                break;
              case 14:
                s.buttons[u].pressed && (o.hat += "left", o.hatmap |= at.LEFT);
                break;
              case 15:
                s.buttons[u].pressed && (o.hat += "right", o.hatmap |= at.RIGHT);
                break;
              case 16:
                o.buttons.home = s.buttons[u].pressed;
                break;
            }
        return s.xbox = o, s;
      }
  }
  onDrawBackground(t) {
    if (!this.flags.collapsed) {
      var r = this._left_axis, s = this._right_axis;
      t.strokeStyle = "#88A", t.strokeRect(
        (r[0] + 1) * 0.5 * this.size[0] - 4,
        (r[1] + 1) * 0.5 * this.size[1] - 4,
        8,
        8
      ), t.strokeStyle = "#8A8", t.strokeRect(
        (s[0] + 1) * 0.5 * this.size[0] - 4,
        (s[1] + 1) * 0.5 * this.size[1] - 4,
        8,
        8
      );
      var a = this.size[1] / this._current_buttons.length;
      t.fillStyle = "#AEB";
      for (var o = 0; o < this._current_buttons.length; ++o)
        this._current_buttons[o] && t.fillRect(0, a * o, 6, a);
    }
  }
  onGetOutputs() {
    return [
      ["left_axis", "vec2"],
      ["right_axis", "vec2"],
      ["left_x_axis", "number"],
      ["left_y_axis", "number"],
      ["right_x_axis", "number"],
      ["right_y_axis", "number"],
      ["trigger_left", "number"],
      ["trigger_right", "number"],
      ["a_button", "number"],
      ["b_button", "number"],
      ["x_button", "number"],
      ["y_button", "number"],
      ["lb_button", "number"],
      ["rb_button", "number"],
      ["ls_button", "number"],
      ["rs_button", "number"],
      ["start_button", "number"],
      ["back_button", "number"],
      ["a_button_event", LiteGraph.EVENT],
      ["b_button_event", LiteGraph.EVENT],
      ["x_button_event", LiteGraph.EVENT],
      ["y_button_event", LiteGraph.EVENT],
      ["lb_button_event", LiteGraph.EVENT],
      ["rb_button_event", LiteGraph.EVENT],
      ["ls_button_event", LiteGraph.EVENT],
      ["rs_button_event", LiteGraph.EVENT],
      ["start_button_event", LiteGraph.EVENT],
      ["back_button_event", LiteGraph.EVENT],
      ["hat_left", "number"],
      ["hat_right", "number"],
      ["hat_up", "number"],
      ["hat_down", "number"],
      ["hat", "number"],
      ["button_pressed", LiteGraph.EVENT]
    ];
  }
};
g(at, "title", "Gamepad"), g(at, "desc", "gets the input of the gamepad"), g(at, "zero", new Float32Array(2)), g(at, "buttons", [
  "a",
  "b",
  "x",
  "y",
  "lb",
  "rb",
  "lt",
  "rt",
  "back",
  "start",
  "ls",
  "rs",
  "home"
]), g(at, "mapping", {
  a: 0,
  b: 1,
  x: 2,
  y: 3,
  lb: 4,
  rb: 5,
  lt: 6,
  rt: 7,
  back: 8,
  start: 9,
  ls: 10,
  rs: 11
}), g(at, "mapping_array", [
  "a",
  "b",
  "x",
  "y",
  "lb",
  "rb",
  "lt",
  "rt",
  "back",
  "start",
  "ls",
  "rs"
]);
let GamepadInput = at;
GamepadInput.CENTER = 0;
GamepadInput.LEFT = 1;
GamepadInput.RIGHT = 2;
GamepadInput.UP = 4;
GamepadInput.DOWN = 8;
LiteGraph.registerNodeType("input/gamepad", GamepadInput);
class Converter {
  constructor() {
    this.addInput("in", 0), this.addOutput("out", 0), this.size = [80, 30];
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t != null && this.outputs)
      for (var r = 0; r < this.outputs.length; r++) {
        var s = this.outputs[r];
        if (!(!s.links || !s.links.length)) {
          var a = null;
          switch (s.name) {
            case "number":
              a = t.length ? t[0] : parseFloat(t);
              break;
            case "vec2":
            case "vec3":
            case "vec4":
              a = null;
              var o = 1;
              switch (s.name) {
                case "vec2":
                  o = 2;
                  break;
                case "vec3":
                  o = 3;
                  break;
                case "vec4":
                  o = 4;
                  break;
              }
              if (a = new Float32Array(o), t.length)
                for (var u = 0; u < t.length && u < a.length; u++)
                  a[u] = t[u];
              else
                a[0] = parseFloat(t);
              break;
          }
          this.setOutputData(r, a);
        }
      }
  }
  onGetOutputs() {
    return [
      ["number", "number"],
      ["vec2", "vec2"],
      ["vec3", "vec3"],
      ["vec4", "vec4"]
    ];
  }
}
g(Converter, "title", "Converter"), g(Converter, "desc", "type A to type B");
LiteGraph.registerNodeType("math/converter", Converter);
class Bypass {
  constructor() {
    this.addInput("in"), this.addOutput("out"), this.size = [80, 30];
  }
  onExecute() {
    var t = this.getInputData(0);
    this.setOutputData(0, t);
  }
}
g(Bypass, "title", "Bypass"), g(Bypass, "desc", "removes the type");
LiteGraph.registerNodeType("math/bypass", Bypass);
class ToNumber {
  constructor() {
    this.addInput("in"), this.addOutput("out");
  }
  onExecute() {
    var t = this.getInputData(0);
    this.setOutputData(0, Number(t));
  }
}
g(ToNumber, "title", "to Number"), g(ToNumber, "desc", "Cast to number");
LiteGraph.registerNodeType("math/to_number", ToNumber);
class MathRange {
  constructor() {
    this.addInput("in", "number", { locked: !0 }), this.addOutput("out", "number", { locked: !0 }), this.addOutput("clamped", "number", { locked: !0 }), this.addProperty("in", 0), this.addProperty("in_min", 0), this.addProperty("in_max", 1), this.addProperty("out_min", 0), this.addProperty("out_max", 1), this.size = [120, 50];
  }
  getTitle() {
    return this.flags.collapsed ? (this._last_v || 0).toFixed(2) : this.title;
  }
  onExecute() {
    let t;
    if (this.inputs)
      for (let u = 0; u < this.inputs.length; u++) {
        let h = this.inputs[u];
        t = this.getInputData(u), t !== void 0 && (this.properties[h.name] = t);
      }
    t = this.properties.in, (t == null || t.constructor !== Number) && (t = 0);
    var r = this.properties.in_min, s = this.properties.in_max, a = this.properties.out_min, o = this.properties.out_max;
    this._last_v = (t - r) / (s - r) * (o - a) + a, this.setOutputData(0, this._last_v), this.setOutputData(1, LiteGraph.clamp(this._last_v, a, o));
  }
  onDrawBackground(t) {
    this._last_v ? this.outputs[0].label = this._last_v.toFixed(3) : this.outputs[0].label = "?";
  }
  onGetInputs() {
    return [
      ["in_min", "number"],
      ["in_max", "number"],
      ["out_min", "number"],
      ["out_max", "number"]
    ];
  }
}
g(MathRange, "title", "Range"), g(MathRange, "desc", "Convert a number from one range to another");
LiteGraph.registerNodeType("math/range", MathRange);
class MathRand {
  constructor() {
    this.addOutput("value", "number"), this.addProperty("min", 0), this.addProperty("max", 1), this.size = [80, 30];
  }
  onExecute() {
    if (this.inputs)
      for (var t = 0; t < this.inputs.length; t++) {
        var r = this.inputs[t], s = this.getInputData(t);
        s !== void 0 && (this.properties[r.name] = s);
      }
    var a = this.properties.min, o = this.properties.max;
    this._last_v = Math.random() * (o - a) + a, this.setOutputData(0, this._last_v);
  }
  onDrawBackground(t) {
    this.outputs[0].label = (this._last_v || 0).toFixed(3);
  }
  onGetInputs() {
    return [
      ["min", "number"],
      ["max", "number"]
    ];
  }
}
g(MathRand, "title", "Rand"), g(MathRand, "desc", "Random number");
LiteGraph.registerNodeType("math/rand", MathRand);
const Et = class Et {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.addProperty("min", 0), this.addProperty("max", 1), this.addProperty("smooth", !0), this.addProperty("seed", 0), this.addProperty("octaves", 1), this.addProperty("persistence", 0.8), this.addProperty("speed", 1), this.size = [90, 30];
  }
  static getValue(t, r) {
    if (!Et.data) {
      Et.data = new Float32Array(1024);
      for (var s = 0; s < Et.data.length; ++s)
        Et.data[s] = Math.random();
    }
    t = t % 1024, t < 0 && (t += 1024);
    var a = Math.floor(t);
    t -= a;
    var o = Et.data[a], u = Et.data[a == 1023 ? 0 : a + 1];
    return r && (t = t * t * t * (t * (t * 6 - 15) + 10)), o * (1 - t) + u * t;
  }
  onExecute() {
    var t = this.getInputData(0) || 0, r = this.properties.octaves || 1, s = 0, a = 1, o = this.properties.seed || 0;
    t += o;
    for (var u = this.properties.speed || 1, h = 0, l = 0; l < r && (s += Et.getValue(t * (1 + l) * u, this.properties.smooth) * a, h += a, a *= this.properties.persistence, !(a < 1e-3)); ++l)
      ;
    s /= h;
    var c = this.properties.min, d = this.properties.max;
    this._last_v = s * (d - c) + c, this.setOutputData(0, this._last_v);
  }
  onDrawBackground(t) {
    this.outputs[0].label = (this._last_v || 0).toFixed(3);
  }
};
g(Et, "title", "Noise"), g(Et, "desc", "Random number with temporal continuity"), g(Et, "data", null);
let MathNoise = Et;
LiteGraph.registerNodeType("math/noise", MathNoise);
class MathSpikes {
  constructor() {
    this.addOutput("out", "number"), this.addProperty("min_time", 1), this.addProperty("max_time", 2), this.addProperty("duration", 0.2), this.size = [90, 30], this._remaining_time = 0, this._blink_time = 0;
  }
  onExecute() {
    var t = this.graph.elapsed_time;
    this._remaining_time -= t, this._blink_time -= t;
    var r = 0;
    if (this._blink_time > 0) {
      var s = this._blink_time / this.properties.duration;
      r = 1 / (Math.pow(s * 8 - 4, 4) + 1);
    }
    this._remaining_time < 0 ? (this._remaining_time = Math.random() * (this.properties.max_time - this.properties.min_time) + this.properties.min_time, this._blink_time = this.properties.duration, this.boxcolor = "#FFF") : this.boxcolor = "#000", this.setOutputData(0, r);
  }
}
LiteGraph.registerNodeType("math/spikes", MathSpikes);
class MathClamp {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.size = [80, 30], this.addProperty("min", 0), this.addProperty("max", 1);
  }
  // MathClamp.filter = "shader";
  onExecute() {
    var t = this.getInputData(0);
    t != null && (t = Math.max(this.properties.min, t), t = Math.min(this.properties.max, t), this.setOutputData(0, t));
  }
  getCode() {
    var t = "";
    return this.isInputConnected(0) && (t += "clamp({{0}}," + this.properties.min + "," + this.properties.max + ")"), t;
  }
}
g(MathClamp, "title", "Clamp"), g(MathClamp, "desc", "Clamp number between min and max");
LiteGraph.registerNodeType("math/clamp", MathClamp);
class MathLerp {
  constructor() {
    this.properties = { f: 0.5 }, this.addInput("A", "number"), this.addInput("B", "number"), this.addOutput("out", "number");
  }
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = 0);
    var r = this.getInputData(1);
    r == null && (r = 0);
    var s = this.properties.f, a = this.getInputData(2);
    a !== void 0 && (s = a), this.setOutputData(0, t * (1 - s) + r * s);
  }
  onGetInputs() {
    return [["f", "number"]];
  }
}
g(MathLerp, "title", "Lerp"), g(MathLerp, "desc", "Linear Interpolation");
LiteGraph.registerNodeType("math/lerp", MathLerp);
class MathAbs {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.size = [80, 30];
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && this.setOutputData(0, Math.abs(t));
  }
}
g(MathAbs, "title", "Abs"), g(MathAbs, "desc", "Absolute");
LiteGraph.registerNodeType("math/abs", MathAbs);
class MathFloor {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.size = [80, 30];
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && this.setOutputData(0, Math.floor(t));
  }
}
g(MathFloor, "title", "Floor"), g(MathFloor, "desc", "Floor number to remove fractional part");
LiteGraph.registerNodeType("math/floor", MathFloor);
class MathFrac {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.size = [80, 30];
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && this.setOutputData(0, t % 1);
  }
}
g(MathFrac, "title", "Frac"), g(MathFrac, "desc", "Returns fractional part");
LiteGraph.registerNodeType("math/frac", MathFrac);
class MathSmoothStep {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.size = [80, 30], this.properties = { A: 0, B: 1 };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t !== void 0) {
      var r = this.properties.A, s = this.properties.B;
      t = LiteGraph.clamp((t - r) / (s - r), 0, 1), t = t * t * (3 - 2 * t), this.setOutputData(0, t);
    }
  }
}
g(MathSmoothStep, "title", "Smoothstep"), g(MathSmoothStep, "desc", "Smoothstep");
LiteGraph.registerNodeType("math/smoothstep", MathSmoothStep);
class MathScale {
  constructor() {
    this.addInput("in", "number", { label: "" }), this.addOutput("out", "number", { label: "" }), this.size = [80, 30], this.addProperty("factor", 1);
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && this.setOutputData(0, t * this.properties.factor);
  }
}
g(MathScale, "title", "Scale"), g(MathScale, "desc", "v * factor");
LiteGraph.registerNodeType("math/scale", MathScale);
class Gate {
  constructor() {
    this.addInput("v", "boolean"), this.addInput("A"), this.addInput("B"), this.addOutput("out");
  }
  onExecute() {
    var t = this.getInputData(0);
    this.setOutputData(0, this.getInputData(t ? 1 : 2));
  }
}
g(Gate, "title", "Gate"), g(Gate, "desc", "if v is true, then outputs A, otherwise B");
LiteGraph.registerNodeType("math/gate", Gate);
class MathAverageFilter {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.size = [80, 30], this.addProperty("samples", 10), this._values = new Float32Array(10), this._current = 0;
  }
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = 0);
    var r = this._values.length;
    this._values[this._current % r] = t, this._current += 1, this._current > r && (this._current = 0);
    for (var s = 0, a = 0; a < r; ++a)
      s += this._values[a];
    this.setOutputData(0, s / r);
  }
  onPropertyChanged(t, r) {
    r < 1 && (r = 1), this.properties.samples = Math.round(r);
    var s = this._values;
    this._values = new Float32Array(this.properties.samples), s.length <= this._values.length ? this._values.set(s) : this._values.set(s.subarray(0, this._values.length));
  }
  onPropertyChanged(t, r) {
    t == "formula" && (this.code_widget.value = r);
  }
}
g(MathAverageFilter, "title", "Average"), g(MathAverageFilter, "desc", "Average Filter");
LiteGraph.registerNodeType("math/average", MathAverageFilter);
class MathTendTo {
  constructor() {
    this.addInput("in", "number"), this.addOutput("out", "number"), this.addProperty("factor", 0.1), this.size = [80, 30], this._value = null;
  }
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = 0);
    var r = this.properties.factor;
    this._value == null ? this._value = t : this._value = this._value * (1 - r) + t * r, this.setOutputData(0, this._value);
  }
}
g(MathTendTo, "title", "TendTo"), g(MathTendTo, "desc", "moves the output value always closer to the input");
LiteGraph.registerNodeType("math/tendTo", MathTendTo);
const _t = class _t {
  constructor() {
    this.addInput("A", "number,array,object"), this.addInput("B", "number"), this.addOutput("=", "number"), this.addProperty("A", 1), this.addProperty("B", 1), this.addProperty("OP", "+", "enum", { values: _t.values }), this._func = _t.funcs[this.properties.OP], this._result = [];
  }
  getTitle() {
    return this.properties.OP == "max" || this.properties.OP == "min" ? this.properties.OP + "(A,B)" : "A " + this.properties.OP + " B";
  }
  setValue(t) {
    typeof t == "string" && (t = parseFloat(t)), this.properties.value = t;
  }
  onPropertyChanged(t, r) {
    var s;
    t == "OP" && (this._func = _t.funcs[this.properties.OP], this._func || ((s = console.warn) == null || s.call(console, "Unknown operation: " + this.properties.OP), this._func = function(a) {
      return a;
    }));
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1);
    t != null ? t.constructor === Number && (this.properties.A = t) : t = this.properties.A, r != null ? this.properties.B = r : r = this.properties.B;
    var s = _t.funcs[this.properties.OP], a;
    if (t.constructor === Number)
      a = 0, a = s(t, r);
    else if (t.constructor === Array) {
      a = this._result, a.length = t.length;
      for (let o = 0; o < t.length; ++o)
        a[o] = s(t[o], r);
    } else {
      a = {};
      for (let o in t)
        a[o] = s(t[o], r);
    }
    this.setOutputData(0, a);
  }
  onDrawBackground(t) {
    this.flags.collapsed || (t.font = "40px Arial", t.fillStyle = "#666", t.textAlign = "center", t.fillText(
      this.properties.OP,
      this.size[0] * 0.5,
      (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5
    ), t.textAlign = "left");
  }
};
g(_t, "title", "Operation"), g(_t, "desc", "Easy math operators"), g(_t, "values", ["+", "-", "*", "/", "%", "^", "max", "min"]), g(_t, "funcs", {
  "+": function(t, r) {
    return t + r;
  },
  "-": function(t, r) {
    return t - r;
  },
  x: function(t, r) {
    return t * r;
  },
  X: function(t, r) {
    return t * r;
  },
  "*": function(t, r) {
    return t * r;
  },
  "/": function(t, r) {
    return t / r;
  },
  "%": function(t, r) {
    return t % r;
  },
  "^": function(t, r) {
    return Math.pow(t, r);
  },
  max: function(t, r) {
    return Math.max(t, r);
  },
  min: function(t, r) {
    return Math.min(t, r);
  }
}), g(_t, "@OP", {
  type: "enum",
  title: "operation",
  values: _t.values
}), g(_t, "size", [100, 60]);
let MathOperation = _t;
LiteGraph.registerNodeType("math/operation", MathOperation);
LiteGraph.registerSearchboxExtra("math/operation", "MAX", {
  properties: { OP: "max" },
  title: "MAX()"
});
LiteGraph.registerSearchboxExtra("math/operation", "MIN", {
  properties: { OP: "min" },
  title: "MIN()"
});
class MathCompare {
  constructor() {
    this.addInput("A", "number"), this.addInput("B", "number"), this.addOutput("A==B", "boolean"), this.addOutput("A!=B", "boolean"), this.addProperty("A", 0), this.addProperty("B", 0);
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1);
    t !== void 0 ? this.properties.A = t : t = this.properties.A, r !== void 0 ? this.properties.B = r : r = this.properties.B;
    for (var s = 0, a = this.outputs.length; s < a; ++s) {
      var o = this.outputs[s];
      if (!(!o.links || !o.links.length)) {
        var u;
        switch (o.name) {
          case "A==B":
            u = t == r;
            break;
          case "A!=B":
            u = t != r;
            break;
          case "A>B":
            u = t > r;
            break;
          case "A<B":
            u = t < r;
            break;
          case "A<=B":
            u = t <= r;
            break;
          case "A>=B":
            u = t >= r;
            break;
        }
        this.setOutputData(s, u);
      }
    }
  }
  onGetOutputs() {
    return [
      ["A==B", "boolean"],
      ["A!=B", "boolean"],
      ["A>B", "boolean"],
      ["A<B", "boolean"],
      ["A>=B", "boolean"],
      ["A<=B", "boolean"]
    ];
  }
}
g(MathCompare, "title", "Compare"), g(MathCompare, "desc", "compares between two values");
LiteGraph.registerNodeType("math/compare", MathCompare);
LiteGraph.registerSearchboxExtra("math/compare", "==", {
  outputs: [["A==B", "boolean"]],
  title: "A==B"
});
LiteGraph.registerSearchboxExtra("math/compare", "!=", {
  outputs: [["A!=B", "boolean"]],
  title: "A!=B"
});
LiteGraph.registerSearchboxExtra("math/compare", ">", {
  outputs: [["A>B", "boolean"]],
  title: "A>B"
});
LiteGraph.registerSearchboxExtra("math/compare", "<", {
  outputs: [["A<B", "boolean"]],
  title: "A<B"
});
LiteGraph.registerSearchboxExtra("math/compare", ">=", {
  outputs: [["A>=B", "boolean"]],
  title: "A>=B"
});
LiteGraph.registerSearchboxExtra("math/compare", "<=", {
  outputs: [["A<=B", "boolean"]],
  title: "A<=B"
});
const Ut = class Ut {
  constructor() {
    this.addInput("A", "number"), this.addInput("B", "number"), this.addOutput("true", "boolean"), this.addOutput("false", "boolean"), this.addProperty("A", 1), this.addProperty("B", 1), this.addProperty("OP", ">", "enum", { values: Ut.values }), this.addWidget("combo", "Cond.", this.properties.OP, {
      property: "OP",
      values: Ut.values
    }), this.size = [80, 60];
  }
  getTitle() {
    return "A " + this.properties.OP + " B";
  }
  onExecute() {
    var t = this.getInputData(0);
    t === void 0 ? t = this.properties.A : this.properties.A = t;
    var r = this.getInputData(1);
    r === void 0 ? r = this.properties.B : this.properties.B = r;
    var s = !0;
    switch (this.properties.OP) {
      case ">":
        s = t > r;
        break;
      case "<":
        s = t < r;
        break;
      case "==":
        s = t == r;
        break;
      case "!=":
        s = t != r;
        break;
      case "<=":
        s = t <= r;
        break;
      case ">=":
        s = t >= r;
        break;
      case "||":
        s = t || r;
        break;
      case "&&":
        s = t && r;
        break;
    }
    this.setOutputData(0, s), this.setOutputData(1, !s);
  }
};
g(Ut, "title", "Condition"), g(Ut, "desc", "evaluates condition between A and B"), g(Ut, "values", [">", "<", "==", "!=", "<=", ">=", "||", "&&"]), g(Ut, "@OP", {
  type: "enum",
  title: "operation",
  values: Ut.values
});
let MathCondition = Ut;
LiteGraph.registerNodeType("math/condition", MathCondition);
class MathBranch {
  constructor() {
    this.addInput("in", 0), this.addInput("cond", "boolean"), this.addOutput("true", 0), this.addOutput("false", 0), this.size = [80, 60];
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1);
    r ? (this.setOutputData(0, t), this.setOutputData(1, null)) : (this.setOutputData(0, null), this.setOutputData(1, t));
  }
}
g(MathBranch, "title", "Branch"), g(MathBranch, "desc", "If condition is true, outputs IN in true, otherwise in false");
LiteGraph.registerNodeType("math/branch", MathBranch);
class MathAccumulate {
  constructor() {
    this.addInput("inc", "number"), this.addOutput("total", "number"), this.addProperty("increment", 1), this.addProperty("value", 0);
  }
  onExecute() {
    this.properties.value === null && (this.properties.value = 0);
    var t = this.getInputData(0);
    t !== null ? this.properties.value += t : this.properties.value += this.properties.increment, this.setOutputData(0, this.properties.value);
  }
}
g(MathAccumulate, "title", "Accumulate"), g(MathAccumulate, "desc", "Increments a value every time");
LiteGraph.registerNodeType("math/accumulate", MathAccumulate);
class MathTrigonometry {
  constructor() {
    this.addInput("v", "number"), this.addOutput("sin", "number"), this.addProperty("amplitude", 1), this.addProperty("offset", 0), this.bgImageUrl = "nodes/imgs/icon-sin.png";
  }
  // MathTrigonometry.filter = "shader";
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = 0);
    var r = this.properties.amplitude, s = this.findInputSlot("amplitude");
    s != -1 && (r = this.getInputData(s));
    var a = this.properties.offset;
    s = this.findInputSlot("offset"), s != -1 && (a = this.getInputData(s));
    for (var o = 0, u = this.outputs.length; o < u; ++o) {
      var h = this.outputs[o], l;
      switch (h.name) {
        case "sin":
          l = Math.sin(t);
          break;
        case "cos":
          l = Math.cos(t);
          break;
        case "tan":
          l = Math.tan(t);
          break;
        case "asin":
          l = Math.asin(t);
          break;
        case "acos":
          l = Math.acos(t);
          break;
        case "atan":
          l = Math.atan(t);
          break;
      }
      this.setOutputData(o, r * l + a);
    }
  }
  onGetInputs() {
    return [
      ["v", "number"],
      ["amplitude", "number"],
      ["offset", "number"]
    ];
  }
  onGetOutputs() {
    return [
      ["sin", "number"],
      ["cos", "number"],
      ["tan", "number"],
      ["asin", "number"],
      ["acos", "number"],
      ["atan", "number"]
    ];
  }
}
g(MathTrigonometry, "title", "Trigonometry"), g(MathTrigonometry, "desc", "Sin Cos Tan");
LiteGraph.registerNodeType("math/trigonometry", MathTrigonometry);
LiteGraph.registerSearchboxExtra("math/trigonometry", "SIN()", {
  outputs: [["sin", "number"]],
  title: "SIN()"
});
LiteGraph.registerSearchboxExtra("math/trigonometry", "COS()", {
  outputs: [["cos", "number"]],
  title: "COS()"
});
LiteGraph.registerSearchboxExtra("math/trigonometry", "TAN()", {
  outputs: [["tan", "number"]],
  title: "TAN()"
});
class MathFormula {
  constructor() {
    this.addInput("x", "number"), this.addInput("y", "number"), this.addOutput("", "number"), this.properties = { x: 1, y: 1, formula: "x+y" }, this.code_widget = this.addWidget(
      "text",
      "F(x,y)",
      this.properties.formula,
      function(t, r, s) {
        s.properties.formula = t;
      }
    ), this.addWidget("toggle", "allow", LiteGraph.allow_scripts, function(t) {
      LiteGraph.allow_scripts = t;
    }), this._func = null;
  }
  onExecute() {
    if (LiteGraph.allow_scripts) {
      var t = this.getInputData(0), r = this.getInputData(1);
      t != null ? this.properties.x = t : t = this.properties.x, r != null ? this.properties.y = r : r = this.properties.y;
      var s;
      try {
        (!this._func || this._func_code != this.properties.formula) && (this._func = new Function(
          "x",
          "y",
          "TIME",
          "return " + this.properties.formula
        ), this._func_code = this.properties.formula), s = this._func(t, r, this.graph.globaltime), this.boxcolor = null;
      } catch {
        this.boxcolor = "red";
      }
      this.setOutputData(0, s);
    }
  }
  getTitle() {
    return this._func_code || "Formula";
  }
  onDrawBackground() {
    var t = this.properties.formula;
    this.outputs && this.outputs.length && (this.outputs[0].label = t);
  }
}
g(MathFormula, "title", "Formula"), g(MathFormula, "desc", "Compute formula"), g(MathFormula, "size", [160, 100]);
LiteGraph.registerNodeType("math/formula", MathFormula);
class Math3DVec2ToXY {
  constructor() {
    this.addInput("vec2", "vec2"), this.addOutput("x", "number"), this.addOutput("y", "number");
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (this.setOutputData(0, t[0]), this.setOutputData(1, t[1]));
  }
}
g(Math3DVec2ToXY, "title", "Vec2->XY"), g(Math3DVec2ToXY, "desc", "vector 2 to components");
LiteGraph.registerNodeType("math3d/vec2-to-xy", Math3DVec2ToXY);
class Math3DXYToVec2 {
  constructor() {
    this.addInputs([
      ["x", "number"],
      ["y", "number"]
    ]), this.addOutput("vec2", "vec2"), this.properties = { x: 0, y: 0 }, this._data = new Float32Array(2);
  }
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = this.properties.x);
    var r = this.getInputData(1);
    r == null && (r = this.properties.y);
    var s = this._data;
    s[0] = t, s[1] = r, this.setOutputData(0, s);
  }
}
g(Math3DXYToVec2, "title", "XY->Vec2"), g(Math3DXYToVec2, "desc", "components to vector2");
LiteGraph.registerNodeType("math3d/xy-to-vec2", Math3DXYToVec2);
class Math3DVec3ToXYZ {
  constructor() {
    this.addInput("vec3", "vec3"), this.addOutput("x", "number"), this.addOutput("y", "number"), this.addOutput("z", "number");
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (this.setOutputData(0, t[0]), this.setOutputData(1, t[1]), this.setOutputData(2, t[2]));
  }
}
g(Math3DVec3ToXYZ, "title", "Vec3->XYZ"), g(Math3DVec3ToXYZ, "desc", "vector 3 to components");
LiteGraph.registerNodeType("math3d/vec3-to-xyz", Math3DVec3ToXYZ);
class Math3DXYZToVec3 {
  constructor() {
    this.addInputs([
      ["x", "number"],
      ["y", "number"],
      ["z", "number"]
    ]), this.addOutput("vec3", "vec3"), this.properties = { x: 0, y: 0, z: 0 }, this._data = new Float32Array(3);
  }
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = this.properties.x);
    var r = this.getInputData(1);
    r == null && (r = this.properties.y);
    var s = this.getInputData(2);
    s == null && (s = this.properties.z);
    var a = this._data;
    a[0] = t, a[1] = r, a[2] = s, this.setOutputData(0, a);
  }
}
g(Math3DXYZToVec3, "title", "XYZ->Vec3"), g(Math3DXYZToVec3, "desc", "components to vector3");
LiteGraph.registerNodeType("math3d/xyz-to-vec3", Math3DXYZToVec3);
class Math3DVec4ToXYZW {
  constructor() {
    this.addInput("vec4", "vec4"), this.addOutput("x", "number"), this.addOutput("y", "number"), this.addOutput("z", "number"), this.addOutput("w", "number");
  }
  onExecute() {
    var t = this.getInputData(0);
    t != null && (this.setOutputData(0, t[0]), this.setOutputData(1, t[1]), this.setOutputData(2, t[2]), this.setOutputData(3, t[3]));
  }
}
g(Math3DVec4ToXYZW, "title", "Vec4->XYZW"), g(Math3DVec4ToXYZW, "desc", "vector 4 to components");
LiteGraph.registerNodeType("math3d/vec4-to-xyzw", Math3DVec4ToXYZW);
class Math3DXYZWToVec4 {
  constructor() {
    this.addInputs([
      ["x", "number"],
      ["y", "number"],
      ["z", "number"],
      ["w", "number"]
    ]), this.addOutput("vec4", "vec4"), this.properties = { x: 0, y: 0, z: 0, w: 0 }, this._data = new Float32Array(4);
  }
  onExecute() {
    var t = this.getInputData(0);
    t == null && (t = this.properties.x);
    var r = this.getInputData(1);
    r == null && (r = this.properties.y);
    var s = this.getInputData(2);
    s == null && (s = this.properties.z);
    var a = this.getInputData(3);
    a == null && (a = this.properties.w);
    var o = this._data;
    o[0] = t, o[1] = r, o[2] = s, o[3] = a, this.setOutputData(0, o);
  }
}
g(Math3DXYZWToVec4, "title", "XYZW->Vec4"), g(Math3DXYZWToVec4, "desc", "components to vector4");
LiteGraph.registerNodeType("math3d/xyzw-to-vec4", Math3DXYZWToVec4);
const DEG2RAD$1 = 0.0174532925, $t = class $t {
  constructor() {
    this.addInput("T", "vec3"), this.addInput("R", "vec3"), this.addInput("S", "vec3"), this.addOutput("mat4", "mat4"), this.properties = {
      T: [0, 0, 0],
      R: [0, 0, 0],
      S: [1, 1, 1],
      R_in_degrees: !0
    }, this._result = mat4.create(), this._must_update = !0;
  }
  onPropertyChanged(t, r) {
    this._must_update = !0;
  }
  onExecute() {
    var t = this._result, r = $t.temp_quat, s = $t.temp_mat4, a = $t.temp_vec3, o = this.getInputData(0), u = this.getInputData(1), h = this.getInputData(2);
    (this._must_update || o || u || h) && (o = o || this.properties.T, u = u || this.properties.R, h = h || this.properties.S, mat4.identity(t), mat4.translate(t, t, o), this.properties.R_in_degrees ? (a.set(u), vec3.scale(a, a, DEG2RAD$1), quat.fromEuler(r, a)) : quat.fromEuler(r, u), mat4.fromQuat(s, r), mat4.multiply(t, t, s), mat4.scale(t, t, h)), this.setOutputData(0, t);
  }
};
g($t, "title", "mat4"), g($t, "temp_quat", new Float32Array([0, 0, 0, 1])), g($t, "temp_mat4", new Float32Array(16)), g($t, "temp_vec3", new Float32Array(3));
let Math3DMat4 = $t;
LiteGraph.registerNodeType("math3d/mat4", Math3DMat4);
const zt = class zt {
  constructor() {
    this.addInput("A", "number,vec3"), this.addInput("B", "number,vec3"), this.addOutput("=", "number,vec3"), this.addProperty("OP", "+", "enum", { values: zt.values }), this._result = vec3.create();
  }
  getTitle() {
    return this.properties.OP == "max" || this.properties.OP == "min" ? this.properties.OP + "(A,B)" : "A " + this.properties.OP + " B";
  }
  onExecute() {
    var a;
    var t = this.getInputData(0), r = this.getInputData(1);
    if (!(t == null || r == null)) {
      t.constructor === Number && (t = [t, t, t]), r.constructor === Number && (r = [r, r, r]);
      var s = this._result;
      switch (this.properties.OP) {
        case "+":
          s = vec3.add(s, t, r);
          break;
        case "-":
          s = vec3.sub(s, t, r);
          break;
        case "x":
        case "X":
        case "*":
          s = vec3.mul(s, t, r);
          break;
        case "/":
          s = vec3.div(s, t, r);
          break;
        case "%":
          s[0] = t[0] % r[0], s[1] = t[1] % r[1], s[2] = t[2] % r[2];
          break;
        case "^":
          s[0] = Math.pow(t[0], r[0]), s[1] = Math.pow(t[1], r[1]), s[2] = Math.pow(t[2], r[2]);
          break;
        case "max":
          s[0] = Math.max(t[0], r[0]), s[1] = Math.max(t[1], r[1]), s[2] = Math.max(t[2], r[2]);
          break;
        case "min":
          s[0] = Math.min(t[0], r[0]), s[1] = Math.min(t[1], r[1]), s[2] = Math.min(t[2], r[2]);
          break;
        case "dot":
          s = vec3.dot(t, r);
          break;
        case "cross":
          vec3.cross(s, t, r);
          break;
        default:
          (a = console.warn) == null || a.call(console, "Unknown operation: " + this.properties.OP);
      }
      this.setOutputData(0, s);
    }
  }
  onDrawBackground(t) {
    this.flags.collapsed || (t.font = "40px Arial", t.fillStyle = "#666", t.textAlign = "center", t.fillText(
      this.properties.OP,
      this.size[0] * 0.5,
      (this.size[1] + LiteGraph.NODE_TITLE_HEIGHT) * 0.5
    ), t.textAlign = "left");
  }
};
g(zt, "title", "Operation"), g(zt, "desc", "Easy math 3D operators"), g(zt, "values", [
  "+",
  "-",
  "*",
  "/",
  "%",
  "^",
  "max",
  "min",
  "dot",
  "cross"
]), g(zt, "@OP", {
  type: "enum",
  title: "operation",
  values: zt.values
}), g(zt, "size", [100, 60]);
let Math3DOperation = zt;
LiteGraph.registerSearchboxExtra("math3d/operation", "CROSS()", {
  properties: { OP: "cross" },
  title: "CROSS()"
});
LiteGraph.registerSearchboxExtra("math3d/operation", "DOT()", {
  properties: { OP: "dot" },
  title: "DOT()"
});
LiteGraph.registerNodeType("math3d/operation", Math3DOperation);
class Math3DVec3Scale {
  constructor() {
    this.addInput("in", "vec3"), this.addInput("f", "number"), this.addOutput("out", "vec3"), this.properties = { f: 1 }, this._data = new Float32Array(3);
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t != null) {
      var r = this.getInputData(1);
      r == null && (r = this.properties.f);
      var s = this._data;
      s[0] = t[0] * r, s[1] = t[1] * r, s[2] = t[2] * r, this.setOutputData(0, s);
    }
  }
}
g(Math3DVec3Scale, "title", "vec3_scale"), g(Math3DVec3Scale, "desc", "scales the components of a vec3");
LiteGraph.registerNodeType("math3d/vec3-scale", Math3DVec3Scale);
class Math3DVec3Length {
  constructor() {
    this.addInput("in", "vec3"), this.addOutput("out", "number");
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t != null) {
      var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
      this.setOutputData(0, r);
    }
  }
}
g(Math3DVec3Length, "title", "vec3_length"), g(Math3DVec3Length, "desc", "returns the module of a vector");
LiteGraph.registerNodeType("math3d/vec3-length", Math3DVec3Length);
class Math3DVec3Normalize {
  constructor() {
    this.addInput("in", "vec3"), this.addOutput("out", "vec3"), this._data = new Float32Array(3);
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t != null) {
      var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]), s = this._data;
      s[0] = t[0] / r, s[1] = t[1] / r, s[2] = t[2] / r, this.setOutputData(0, s);
    }
  }
}
g(Math3DVec3Normalize, "title", "vec3_normalize"), g(Math3DVec3Normalize, "desc", "returns the vector normalized");
LiteGraph.registerNodeType("math3d/vec3-normalize", Math3DVec3Normalize);
class Math3DVec3Lerp {
  constructor() {
    this.addInput("A", "vec3"), this.addInput("B", "vec3"), this.addInput("f", "vec3"), this.addOutput("out", "vec3"), this.properties = { f: 0.5 }, this._data = new Float32Array(3);
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t != null) {
      var r = this.getInputData(1);
      if (r != null) {
        var s = this.getInputOrProperty("f"), a = this._data;
        a[0] = t[0] * (1 - s) + r[0] * s, a[1] = t[1] * (1 - s) + r[1] * s, a[2] = t[2] * (1 - s) + r[2] * s, this.setOutputData(0, a);
      }
    }
  }
}
g(Math3DVec3Lerp, "title", "vec3_lerp"), g(Math3DVec3Lerp, "desc", "returns the interpolated vector");
LiteGraph.registerNodeType("math3d/vec3-lerp", Math3DVec3Lerp);
class Math3DVec3Dot {
  constructor() {
    this.addInput("A", "vec3"), this.addInput("B", "vec3"), this.addOutput("out", "number");
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t != null) {
      var r = this.getInputData(1);
      if (r != null) {
        var s = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
        this.setOutputData(0, s);
      }
    }
  }
}
g(Math3DVec3Dot, "title", "vec3_dot"), g(Math3DVec3Dot, "desc", "returns the dot product");
LiteGraph.registerNodeType("math3d/vec3-dot", Math3DVec3Dot);
var Ce;
if (glMatrix) {
  class n {
    constructor() {
      this.addOutput("quat", "quat"), this.properties = { x: 0, y: 0, z: 0, w: 1, normalize: !1 }, this._value = quat.create();
    }
    onExecute() {
      this._value[0] = this.getInputOrProperty("x"), this._value[1] = this.getInputOrProperty("y"), this._value[2] = this.getInputOrProperty("z"), this._value[3] = this.getInputOrProperty("w"), this.properties.normalize && quat.normalize(this._value, this._value), this.setOutputData(0, this._value);
    }
    onGetInputs() {
      return [
        ["x", "number"],
        ["y", "number"],
        ["z", "number"],
        ["w", "number"]
      ];
    }
  }
  g(n, "title", "Quaternion"), g(n, "desc", "quaternion"), LiteGraph.registerNodeType("math3d/quaternion", n);
  class t {
    constructor() {
      this.addInputs([
        ["degrees", "number"],
        ["axis", "vec3"]
      ]), this.addOutput("quat", "quat"), this.properties = { angle: 90, axis: vec3.fromValues(0, 1, 0) }, this._value = quat.create();
    }
    onExecute() {
      var c = this.getInputData(0);
      c == null && (c = this.properties.angle);
      var d = this.getInputData(1);
      d == null && (d = this.properties.axis);
      var f = quat.setAxisAngle(this._value, d, c * 0.0174532925);
      this.setOutputData(0, f);
    }
  }
  g(t, "title", "Rotation"), g(t, "desc", "quaternion rotation"), LiteGraph.registerNodeType("math3d/rotation", t);
  class r {
    constructor() {
      this.addInput("euler", "vec3"), this.addOutput("quat", "quat"), this.properties = { euler: [0, 0, 0], use_yaw_pitch_roll: !1 }, this._degs = vec3.create(), this._value = quat.create();
    }
    onExecute() {
      var c = this.getInputData(0);
      c == null && (c = this.properties.euler), vec3.scale(this._degs, c, DEG2RAD$1), this.properties.use_yaw_pitch_roll && (this._degs = [this._degs[2], this._degs[0], this._degs[1]]);
      var d = quat.fromEuler(this._value, this._degs);
      this.setOutputData(0, d);
    }
  }
  g(r, "title", "Euler->Quat"), g(r, "desc", "Converts euler angles (in degrees) to quaternion"), LiteGraph.registerNodeType("math3d/euler_to_quat", r);
  class s {
    constructor() {
      this.addInput(["quat", "quat"]), this.addOutput("euler", "vec3"), this._value = vec3.create();
    }
    onExecute() {
      var c = this.getInputData(0);
      c && (quat.toEuler(this._value, c), vec3.scale(this._value, this._value, DEG2RAD$1), this.setOutputData(0, this._value));
    }
  }
  g(s, "title", "Euler->Quat"), g(s, "desc", "Converts rotX,rotY,rotZ in degrees to quat"), LiteGraph.registerNodeType("math3d/quat_to_euler", s);
  class a {
    constructor() {
      this.addInputs([
        ["vec3", "vec3"],
        ["quat", "quat"]
      ]), this.addOutput("result", "vec3"), this.properties = { vec: [0, 0, 1] };
    }
    onExecute() {
      var c = this.getInputData(0);
      c == null && (c = this.properties.vec);
      var d = this.getInputData(1);
      d == null ? this.setOutputData(c) : this.setOutputData(0, vec3.transformQuat(vec3.create(), c, d));
    }
  }
  g(a, "title", "Rot. Vec3"), g(a, "desc", "rotate a point"), LiteGraph.registerNodeType("math3d/rotate_vec3", a);
  class o {
    constructor() {
      this.addInputs([
        ["A", "quat"],
        ["B", "quat"]
      ]), this.addOutput("A*B", "quat"), this._value = quat.create();
    }
    onExecute() {
      var c = this.getInputData(0);
      if (c != null) {
        var d = this.getInputData(1);
        if (d != null) {
          var f = quat.multiply(this._value, c, d);
          this.setOutputData(0, f);
        }
      }
    }
  }
  g(o, "title", "Mult. Quat"), g(o, "desc", "rotate quaternion"), LiteGraph.registerNodeType("math3d/mult-quat", o);
  class u {
    constructor() {
      this.addInputs([
        ["A", "quat"],
        ["B", "quat"],
        ["factor", "number"]
      ]), this.addOutput("slerp", "quat"), this.addProperty("factor", 0.5), this._value = quat.create();
    }
    onExecute() {
      var c = this.getInputData(0);
      if (c != null) {
        var d = this.getInputData(1);
        if (d != null) {
          var f = this.properties.factor;
          this.getInputData(2) != null && (f = this.getInputData(2));
          var _ = quat.slerp(this._value, c, d, f);
          this.setOutputData(0, _);
        }
      }
    }
  }
  g(u, "title", "Quat Slerp"), g(u, "desc", "quaternion spherical interpolation"), LiteGraph.registerNodeType("math3d/quat-slerp", u);
  class h {
    constructor() {
      this.addInput("vec3", "vec3"), this.addOutput("remap", "vec3"), this.addOutput("clamped", "vec3"), this.properties = {
        clamp: !0,
        range_min: [-1, -1, 0],
        range_max: [1, 1, 0],
        target_min: [-1, -1, 0],
        target_max: [1, 1, 0]
      }, this._value = vec3.create(), this._clamped = vec3.create();
    }
    onExecute() {
      var c = this.getInputData(0);
      c && this._value.set(c);
      for (var d = this.properties.range_min, f = this.properties.range_max, _ = this.properties.target_min, E = this.properties.target_max, m = 0; m < 3; ++m) {
        var T = f[m] - d[m];
        if (this._clamped[m] = LiteGraph.clamp(
          this._value[m],
          d[m],
          f[m]
        ), T == 0) {
          this._value[m] = (_[m] + E[m]) * 0.5;
          continue;
        }
        var L = (this._value[m] - d[m]) / T;
        this.properties.clamp && (L = LiteGraph.clamp(L, 0, 1));
        var G = E[m] - _[m];
        this._value[m] = _[m] + L * G;
      }
      this.setOutputData(0, this._value), this.setOutputData(1, this._clamped);
    }
  }
  g(h, "title", "Remap Range"), g(h, "desc", "remap a 3D range"), LiteGraph.registerNodeType("math3d/remap_range", h);
} else LiteGraph.debug && ((Ce = console.warn) == null || Ce.call(console, "No glmatrix found, some Math3D nodes may not work"));
function toString(n) {
  if (n && n.constructor === Object)
    try {
      return JSON.stringify(n);
    } catch {
      return String(n);
    }
  return String(n);
}
LiteGraph.wrapFunctionAsNode("string/toString", toString, [""], "string");
function compare(n, t) {
  return n == t;
}
LiteGraph.wrapFunctionAsNode(
  "string/compare",
  compare,
  ["string", "string"],
  "boolean"
);
function concatenate(n, t) {
  return n === void 0 ? t : t === void 0 ? n : n + "" + t;
}
LiteGraph.wrapFunctionAsNode(
  "string/concatenate",
  concatenate,
  ["string", "string"],
  "string"
);
function contains(n, t) {
  return n === void 0 || t === void 0 ? !1 : n.indexOf(t) != -1;
}
LiteGraph.wrapFunctionAsNode(
  "string/contains",
  contains,
  ["string", "string"],
  "boolean"
);
function toUpperCase(n) {
  return n != null && n.constructor === String ? n.toUpperCase() : n;
}
LiteGraph.wrapFunctionAsNode(
  "string/toUpperCase",
  toUpperCase,
  ["string"],
  "string"
);
function split(n, t) {
  if (t == null && (t = this.properties.separator), n == null) return [];
  if (n.constructor === String) return n.split(t || " ");
  if (n.constructor === Array) {
    for (var r = [], s = 0; s < n.length; ++s)
      typeof n[s] == "string" && (r[s] = n[s].split(t || " "));
    return r;
  }
  return null;
}
LiteGraph.wrapFunctionAsNode(
  "string/split",
  split,
  ["string,array", "string"],
  "array",
  { separator: "," }
);
function toFixed(n) {
  return n != null && n.constructor === Number ? n.toFixed(this.properties.precision) : n;
}
LiteGraph.wrapFunctionAsNode("string/toFixed", toFixed, ["number"], "string", { precision: 0 });
class StringToTable {
  constructor() {
    this.addInput("", "string"), this.addOutput("table", "table"), this.addOutput("rows", "number"), this.addProperty("value", ""), this.addProperty("separator", ","), this._table = null;
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      var r = this.properties.separator || ",";
      (t != this._str || r != this._last_separator) && (this._last_separator = r, this._str = t, this._table = t.split(`
`).map(function(s) {
        return s.trim().split(r);
      })), this.setOutputData(0, this._table), this.setOutputData(1, this._table ? this._table.length : 0);
    }
  }
}
g(StringToTable, "title", "toTable"), g(StringToTable, "desc", "Splits a string to table");
LiteGraph.registerNodeType("string/toTable", StringToTable);
class Selector {
  constructor() {
    this.addInput("sel", "number"), this.addInput("A"), this.addInput("B"), this.addInput("C"), this.addInput("D"), this.addOutput("out"), this.selected = 0;
  }
  onDrawBackground(t) {
    if (!this.flags.collapsed) {
      t.fillStyle = "#AFB";
      var r = (this.selected + 1) * LiteGraph.NODE_SLOT_HEIGHT + 6;
      t.beginPath(), t.moveTo(50, r), t.lineTo(50, r + LiteGraph.NODE_SLOT_HEIGHT), t.lineTo(34, r + LiteGraph.NODE_SLOT_HEIGHT * 0.5), t.fill();
    }
  }
  onExecute() {
    var t = this.getInputData(0);
    (t == null || t.constructor !== Number) && (t = 0), this.selected = t = Math.round(t) % (this.inputs.length - 1);
    var r = this.getInputData(t + 1);
    r !== void 0 && this.setOutputData(0, r);
  }
  onGetInputs() {
    return [
      ["E", 0],
      ["F", 0],
      ["G", 0],
      ["H", 0]
    ];
  }
}
g(Selector, "title", "Selector"), g(Selector, "desc", "selects an output");
LiteGraph.registerNodeType("logic/selector", Selector);
class Sequence {
  constructor() {
    this.properties = { sequence: "A,B,C" }, this.addInput("index", "number"), this.addInput("seq"), this.addOutput("out"), this.index = 0, this.values = this.properties.sequence.split(",");
  }
  onPropertyChanged(t, r) {
    t == "sequence" && (this.values = r.split(","));
  }
  onExecute() {
    var t = this.getInputData(1);
    t && t != this.current_sequence && (this.values = t.split(","), this.current_sequence = t);
    var r = this.getInputData(0);
    r == null && (r = 0), this.index = r = Math.round(r) % this.values.length, this.setOutputData(0, this.values[r]);
  }
}
g(Sequence, "title", "Sequence"), g(Sequence, "desc", "select one element from a sequence from a string");
LiteGraph.registerNodeType("logic/sequence", Sequence);
class logicAnd {
  constructor() {
    this.properties = {}, this.addInput("a", "boolean"), this.addInput("b", "boolean"), this.addOutput("out", "boolean");
  }
  onExecute() {
    let t = !0;
    for (let r in this.inputs)
      if (!this.getInputData(r)) {
        t = !1;
        break;
      }
    this.setOutputData(0, t);
  }
  onGetInputs() {
    return [["and", "boolean"]];
  }
}
g(logicAnd, "title", "AND"), g(logicAnd, "desc", "Return true if all inputs are true");
LiteGraph.registerNodeType("logic/AND", logicAnd);
class logicOr {
  constructor() {
    this.properties = {}, this.addInput("a", "boolean"), this.addInput("b", "boolean"), this.addOutput("out", "boolean");
  }
  onExecute() {
    var t = !1;
    for (var r in this.inputs)
      if (this.getInputData(r)) {
        t = !0;
        break;
      }
    this.setOutputData(0, t);
  }
  onGetInputs() {
    return [["or", "boolean"]];
  }
}
g(logicOr, "title", "OR"), g(logicOr, "desc", "Return true if at least one input is true");
LiteGraph.registerNodeType("logic/OR", logicOr);
class logicNot {
  constructor() {
    this.properties = {}, this.addInput("in", "boolean"), this.addOutput("out", "boolean");
  }
  onExecute() {
    var t = !this.getInputData(0);
    this.setOutputData(0, t);
  }
}
g(logicNot, "title", "NOT"), g(logicNot, "desc", "Return the logical negation");
LiteGraph.registerNodeType("logic/NOT", logicNot);
class logicCompare {
  constructor() {
    this.properties = {}, this.addInput("a", "boolean"), this.addInput("b", "boolean"), this.addOutput("out", "boolean");
  }
  onExecute() {
    var t = null, r = !0;
    for (var s in this.inputs)
      if (t === null) t = this.getInputData(s);
      else if (t != this.getInputData(s)) {
        r = !1;
        break;
      }
    this.setOutputData(0, r);
  }
  onGetInputs() {
    return [["bool", "boolean"]];
  }
}
g(logicCompare, "title", "bool == bool"), g(logicCompare, "desc", "Compare for logical equality");
LiteGraph.registerNodeType("logic/CompareBool", logicCompare);
class logicBranch {
  // @BUG: Seems to always execute false branch
  constructor() {
    this.properties = {}, this.addInput("onTrigger", LiteGraph.ACTION), this.addInput("condition", "boolean"), this.addOutput("true", LiteGraph.EVENT), this.addOutput("false", LiteGraph.EVENT), this.mode = LiteGraph.ON_TRIGGER;
  }
  onExecute(t, r) {
    var s = this.getInputData(1);
    s ? this.triggerSlot(0) : this.triggerSlot(1);
  }
}
g(logicBranch, "title", "Branch"), g(logicBranch, "desc", "Branch execution on condition");
LiteGraph.registerNodeType("logic/IF", logicBranch);
class logicFor {
  constructor() {
    this.properties = {}, this.addInput("start", "number"), this.addInput("nElements", "number"), this.addInput("do", LiteGraph.ACTION), this.addInput("break", LiteGraph.ACTION), this.addOutput("do", LiteGraph.EVENT), this.addOutput("index", "number"), this.started = !1, this.stopped = !1;
  }
  onExecute(t) {
    var o, u;
    if (this.started) {
      for (var r = this.getInputData(0), s = this.getInputData(1), a = r; a < r + s; a++) {
        if ((o = console.debug) == null || o.call(console, "for cycle " + a), this.triggerSlot(0, t), this.stopped) {
          (u = console.debug) == null || u.call(console, "for cycle stopped on index " + a);
          break;
        }
        this.setOutputData(1, a);
      }
      this.started = !1, this.stopped = !0;
    }
  }
  onAction(t) {
    switch (t) {
      case "break":
        this.stopped = !0;
        break;
      /* case "reset":
          this.stopped = false;
      break;*/
      case "do":
        this.started = !0, this.stopped = !1, this.execute();
        break;
    }
  }
}
g(logicFor, "title", "FOR"), g(logicFor, "desc", "Cycle FOR");
LiteGraph.registerNodeType("logic/CycleFOR", logicFor);
class logicWhile {
  constructor() {
    this.properties = { cycleLimit: 999, checkOnStart: !0 }, this.addInput("do", LiteGraph.ACTION), this.addInput("condition", "boolean"), this.addInput("break", LiteGraph.ACTION), this.addOutput("do", LiteGraph.EVENT), this.addOutput("index", "number"), this.started = !1, this.stopped = !1, this.k = 0, this.cond = !1, this.addWidget("toggle", "checkOnStart", this.properties.checkOnStart, "checkOnStart");
  }
  onExecute() {
    this.setOutputData(1, this.k), this.cond = this.getInputData(1);
  }
  onAction(t, r) {
    var a, o;
    switch (t) {
      case "break":
        this.stopped = !0;
        break;
      case "do":
        this.started = !0, this.stopped = !1;
        var s = this.getInputOrProperty("checkOnStart");
        for (this.cond = !s || this.getInputData(1), this.k = 0, cycleLimit = this.properties.cycleLimit || 999; this.cond && this.k < cycleLimit; ) {
          if ((a = console.debug) == null || a.call(console, "while cycle " + this.k), this.setOutputData(1, this.k), this.triggerSlot(0, r), this.stopped) {
            (o = console.debug) == null || o.call(console, "while cycle stopped on index " + k);
            break;
          }
          this.k++, this.cond = this.getInputData(1, !0, !0);
        }
        this.k = 0, this.setOutputData(1, this.k), this.cond = this.getInputData(1), this.started = !1, this.stopped = !0;
        break;
    }
  }
}
g(logicWhile, "title", "WHILE"), g(logicWhile, "desc", "Cycle WHILE");
LiteGraph.registerNodeType("logic/CycleWHILE", logicWhile);
const Ee = class Ee {
  constructor() {
    this.addInput("A", "Number"), this.addInput("B", "Number"), this.addInput("C", "Number"), this.addInput("D", "Number"), this.values = [[], [], [], []], this.properties = { scale: 2 };
  }
  onExecute() {
    if (!this.flags.collapsed)
      for (var t = this.size, r = 0; r < 4; ++r) {
        var s = this.getInputData(r);
        if (s != null) {
          var a = this.values[r];
          a.push(s), a.length > t[0] && a.shift();
        }
      }
  }
  onDrawBackground(t) {
    if (!this.flags.collapsed) {
      var r = this.size, s = 0.5 * r[1] / this.properties.scale, a = Ee.colors, o = r[1] * 0.5;
      if (t.fillStyle = "#000", t.fillRect(0, 0, r[0], r[1]), t.strokeStyle = "#555", t.beginPath(), t.moveTo(0, o), t.lineTo(r[0], o), t.stroke(), this.inputs)
        for (let u = 0; u < 4; ++u) {
          let h = this.values[u];
          if (!this.inputs[u] || !this.inputs[u].link)
            continue;
          t.strokeStyle = a[u], t.beginPath();
          let l = h[0] * s * -1 + o;
          t.moveTo(0, LiteGraph.clamp(l, 0, r[1]));
          for (let c = 1; c < h.length && c < r[0]; ++c)
            l = h[c] * s * -1 + o, t.lineTo(c, LiteGraph.clamp(l, 0, r[1]));
          t.stroke();
        }
    }
  }
};
g(Ee, "title", "Plot"), g(Ee, "desc", "Plots data over time"), g(Ee, "colors", ["#FFF", "#F99", "#9F9", "#99F"]);
let GraphicsPlot = Ee;
LiteGraph.registerNodeType("graphics/plot", GraphicsPlot);
class GraphicsImage {
  constructor() {
    this.addOutput("frame", "image"), this.properties = { url: "" };
  }
  onAdded() {
    this.properties.url != "" && this.img == null && this.loadImage(this.properties.url);
  }
  onDrawBackground(t) {
    this.flags.collapsed || this.img && this.size[0] > 5 && this.size[1] > 5 && this.img.width && t.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
  }
  onExecute() {
    this.img || (this.boxcolor = "#000"), this.img && this.img.width ? this.setOutputData(0, this.img) : this.setOutputData(0, null), this.img && this.img.dirty && (this.img.dirty = !1);
  }
  onPropertyChanged(t, r) {
    return this.properties[t] = r, t == "url" && r != "" && this.loadImage(r), !0;
  }
  loadImage(t, r) {
    if (t == "") {
      this.img = null;
      return;
    }
    this.img = document.createElement("img"), t.substr(0, 4) == "http" && LiteGraph.proxy && (t = LiteGraph.proxy + t.substr(t.indexOf(":") + 3)), this.img.src = t, this.boxcolor = "#F95";
    var s = this;
    this.img.onload = function() {
      var a;
      r && r(this), (a = console.log) == null || a.call(console, `Image loaded, size: ${s.img.width}x${s.img.height}`), this.dirty = !0, s.boxcolor = "#9F9", s.setDirtyCanvas(!0);
    }, this.img.onerror = function() {
      var a;
      (a = console.log) == null || a.call(console, "error loading the image:" + t);
    };
  }
  onWidget(t, r) {
    r.name == "load" && this.loadImage(this.properties.url);
  }
  onDropFile(t) {
    var r = this;
    this._url && URL.revokeObjectURL(this._url), this._url = URL.createObjectURL(t), this.properties.url = this._url, this.loadImage(this._url, function(s) {
      r.size[1] = s.height / s.width * r.size[0];
    });
  }
}
g(GraphicsImage, "title", "Image"), g(GraphicsImage, "desc", "Image loader"), g(GraphicsImage, "widgets", [{ name: "load", text: "Load", type: "button" }]), g(GraphicsImage, "supported_extensions", ["jpg", "jpeg", "png", "gif"]);
LiteGraph.registerNodeType("graphics/image", GraphicsImage);
class ColorPalette {
  constructor() {
    this.addInput("f", "number"), this.addOutput("Color", "color"), this.properties = {
      colorA: "#444444",
      colorB: "#44AAFF",
      colorC: "#44FFAA",
      colorD: "#FFFFFF"
    };
  }
  onExecute() {
    var t = [];
    this.properties.colorA != null && t.push(hex2num(this.properties.colorA)), this.properties.colorB != null && t.push(hex2num(this.properties.colorB)), this.properties.colorC != null && t.push(hex2num(this.properties.colorC)), this.properties.colorD != null && t.push(hex2num(this.properties.colorD));
    var r = this.getInputData(0);
    if (r == null && (r = 0.5), r > 1 ? r = 1 : r < 0 && (r = 0), t.length != 0) {
      var s = [0, 0, 0];
      if (r == 0)
        s = t[0];
      else if (r == 1)
        s = t[t.length - 1];
      else {
        var a = (t.length - 1) * r, o = t[Math.floor(a)], u = t[Math.floor(a) + 1], h = a - Math.floor(a);
        s[0] = o[0] * (1 - h) + u[0] * h, s[1] = o[1] * (1 - h) + u[1] * h, s[2] = o[2] * (1 - h) + u[2] * h;
      }
      for (var l = 0; l < s.length; l++)
        s[l] /= 255;
      this.boxcolor = colorToString(s), this.setOutputData(0, s);
    }
  }
}
g(ColorPalette, "title", "Palette"), g(ColorPalette, "desc", "Generates a color");
LiteGraph.registerNodeType("color/palette", ColorPalette);
class ImageFrame {
  constructor() {
    this.addInput("", "image,canvas"), this.size = [200, 200];
  }
  onDrawBackground(t) {
    this.frame && !this.flags.collapsed && t.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
  }
  onExecute() {
    this.frame = this.getInputData(0), this.setDirtyCanvas(!0);
  }
  onWidget(t, r) {
    if (r.name == "resize" && this.frame) {
      var s = this.frame.width, a = this.frame.height;
      !s && this.frame.videoWidth != null && (s = this.frame.videoWidth, a = this.frame.videoHeight), s && a && (this.size = [s, a]), this.setDirtyCanvas(!0, !0);
    } else r.name == "view" && this.show();
  }
  show() {
    showElement && this.frame && showElement(this.frame);
  }
}
g(ImageFrame, "title", "Frame"), g(ImageFrame, "desc", "Frame viewer"), g(ImageFrame, "widgets", [
  { name: "resize", text: "Resize box", type: "button" },
  { name: "view", text: "View Image", type: "button" }
]);
LiteGraph.registerNodeType("graphics/frame", ImageFrame);
class ImageFade {
  constructor() {
    this.addInputs([
      ["img1", "image"],
      ["img2", "image"],
      ["fade", "number"]
    ]), this.addOutput("", "image"), this.properties = { fade: 0.5, width: 512, height: 512 };
  }
  onAdded() {
    this.createCanvas();
    var t = this.canvas.getContext("2d");
    t.fillStyle = "#000", t.fillRect(0, 0, this.properties.width, this.properties.height);
  }
  createCanvas() {
    this.canvas = document.createElement("canvas"), this.canvas.width = this.properties.width, this.canvas.height = this.properties.height;
  }
  onExecute() {
    var t = this.canvas.getContext("2d"), r = this.getInputData(0);
    r != null && t.drawImage(r, 0, 0, this.canvas.width, this.canvas.height);
    var s = this.getInputData(2);
    s == null ? s = this.properties.fade : this.properties.fade = s, t.globalAlpha = s;
    var a = this.getInputData(1);
    a != null && t.drawImage(a, 0, 0, this.canvas.width, this.canvas.height), t.globalAlpha = 1, this.setOutputData(0, this.canvas), this.setDirtyCanvas(!0);
  }
}
g(ImageFade, "title", "Image fade"), g(ImageFade, "desc", "Fades between images"), g(ImageFade, "widgets", [
  { name: "resizeA", text: "Resize to A", type: "button" },
  { name: "resizeB", text: "Resize to B", type: "button" }
]);
LiteGraph.registerNodeType("graphics/imagefade", ImageFade);
class ImageCrop {
  constructor() {
    this.addInput("", "image"), this.addOutput("", "image"), this.properties = { width: 256, height: 256, x: 0, y: 0, scale: 1 }, this.size = [50, 20];
  }
  onAdded() {
    this.createCanvas();
  }
  createCanvas() {
    this.canvas = document.createElement("canvas"), this.canvas.width = this.properties.width, this.canvas.height = this.properties.height;
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t)
      if (t.width) {
        var r = this.canvas.getContext("2d");
        r.drawImage(
          t,
          -this.properties.x,
          -this.properties.y,
          t.width * this.properties.scale,
          t.height * this.properties.scale
        ), this.setOutputData(0, this.canvas);
      } else
        this.setOutputData(0, null);
  }
  onDrawBackground(t) {
    this.flags.collapsed || this.canvas && t.drawImage(
      this.canvas,
      0,
      0,
      this.canvas.width,
      this.canvas.height,
      0,
      0,
      this.size[0],
      this.size[1]
    );
  }
  onPropertyChanged(t, r) {
    var s;
    return this.properties[t] = r, t == "scale" ? (this.properties[t] = parseFloat(r), this.properties[t] == 0 && ((s = console.error) == null || s.call(console, "Error in scale"), this.properties[t] = 1)) : this.properties[t] = parseInt(r), this.createCanvas(), !0;
  }
}
g(ImageCrop, "title", "Crop"), g(ImageCrop, "desc", "Crop Image");
LiteGraph.registerNodeType("graphics/cropImage", ImageCrop);
class CanvasNode {
  constructor() {
    this.addInput("clear", LiteGraph.ACTION), this.addOutput("", "canvas"), this.properties = { width: 512, height: 512, autoclear: !0 }, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d");
  }
  onExecute() {
    var t = this.canvas, r = this.properties.width | 0, s = this.properties.height | 0;
    t.width != r && (t.width = r), t.height != s && (t.height = s), this.properties.autoclear && this.ctx.clearRect(0, 0, t.width, t.height), this.setOutputData(0, t);
  }
  onAction(t) {
    t == "clear" && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
}
g(CanvasNode, "title", "Canvas"), g(CanvasNode, "desc", "Canvas to render stuff");
LiteGraph.registerNodeType("graphics/canvas", CanvasNode);
class DrawImageNode {
  constructor() {
    this.addInput("canvas", "canvas"), this.addInput("img", "image,canvas"), this.addInput("x", "number"), this.addInput("y", "number"), this.properties = { x: 0, y: 0, opacity: 1 };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      var r = this.getInputOrProperty("img");
      if (r) {
        var s = this.getInputOrProperty("x"), a = this.getInputOrProperty("y"), o = t.getContext("2d");
        o.drawImage(r, s, a);
      }
    }
  }
}
g(DrawImageNode, "title", "DrawImage"), g(DrawImageNode, "desc", "Draws image into a canvas");
LiteGraph.registerNodeType("graphics/drawImage", DrawImageNode);
class DrawRectangleNode {
  constructor() {
    this.addInput("canvas", "canvas"), this.addInput("x", "number"), this.addInput("y", "number"), this.addInput("w", "number"), this.addInput("h", "number"), this.properties = {
      x: 0,
      y: 0,
      w: 10,
      h: 10,
      color: "white",
      opacity: 1
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      var r = this.getInputOrProperty("x"), s = this.getInputOrProperty("y"), a = this.getInputOrProperty("w"), o = this.getInputOrProperty("h"), u = t.getContext("2d");
      u.fillRect(r, s, a, o);
    }
  }
}
g(DrawRectangleNode, "title", "DrawRectangle"), g(DrawRectangleNode, "desc", "Draws rectangle in canvas");
LiteGraph.registerNodeType("graphics/drawRectangle", DrawRectangleNode);
class ImageVideo {
  constructor() {
    this.addInput("t", "number"), this.addOutputs([
      ["frame", "image"],
      ["t", "number"],
      ["d", "number"]
    ]), this.properties = { url: "", use_proxy: !0 };
  }
  onExecute() {
    if (this.properties.url && (this.properties.url != this._video_url && this.loadVideo(this.properties.url), !(!this._video || this._video.width == 0))) {
      var t = this.getInputData(0);
      t && t >= 0 && t <= 1 && (this._video.currentTime = t * this._video.duration, this._video.pause()), this._video.dirty = !0, this.setOutputData(0, this._video), this.setOutputData(1, this._video.currentTime), this.setOutputData(2, this._video.duration), this.setDirtyCanvas(!0);
    }
  }
  onStart() {
    this.play();
  }
  onStop() {
    this.stop();
  }
  loadVideo(t) {
    this._video_url = t;
    var r = t.substr(0, 10).indexOf(":"), s = "";
    r != -1 && (s = t.substr(0, r));
    var a = "";
    s && (a = t.substr(0, t.indexOf("/", s.length + 3)), a = a.substr(s.length + 3)), this.properties.use_proxy && s && LiteGraph.proxy && a != location.host && (t = LiteGraph.proxy + t.substr(t.indexOf(":") + 3)), this._video = document.createElement("video"), this._video.src = t, this._video.type = "type=video/mp4", this._video.muted = !0, this._video.autoplay = !0;
    var o = this;
    this._video.addEventListener("loadedmetadata", (u) => {
      var h, l;
      (h = console.log) == null || h.call(console, "Duration: " + this.duration + " seconds"), (l = console.log) == null || l.call(console, "Size: " + this.videoWidth + "," + this.videoHeight), o.setDirtyCanvas(!0), this.width = this.videoWidth, this.height = this.videoHeight;
    }), this._video.addEventListener("progress", (u) => {
      var h;
      (h = console.log) == null || h.call(console, "video loading...");
    }), this._video.addEventListener("error", (u) => {
      var h, l, c, d, f;
      if ((h = console.error) == null || h.call(console, "Error loading video: " + this.src), this.error)
        switch (this.error.code) {
          case this.error.MEDIA_ERR_ABORTED:
            (l = console.error) == null || l.call(console, "You stopped the video.");
            break;
          case this.error.MEDIA_ERR_NETWORK:
            (c = console.error) == null || c.call(console, "Network error - please try again later.");
            break;
          case this.error.MEDIA_ERR_DECODE:
            (d = console.error) == null || d.call(console, "Video is broken..");
            break;
          case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            (f = console.error) == null || f.call(console, "Sorry, your browser can't play this video.");
            break;
        }
    }), this._video.addEventListener("ended", (u) => {
      var h;
      (h = console.log) == null || h.call(console, "Video Ended."), this.play();
    });
  }
  onPropertyChanged(t, r) {
    return this.properties[t] = r, t == "url" && r != "" && this.loadVideo(r), !0;
  }
  play() {
    this._video && this._video.videoWidth && this._video.play();
  }
  playPause() {
    this._video && (this._video.paused ? this.play() : this.pause());
  }
  stop() {
    this._video && (this._video.pause(), this._video.currentTime = 0);
  }
  pause() {
    var t;
    this._video && ((t = console.log) == null || t.call(console, "Video paused"), this._video.pause());
  }
  onWidget(t, r) {
  }
}
g(ImageVideo, "title", "Video"), g(ImageVideo, "desc", "Video playback"), g(ImageVideo, "widgets", [
  { name: "play", text: "PLAY", type: "minibutton" },
  { name: "stop", text: "STOP", type: "minibutton" },
  { name: "demo", text: "Demo video", type: "button" },
  { name: "mute", text: "Mute video", type: "button" }
]);
LiteGraph.registerNodeType("graphics/video", ImageVideo);
const Qt = class Qt {
  constructor() {
    this.addOutput("Webcam", "image"), this.properties = { filterFacingMode: !1, facingMode: "user" }, this.boxcolor = "black", this.frame = 0;
  }
  openStream() {
    var a;
    if (!navigator.mediaDevices.getUserMedia) {
      (a = console.log) == null || a.call(console, "getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
      return;
    }
    this._waiting_confirmation = !0;
    var t = {
      audio: !1,
      video: this.properties.filterFacingMode ? { facingMode: this.properties.facingMode } : !0
    };
    navigator.mediaDevices.getUserMedia(t).then(this.streamReady.bind(this)).catch(s);
    var r = this;
    function s(o) {
      var u;
      (u = console.log) == null || u.call(console, "Webcam rejected", o), r._webcam_stream = !1, Qt.is_webcam_open = !1, r.boxcolor = "red", r.trigger("stream_error");
    }
  }
  closeStream() {
    if (this._webcam_stream) {
      var t = this._webcam_stream.getTracks();
      if (t.length)
        for (var r = 0; r < t.length; ++r)
          t[r].stop();
      Qt.is_webcam_open = !1, this._webcam_stream = null, this._video = null, this.boxcolor = "black", this.trigger("stream_closed");
    }
  }
  onPropertyChanged(t, r) {
    t == "facingMode" && (this.properties.facingMode = r, this.closeStream(), this.openStream());
  }
  onRemoved() {
    this.closeStream();
  }
  streamReady(t) {
    this._webcam_stream = t, this.boxcolor = "green";
    var r = this._video;
    r || (r = document.createElement("video"), r.autoplay = !0, r.srcObject = t, this._video = r, r.onloadedmetadata = function(s) {
      var a;
      (a = console.log) == null || a.call(console, s), Qt.is_webcam_open = !0;
    }), this.trigger("stream_ready", r);
  }
  onExecute() {
    if (this._webcam_stream == null && !this._waiting_confirmation && this.openStream(), !(!this._video || !this._video.videoWidth)) {
      this._video.frame = ++this.frame, this._video.width = this._video.videoWidth, this._video.height = this._video.videoHeight, this.setOutputData(0, this._video);
      for (var t = 1; t < this.outputs.length; ++t)
        if (this.outputs[t])
          switch (this.outputs[t].name) {
            case "width":
              this.setOutputData(t, this._video.videoWidth);
              break;
            case "height":
              this.setOutputData(t, this._video.videoHeight);
              break;
          }
    }
  }
  getExtraMenuOptions() {
    var t = this, r = t.properties.show ? "Hide Frame" : "Show Frame";
    return [
      {
        content: r,
        callback: function() {
          t.properties.show = !t.properties.show;
        }
      }
    ];
  }
  onDrawBackground(t) {
    this.flags.collapsed || this.size[1] <= 20 || !this.properties.show || this._video && (t.save(), t.drawImage(this._video, 0, 0, this.size[0], this.size[1]), t.restore());
  }
  onGetOutputs() {
    return [
      ["width", "number"],
      ["height", "number"],
      ["stream_ready", LiteGraph.EVENT],
      ["stream_closed", LiteGraph.EVENT],
      ["stream_error", LiteGraph.EVENT]
    ];
  }
};
g(Qt, "title", "Webcam"), g(Qt, "desc", "Webcam image"), g(Qt, "is_webcam_open", !1);
let ImageWebcam = Qt;
LiteGraph.registerNodeType("graphics/webcam", ImageWebcam);
const DDS = (function() {
  var n = 542327876, t = 131072, r = 512, s = 4;
  function a(A) {
    return A.charCodeAt(0) + (A.charCodeAt(1) << 8) + (A.charCodeAt(2) << 16) + (A.charCodeAt(3) << 24);
  }
  function o(A) {
    return String.fromCharCode(
      A & 255,
      A >> 8 & 255,
      A >> 16 & 255,
      A >> 24 & 255
    );
  }
  var u = a("DXT1"), h = a("DXT3"), l = a("DXT5"), c = 31, d = 0, f = 1, _ = 2, E = 3, m = 4, T = 7, L = 20, G = 21, O = 27;
  function b(A, R, B, X) {
    for (var F = new Uint16Array(4), V = new Uint16Array(B * X), $ = 0, U = 0, H = 0, z = 0, K = 0, tt = 0, W = 0, Q = 0, J = 0, q = B / 4, Z = X / 4, pt = 0; pt < Z; pt++)
      for (var Bt = 0; Bt < q; Bt++)
        H = R + 4 * (pt * q + Bt), F[0] = A[H], F[1] = A[H + 1], z = F[0] & 31, K = F[0] & 2016, tt = F[0] & 63488, W = F[1] & 31, Q = F[1] & 2016, J = F[1] & 63488, F[2] = 5 * z + 3 * W >> 3 | 5 * K + 3 * Q >> 3 & 2016 | 5 * tt + 3 * J >> 3 & 63488, F[3] = 5 * W + 3 * z >> 3 | 5 * Q + 3 * K >> 3 & 2016 | 5 * J + 3 * tt >> 3 & 63488, $ = A[H + 2], U = pt * 4 * B + Bt * 4, V[U] = F[$ & 3], V[U + 1] = F[$ >> 2 & 3], V[U + 2] = F[$ >> 4 & 3], V[U + 3] = F[$ >> 6 & 3], U += B, V[U] = F[$ >> 8 & 3], V[U + 1] = F[$ >> 10 & 3], V[U + 2] = F[$ >> 12 & 3], V[U + 3] = F[$ >> 14], $ = A[H + 3], U += B, V[U] = F[$ & 3], V[U + 1] = F[$ >> 2 & 3], V[U + 2] = F[$ >> 4 & 3], V[U + 3] = F[$ >> 6 & 3], U += B, V[U] = F[$ >> 8 & 3], V[U + 1] = F[$ >> 10 & 3], V[U + 2] = F[$ >> 12 & 3], V[U + 3] = F[$ >> 14];
    return V;
  }
  function I(A) {
    for (var R = 0, B = A.length, X = 0; R < B; R += 4)
      X = A[R], A[R] = A[R + 2], A[R + 2] = X;
  }
  function S(A, R, B, X) {
    var F = new Int32Array(B, 0, c), V, $, U, H, z, K, tt, W, Q, J, q, Z, pt;
    if (F[d] != n)
      return console.error("Invalid magic number in DDS header"), 0;
    if (!F[L] & s)
      return console.error("Unsupported format, must contain a FourCC code"), 0;
    switch (V = F[G], V) {
      case u:
        $ = 8, U = R ? R.COMPRESSED_RGB_S3TC_DXT1_EXT : null;
        break;
      /*
               case FOURCC_DXT1:
                   blockBytes = 8;
                   internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT1_EXT : null;
                   break;
      */
      case h:
        $ = 16, U = R ? R.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
        break;
      case l:
        $ = 16, U = R ? R.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
        break;
      default:
        $ = 4, V = null, U = A.RGBA;
    }
    if (q = 1, F[_] & t && X !== !1 && (q = Math.max(1, F[T])), H = F[m], z = F[E], tt = F[f] + 4, W = !!(F[O + 1] & r), W)
      for (pt = 0; pt < 6; ++pt) {
        H = F[m], z = F[E];
        for (var Z = 0; Z < q; ++Z)
          V ? (K = Math.max(4, H) / 4 * Math.max(4, z) / 4 * $, J = new Uint8Array(B, tt, K), A.compressedTexImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + pt, Z, U, H, z, 0, J)) : (A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL, !1), K = H * z * $, J = new Uint8Array(B, tt, K), I(J), A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + pt, Z, U, H, z, 0, A.RGBA, A.UNSIGNED_BYTE, J)), tt += K, H *= 0.5, z *= 0.5;
      }
    else if (R) {
      A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL, !0);
      for (var Z = 0; Z < q; ++Z)
        V ? (K = Math.max(4, H) / 4 * Math.max(4, z) / 4 * $, J = new Uint8Array(B, tt, K), A.compressedTexImage2D(A.TEXTURE_2D, Z, U, H, z, 0, J)) : (K = H * z * $, J = new Uint8Array(B, tt, K), I(J), A.texImage2D(A.TEXTURE_2D, Z, U, H, z, 0, U, A.UNSIGNED_BYTE, J)), tt += K, H *= 0.5, z *= 0.5;
    } else if (V == u)
      K = Math.max(4, H) / 4 * Math.max(4, z) / 4 * $, J = new Uint16Array(B), Q = b(J, tt / 2, H, z), A.texImage2D(A.TEXTURE_2D, 0, A.RGB, H, z, 0, A.RGB, A.UNSIGNED_SHORT_5_6_5, Q), X && A.generateMipmap(A.TEXTURE_2D);
    else
      return console.error("No manual decoder for", o(V), "and no native support"), 0;
    return q;
  }
  function N(A, R) {
    var B = new Int32Array(A, 0, c), X, F, V, $, U, H, z, K, tt, W, Q, J;
    if (B[d] != n)
      return console.error("Invalid magic number in DDS header"), 0;
    if (!B[L] & s)
      return console.error("Unsupported format, must contain a FourCC code"), 0;
    switch (X = B[G], X) {
      case u:
        F = 8, V = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        break;
      case h:
        F = 16, V = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        break;
      case l:
        F = 16, V = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        break;
      default:
        F = 4, V = "RGBA";
    }
    W = 1, B[_] & t && loadMipmaps !== !1 && (W = Math.max(1, B[T])), $ = B[m], U = B[E], z = B[f] + 4, K = !!(B[O + 1] & r);
    var q = [];
    if (K)
      for (var J = 0; J < 6; ++J) {
        $ = B[m], U = B[E];
        for (var Q = 0; Q < W; ++Q)
          X ? (H = Math.max(4, $) / 4 * Math.max(4, U) / 4 * F, tt = new Uint8Array(A, z, H), q.push({ tex: "TEXTURE_CUBE_MAP", face: J, mipmap: Q, internalFormat: V, width: $, height: U, offset: 0, dataOffset: z, dataLength: H })) : (H = $ * U * F, tt = new Uint8Array(A, z, H), I(tt), q.push({ tex: "TEXTURE_CUBE_MAP", face: J, mipmap: Q, internalFormat: V, width: $, height: U, offset: 0, type: "UNSIGNED_BYTE", dataOffset: z, dataLength: H })), z += H, $ *= 0.5, U *= 0.5;
      }
    else
      for (var Q = 0; Q < W; ++Q)
        H = Math.max(4, $) / 4 * Math.max(4, U) / 4 * F, tt = new Uint8Array(A, z, H), q.push({ tex: "TEXTURE_2D", mipmap: Q, internalFormat: V, width: $, height: U, offset: 0, type: "UNSIGNED_BYTE", dataOffset: z, dataLength: H }), z += H, $ *= 0.5, U *= 0.5;
    return q;
  }
  function C(A, R, B, X, F, V) {
    var $ = new XMLHttpRequest();
    return $.open("GET", B, !0), $.responseType = "arraybuffer", $.onload = function() {
      if (this.status == 200) {
        var U = new Int32Array(this.response, 0, c), H = !!(U[O + 1] & r), z = H ? A.TEXTURE_CUBE_MAP : A.TEXTURE_2D;
        A.bindTexture(z, X);
        var K = S(A, R, this.response, F);
        A.texParameteri(z, A.TEXTURE_MAG_FILTER, A.LINEAR), A.texParameteri(z, A.TEXTURE_MIN_FILTER, K > 1 ? A.LINEAR_MIPMAP_LINEAR : A.LINEAR), A.bindTexture(z, null), X.texture_type = z, X.width = U[m], X.height = U[E];
      }
      V && V(X);
    }, $.send(null), X;
  }
  function D(A, R, B, X, F) {
    var V = new Int32Array(B, 0, c), $ = !!(V[O + 1] & r), U = $ ? A.TEXTURE_CUBE_MAP : A.TEXTURE_2D;
    X.handler, A.bindTexture(U, X.handler);
    var H = S(A, R, B, F);
    return A.texParameteri(U, A.TEXTURE_MAG_FILTER, A.LINEAR), A.texParameteri(U, A.TEXTURE_MIN_FILTER, H > 1 ? A.LINEAR_MIPMAP_LINEAR : A.LINEAR), $ && (A.texParameteri(U, A.TEXTURE_WRAP_S, A.CLAMP_TO_EDGE), A.texParameteri(U, A.TEXTURE_WRAP_T, A.CLAMP_TO_EDGE)), A.bindTexture(U, null), X.handler && (X.texture_type = U, X.width = V[m], X.height = V[E]), X;
  }
  function M(A) {
    var R = new Int32Array(A, 0, c), B = !!(R[O + 1] & r), X = B ? "TEXTURE_CUBE_MAP" : "TEXTURE_2D", F = N(A), V = {
      type: X,
      buffers: F,
      data: A,
      width: R[m],
      height: R[E]
    };
    return V;
  }
  function P(A, V, B, X) {
    var F = A.createTexture(), V = A.getExtension("WEBGL_compressed_texture_s3tc");
    return C(A, V, B, F, !0, X), F;
  }
  return {
    dxtToRgb565: b,
    uploadDDSLevels: S,
    loadDDSTextureEx: C,
    loadDDSTexture: P,
    loadDDSTextureFromMemoryEx: D,
    getDDSTextureFromMemoryEx: M
  };
})();
class Editor {
  constructor(t, r = {}) {
    const s = this.root = document.createElement("div");
    s.className = "litegraph litegraph-editor", s.innerHTML = `
        <div class="header">
            <div class="tools tools-left"></div>
            <div class="tools tools-right"></div>
        </div>
        <div class="content">
            <div class="editor-area">
                <canvas class="graphcanvas" width="1000" height="500" tabindex="10"></canvas>
            </div>
        </div>
        <div class="footer">
            <div class="tools tools-left"></div>
            <div class="tools tools-right"></div>
        </div>`, this.tools = s.querySelector(".tools"), this.content = s.querySelector(".content"), this.footer = s.querySelector(".footer");
    const a = this.canvas = s.querySelector(".graphcanvas"), o = this.graph = new LGraph(), u = this.graphcanvas = new LGraphCanvas(a, o);
    u.background_image = "imgs/grid.png", o.onAfterExecute = () => {
      u.draw(!0);
    }, u.onDropItem = this.onDropItem.bind(this), this.addLoadCounter(), this.addToolsButton(
      "playnode_button",
      "Play",
      "imgs/icon-play.png",
      this.onPlayButton.bind(this),
      ".tools-right"
    ), this.addToolsButton(
      "playstepnode_button",
      "Step",
      "imgs/icon-playstep.png",
      this.onPlayStepButton.bind(this),
      ".tools-right"
    ), r.skip_livemode || this.addToolsButton(
      "livemode_button",
      "Live",
      "imgs/icon-record.png",
      this.onLiveButton.bind(this),
      ".tools-right"
    ), r.skip_maximize || this.addToolsButton(
      "maximize_button",
      "",
      "imgs/icon-maximize.png",
      this.onFullscreenButton.bind(this),
      ".tools-right"
    ), r.miniwindow && this.addMiniWindow(300, 200);
    const h = document.getElementById(t);
    if (h)
      h == null || h.appendChild(s);
    else
      throw new Error("Editor has no parentElement to bind to");
    o.onPlayEvent = () => {
      const l = this.root.querySelector("#playnode_button");
      l.innerHTML = '<img src="imgs/icon-stop.png"/> Stop';
    }, o.onStopEvent = () => {
      const l = this.root.querySelector("#playnode_button");
      l.innerHTML = '<img src="imgs/icon-play.png"/> Play';
    }, u.resize();
  }
  addLoadCounter() {
    const t = document.createElement("div");
    t.className = "headerpanel loadmeter toolbar-widget", t.innerHTML = `
            <div class="cpuload">
                <strong>CPU</strong> 
                <div class="bgload">
                    <div class="fgload"></div>
                </div>
            </div>
            <div class="gpuload">
                <strong>GFX</strong> 
                <div class="bgload">
                    <div class="fgload"></div>
                </div>
            </div>`, this.root.querySelector(".header .tools-left").appendChild(t);
    var r = this;
    setInterval(() => {
      t.querySelector(".cpuload .fgload").style.width = `${2 * r.graph.execution_time * 90}px`, r.graph.status == LGraph.STATUS_RUNNING ? t.querySelector(".gpuload .fgload").style.width = `${r.graphcanvas.render_time * 10 * 90}px` : t.querySelector(".gpuload .fgload").style.width = "4px";
    }, 200);
  }
  addToolsButton(t, r, s, a, o = ".tools") {
    const u = this.createButton(r, s, a);
    u.id = t, this.root.querySelector(o).appendChild(u);
  }
  createButton(t, r, s) {
    const a = document.createElement("button");
    return r && (a.innerHTML = `<img src="${r}"/> `), a.classList.add("btn"), a.innerHTML += t, s && a.addEventListener("click", s), a;
  }
  onLoadButton() {
    var t = this.graphcanvas.createPanel("Load session", { closable: !0 });
    this.root.appendChild(t);
  }
  onSaveButton() {
  }
  onPlayButton() {
    var t = this.graph;
    t.status == LGraph.STATUS_STOPPED ? t.start() : t.stop();
  }
  onPlayStepButton() {
    var t = this.graph;
    t.runStep(1), this.graphcanvas.draw(!0, !0);
  }
  onLiveButton() {
    var t = !this.graphcanvas.live_mode;
    this.graphcanvas.switchLiveMode(!0), this.graphcanvas.draw();
    var r = this.root.querySelector("#livemode_button");
    r.innerHTML = t ? '<img src="imgs/icon-gear.png"/> Edit' : '<img src="imgs/icon-record.png"/> Live';
  }
  onDropItem(t) {
    for (var r = this, s = 0; s < t.dataTransfer.files.length; ++s) {
      var a = t.dataTransfer.files[s], o = LGraphCanvas.getFileExtension(a.name), u = new FileReader();
      o == "json" && (u.onload = (h) => {
        var l = JSON.parse(h.target.result);
        r.graph.configure(l);
      }, u.readAsText(a));
    }
  }
  goFullscreen() {
    if (this.root.requestFullscreen)
      this.root.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    else if (this.root.mozRequestFullscreen)
      this.root.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    else if (this.root.webkitRequestFullscreen)
      this.root.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    else
      throw new Error("Fullscreen not supported");
    var t = this;
    setTimeout(() => {
      t.graphcanvas.resize();
    }, 100);
  }
  onFullscreenButton() {
    this.isFullscreen() ? this.exitFullscreen() : this.goFullscreen();
  }
  addMiniWindow(t, r) {
    var s = document.createElement("div");
    s.className = "litegraph miniwindow", s.innerHTML = `<canvas class="graphcanvas" width="${t}" height="${r}" tabindex="10"></canvas>`;
    var a = s.querySelector("canvas"), o = this, u = new LGraphCanvas(a, this.graph);
    u.show_info = !1, u.background_image = "imgs/grid.png", u.scale = 0.25, u.allow_dragnodes = !1, u.allow_interaction = !1, u.render_shadows = !1, u.max_zoom = 0.25, this.miniwindow_graphcanvas = u, u.onClear = () => {
      u.scale = 0.25, u.allow_dragnodes = !1, u.allow_interaction = !1;
    }, u.onRenderBackground = function(l, c) {
      c.strokeStyle = "#567";
      var d = o.graphcanvas.convertOffsetToCanvas([0, 0]), f = o.graphcanvas.convertOffsetToCanvas([
        o.graphcanvas.canvas.width,
        o.graphcanvas.canvas.height
      ]);
      d = this.convertCanvasToOffset(d), f = this.convertCanvasToOffset(f), c.lineWidth = 1, c.strokeRect(
        Math.floor(d[0]) + 0.5,
        Math.floor(d[1]) + 0.5,
        Math.floor(f[0] - d[0]),
        Math.floor(f[1] - d[1])
      );
    }, s.style.position = "absolute", s.style.top = "4px", s.style.right = "4px";
    var h = document.createElement("div");
    h.className = "corner-button", h.innerHTML = "&#10060;", h.addEventListener("click", (l) => {
      u.setGraph(null), s.parentNode.removeChild(s);
    }), s.appendChild(h), this.root.querySelector(".content").appendChild(s);
  }
  addMultiview() {
    var t = this.canvas;
    let r;
    if (this.graphcanvas2) {
      this.graphcanvas2.setGraph(null, !0), this.graphcanvas2.viewport = null, this.graphcanvas2 = null, this.graphcanvas.viewport = null, this.graphcanvas.setGraph(null, !0), this.graphcanvas = null, r = new LGraphCanvas(t, this.graph), r.background_image = "imgs/grid.png", this.graphcanvas = r, window.graphcanvas = this.graphcanvas;
      return;
    }
    this.graphcanvas.ctx.fillStyle = "black", this.graphcanvas.ctx.fillRect(0, 0, t.width, t.height), this.graphcanvas.viewport = [0, 0, t.width * 0.5 - 2, t.height], r = new LGraphCanvas(t, this.graph), r.background_image = "imgs/grid.png", this.graphcanvas2 = r, this.graphcanvas2.viewport = [t.width * 0.5, 0, t.width * 0.5, t.height];
  }
  isFullscreen() {
    return document.fullscreenElement || document.mozRequestFullscreen || document.webkitRequestFullscreen || !1;
  }
  exitFullscreen() {
    document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullscreen ? document.mozCancelFullscreen() : document.webkitExitFullscreen && document.webkitExitFullscreen();
  }
}
var gl$1 = null;
typeof global == "object" && (global.LiteGraph = LiteGraph);
typeof window == "object" && (window.LiteGraph = LiteGraph);
var Ne;
(Ne = LiteGraph.info) == null || Ne.call(LiteGraph, "LiteGraph included");
var webgl_canvas = null;
LiteGraph.node_images_path = "../nodes_data/";
var editor = new Editor("main", { miniwindow: !1 });
window.graphcanvas = editor.graphcanvas;
window.graph = editor.graph;
updateEditorHiPPICanvas();
window.addEventListener("resize", function() {
  editor.graphcanvas.resize(), updateEditorHiPPICanvas();
});
window.onbeforeunload = function() {
  var n = JSON.stringify(graph.serialize());
  localStorage.setItem("litegraphg demo backup", n);
};
function updateEditorHiPPICanvas() {
  const n = window.devicePixelRatio;
  if (n == 1)
    return;
  const t = editor.canvas.parentNode.getBoundingClientRect(), { width: r, height: s } = t;
  return editor.canvas.width = r * n, editor.canvas.height = s * n, editor.canvas.style.width = r + "px", editor.canvas.style.height = s + "px", editor.canvas.getContext("2d").scale(n, n), editor.canvas;
}
LiteGraph.allow_scripts = !0;
var elem = document.createElement("span");
elem.id = "LGEditorTopBarSelector";
elem.className = "selector";
elem.innerHTML = "";
elem.innerHTML += "Demo <select><option>Empty</option></select> <button class='btn' id='save'>Save</button><button class='btn' id='load'>Load</button><button class='btn' id='download'>Download</button> | <button class='btn' id='webgl'>WebGL</button> <button class='btn' id='multiview'>Multiview</button>";
editor.tools.appendChild(elem);
var select = elem.querySelector("select");
select.addEventListener("change", function(n) {
  var t = this.options[this.selectedIndex], r = t.dataset.url;
  r ? graph.load(r) : t.callback ? t.callback() : graph.clear();
});
elem.querySelector("#save").addEventListener("click", function() {
  var n;
  (n = console.log) == null || n.call(console, "saved"), localStorage.setItem("graphdemo_save", JSON.stringify(graph.serialize()));
});
elem.querySelector("#load").addEventListener("click", function() {
  var t;
  var n = localStorage.getItem("graphdemo_save");
  n && graph.configure(JSON.parse(n)), (t = console.log) == null || t.call(console, "loaded");
});
elem.querySelector("#download").addEventListener("click", function() {
  var n = JSON.stringify(graph.serialize()), t = new Blob([n]), r = URL.createObjectURL(t), s = document.createElement("a");
  s.setAttribute("href", r), s.setAttribute("download", "graph.JSON"), s.style.display = "none", document.body.appendChild(s), s.click(), document.body.removeChild(s), setTimeout(function() {
    URL.revokeObjectURL(r);
  }, 1e3 * 60);
});
elem.querySelector("#webgl").addEventListener("click", enableWebGL);
elem.querySelector("#multiview").addEventListener("click", function() {
  editor.addMultiview();
});
function addDemo(n, t) {
  var r = document.createElement("option");
  t.constructor === String ? r.dataset.url = t : r.callback = t, r.innerHTML = n, select.appendChild(r);
}
addDemo("Features", "examples/features.json");
addDemo("Benchmark", "examples/benchmark.json");
addDemo("Subgraph", "examples/subgraph.json");
addDemo("Audio", "examples/audio.json");
addDemo("Audio Delay", "examples/audio_delay.json");
addDemo("Audio Reverb", "examples/audio_reverb.json");
addDemo("MIDI Generation", "examples/midi_generation.json");
addDemo("Copy Paste", "examples/copypaste.json");
addDemo("autobackup", function() {
  var n = localStorage.getItem("litegraphg demo backup");
  if (n) {
    var t = JSON.parse(n);
    graph.configure(t);
  }
});
function enableWebGL() {
  if (webgl_canvas) {
    webgl_canvas.style.display = webgl_canvas.style.display == "none" ? "block" : "none";
    return;
  }
  let n = [
    "./libs/gl-matrix-min.js",
    "./libs/litegl.js"
  ];
  async function t(s) {
    var a, o;
    if (n.length === 0)
      return r();
    try {
      await import(s), (a = console.log) == null || a.call(console, `${s} loaded successfully`);
    } catch (u) {
      (o = console.error) == null || o.call(console, `Error loading ${s}: ${u}`);
    }
  }
  n.forEach((s) => t(s));
  const r = () => {
    var a, o, u, h;
    if ((a = console.log) == null || a.call(console, this.src), !window.GL) {
      (o = LiteGraph.warn) == null || o.call(LiteGraph, "GL doesn't exist");
      return;
    }
    webgl_canvas = document.createElement("canvas"), webgl_canvas.width = 400, webgl_canvas.height = 300, webgl_canvas.style.position = "absolute", webgl_canvas.style.top = "0px", webgl_canvas.style.right = "0px", webgl_canvas.style.border = "1px solid #AAA", webgl_canvas.addEventListener("click", function() {
      var l = webgl_canvas.parentNode.getBoundingClientRect();
      webgl_canvas.width != l.width ? (webgl_canvas.width = l.width, webgl_canvas.height = l.height) : (webgl_canvas.width = 400, webgl_canvas.height = 300);
    });
    var s = document.querySelector(".editor-area");
    if (s.appendChild(webgl_canvas), gl$1 = GL.create({ canvas: webgl_canvas }), !gl$1) {
      (u = LiteGraph.warn) == null || u.call(LiteGraph, "gl doesn't exist");
      return;
    }
    n = [
      "../src/nodes/gltextures.js",
      "../src/nodes/glfx.js",
      "../src/nodes/glshaders.js",
      "../src/nodes/geometry.js"
    ], n.forEach((l) => t(l)), editor.graph.onBeforeStep = () => {
      gl$1.clearColor(0, 0, 0, 0), gl$1.clear(gl$1.COLOR_BUFFER_BIT | gl$1.DEPTH_BUFFER_BIT), gl$1.viewport(0, 0, gl$1.canvas.width, gl$1.canvas.height);
    }, (h = console.log) == null || h.call(console, "webgl ready");
  };
}
const global$1 = { gl: gl$1 };
var Re, Me, Fe;
(Fe = window.requestAnimationFrame) != null || (window.requestAnimationFrame = (Me = (Re = window.mozRequestAnimationFrame) != null ? Re : window.webkitRequestAnimationFrame) != null ? Me : function(n) {
  setTimeout(n, 1e3 / 60);
});
if (typeof glMatrix == "undefined")
  throw new Error("litegl.js requires gl-matrix to work. It must be included before litegl.");
var GL$1 = new class {
  constructor() {
    this.blockable_keys = { Up: !0, Down: !0, Left: !0, Right: !0 }, this.reverse = null, this.LEFT_MOUSE_BUTTON = 0, this.MIDDLE_MOUSE_BUTTON = 1, this.RIGHT_MOUSE_BUTTON = 2, this.LEFT_MOUSE_BUTTON_MASK = 1, this.RIGHT_MOUSE_BUTTON_MASK = 2, this.MIDDLE_MOUSE_BUTTON_MASK = 4, this.last_context_id = 0, this.COLOR_BUFFER_BIT = 16384, this.DEPTH_BUFFER_BIT = 256, this.STENCIL_BUFFER_BIT = 1024, this.TEXTURE_2D = 3553, this.TEXTURE_CUBE_MAP = 34067, this.TEXTURE_3D = 32879, this.TEXTURE_MAG_FILTER = 10240, this.TEXTURE_MIN_FILTER = 10241, this.TEXTURE_WRAP_S = 10242, this.TEXTURE_WRAP_T = 10243, this.BYTE = 5120, this.UNSIGNED_BYTE = 5121, this.SHORT = 5122, this.UNSIGNED_SHORT = 5123, this.INT = 5124, this.UNSIGNED_INT = 5125, this.FLOAT = 5126, this.HALF_FLOAT_OES = 36193, this.HALF_FLOAT = 5131, this.DEPTH_COMPONENT16 = 33189, this.DEPTH_COMPONENT24 = 33190, this.DEPTH_COMPONENT32F = 36012, this.FLOAT_VEC2 = 35664, this.FLOAT_VEC3 = 35665, this.FLOAT_VEC4 = 35666, this.INT_VEC2 = 35667, this.INT_VEC3 = 35668, this.INT_VEC4 = 35669, this.BOOL = 35670, this.BOOL_VEC2 = 35671, this.BOOL_VEC3 = 35672, this.BOOL_VEC4 = 35673, this.FLOAT_MAT2 = 35674, this.FLOAT_MAT3 = 35675, this.FLOAT_MAT4 = 35676, this.TYPE_LENGTH = {}, this.TYPE_LENGTH[this.FLOAT] = this.TYPE_LENGTH[this.INT] = this.TYPE_LENGTH[this.BYTE] = this.TYPE_LENGTH[this.BOOL] = 1, this.TYPE_LENGTH[this.FLOAT_VEC2] = this.TYPE_LENGTH[this.INT_VEC2] = this.TYPE_LENGTH[this.BOOL_VEC2] = 2, this.TYPE_LENGTH[this.FLOAT_VEC3] = this.TYPE_LENGTH[this.INT_VEC3] = this.TYPE_LENGTH[this.BOOL_VEC3] = 3, this.TYPE_LENGTH[this.FLOAT_VEC4] = this.TYPE_LENGTH[this.INT_VEC4] = this.TYPE_LENGTH[this.BOOL_VEC4] = 4, this.TYPE_LENGTH[this.FLOAT_MAT3] = 9, this.TYPE_LENGTH[this.FLOAT_MAT4] = 16, this.SAMPLER_2D = 35678, this.SAMPLER_3D = 35679, this.SAMPLER_CUBE = 35680, this.DEPTH_COMPONENT = 6402, this.ALPHA = 6406, this.RGB = 6407, this.RGBA = 6408, this.LUMINANCE = 6409, this.LUMINANCE_ALPHA = 6410, this.DEPTH_STENCIL = 34041, this.UNSIGNED_INT_24_8_WEBGL = 34042, this.R8 = 33321, this.R16F = 33325, this.R32F = 33326, this.R8UI = 33330, this.RG8 = 33323, this.RG16F = 33327, this.RG32F = 33328, this.RGB8 = 32849, this.SRGB8 = 35905, this.RGB565 = 36194, this.R11F_G11F_B10F = 35898, this.RGB9_E5 = 35901, this.RGB16F = 34843, this.RGB32F = 34837, this.RGB8UI = 36221, this.RGBA8 = 32856, this.RGB5_A1 = 32855, this.RGBA16F = 34842, this.RGBA32F = 34836, this.RGBA8UI = 36220, this.RGBA16I = 36232, this.RGBA16UI = 36214, this.RGBA32I = 36226, this.RGBA32UI = 36208, this.NEAREST = 9728, this.LINEAR = 9729, this.NEAREST_MIPMAP_NEAREST = 9984, this.LINEAR_MIPMAP_NEAREST = 9985, this.NEAREST_MIPMAP_LINEAR = 9986, this.LINEAR_MIPMAP_LINEAR = 9987, this.REPEAT = 10497, this.CLAMP_TO_EDGE = 33071, this.MIRRORED_REPEAT = 33648, this.ZERO = 0, this.ONE = 1, this.SRC_COLOR = 768, this.ONE_MINUS_SRC_COLOR = 769, this.SRC_ALPHA = 770, this.ONE_MINUS_SRC_ALPHA = 771, this.DST_ALPHA = 772, this.ONE_MINUS_DST_ALPHA = 773, this.DST_COLOR = 774, this.ONE_MINUS_DST_COLOR = 775, this.SRC_ALPHA_SATURATE = 776, this.CONSTANT_COLOR = 32769, this.ONE_MINUS_CONSTANT_COLOR = 32770, this.CONSTANT_ALPHA = 32771, this.ONE_MINUS_CONSTANT_ALPHA = 32772, this.VERTEX_SHADER = 35633, this.FRAGMENT_SHADER = 35632, this.FRONT = 1028, this.BACK = 1029, this.FRONT_AND_BACK = 1032, this.NEVER = 512, this.LESS = 513, this.EQUAL = 514, this.LEQUAL = 515, this.GREATER = 516, this.NOTEQUAL = 517, this.GEQUAL = 518, this.ALWAYS = 519, this.KEEP = 7680, this.REPLACE = 7681, this.INCR = 7682, this.DECR = 7683, this.INCR_WRAP = 34055, this.DECR_WRAP = 34056, this.INVERT = 5386, this.STREAM_DRAW = 35040, this.STATIC_DRAW = 35044, this.DYNAMIC_DRAW = 35048, this.ARRAY_BUFFER = 34962, this.ELEMENT_ARRAY_BUFFER = 34963, this.POINTS = 0, this.LINES = 1, this.LINE_LOOP = 2, this.LINE_STRIP = 3, this.TRIANGLES = 4, this.TRIANGLE_STRIP = 5, this.TRIANGLE_FAN = 6, this.CW = 2304, this.CCW = 2305, this.CULL_FACE = 2884, this.DEPTH_TEST = 2929, this.BLEND = 3042, this.temp_vec3 = vec3.create(), this.temp2_vec3 = vec3.create(), this.temp_vec4 = vec4.create(), this.temp_quat = quat.create(), this.temp_mat3 = mat3.create(), this.temp_mat4 = mat4.create(), this.dragging = !1, this.last_pos = [0, 0];
  }
  /**
  * Tells if one number is power of two (used for textures)
  * @method isPowerOfTwo
  * @param {v} number
  * @return {boolean}
  */
  isPowerOfTwo(n) {
    return Math.log(n) / Math.log(2) % 1 == 0;
  }
  /**
  * Tells if one number is power of two (used for textures)
  * @method isPowerOfTwo
  * @param {v} number
  * @return {boolean}
  */
  nearestPowerOfTwo(n) {
    return Math.pow(2, Math.round(Math.log(n) / Math.log(2)));
  }
  /**
  * converts from polar to cartesian
  * @method polarToCartesian
  * @param {vec3} out
  * @param {number} azimuth orientation from 0 to 2PI
  * @param {number} inclianation from -PI to PI
  * @param {number} radius
  * @return {vec3} returns out
  */
  polarToCartesian(n, t, r, s) {
    return n = n || vec3.create(), n[0] = s * Math.sin(r) * Math.cos(t), n[1] = s * Math.cos(r), n[2] = s * Math.sin(r) * Math.sin(t), n;
  }
  /**
  * converts from cartesian to polar
  * @method cartesianToPolar
  * @param {vec3} out
  * @param {number} x
  * @param {number} y
  * @param {number} z
  * @return {vec3} returns [azimuth,inclination,radius]
  */
  cartesianToPolar(n, t, r, s) {
    return n = n || vec3.create(), n[2] = Math.sqrt(t * t + r * r + s * s), n[0] = Math.atan2(t, s), n[1] = Math.acos(s / n[2]), n;
  }
  /**
  * clone one object recursively, only allows objects containing number,strings,typed-arrays or other objects
  * @method cloneObject
  * @param {Object} object 
  * @param {Object} target if omited an empty object is created
  * @return {Object}
  */
  cloneObject(n, t) {
    if (n.constructor !== Object)
      throw "cloneObject only can clone pure javascript objects, not classes";
    t = t || {};
    for (var r in n) {
      var s = n[r];
      if (s === null) {
        t[r] = null;
        continue;
      }
      switch (s.constructor) {
        case Int8Array:
        case Uint8Array:
        case Int16Array:
        case Uint16Array:
        case Int32Array:
        case Uint32Array:
        case Float32Array:
        case Float64Array:
          t[r] = new s.constructor(s);
          break;
        case Boolean:
        case Number:
        case String:
          t[r] = s;
          break;
        case Array:
          t[r] = s.concat();
          break;
        case Object:
          t[r] = GL$1.cloneObject(s);
          break;
      }
    }
    return t;
  }
  createCanvas(n, t) {
    var r = document.createElement("canvas");
    return r.width = n, r.height = t, r;
  }
  cloneCanvas(n) {
    var t = document.createElement("canvas");
    t.width = n.width, t.height = n.height;
    var r = t.getContext("2d");
    return r.drawImage(n, 0, 0), t;
  }
  //copy methods from origin to target
  extendClass(n, t) {
    for (var r in t)
      n.hasOwnProperty(r) || (n[r] = t[r]);
    if (t.prototype)
      for (var s = Object.getOwnPropertyNames(t.prototype), r = 0; r < s.length; ++r) {
        var a = s[r];
        n.prototype.hasOwnProperty(a) || (t.prototype.__lookupGetter__(a) ? n.prototype.__defineGetter__(a, t.prototype.__lookupGetter__(a)) : n.prototype[a] = t.prototype[a], t.prototype.__lookupSetter__(a) && n.prototype.__defineSetter__(a, t.prototype.__lookupSetter__(a)));
      }
    n.hasOwnProperty("superclass") || Object.defineProperty(n, "superclass", {
      get: function() {
        return t;
      },
      enumerable: !1
    });
  }
  // unused but cool
  RGBToHex(n, t, r) {
    return n = Math.min(255, n * 255) | 0, t = Math.min(255, t * 255) | 0, r = Math.min(255, r * 255) | 0, "#" + ((1 << 24) + (n << 16) + (t << 8) + r).toString(16).slice(1);
  }
  // unused but cool
  HUEToRGB(n, t, r) {
    return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? n + (t - n) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? n + (t - n) * (2 / 3 - r) * 6 : n;
  }
  // unused but cool
  HSLToRGB(n, t, r, s) {
    var a, o, u;
    if (s = s || vec3.create(), t == 0)
      a = o = u = r;
    else {
      var h = r < 0.5 ? r * (1 + t) : r + t - r * t, l = 2 * r - h;
      a = HUEToRGB(l, h, n + 1 / 3), o = HUEToRGB(l, h, n), u = HUEToRGB(l, h, n - 1 / 3);
    }
    return s[0] = a, s[1] = o, s[2] = u, s;
  }
  linearizeArray(n, t) {
    if (n.constructor === t)
      return n;
    if (n.constructor !== Array)
      return t = t || Float32Array, new t(n);
    t = t || Float32Array;
    for (var r = n[0].length, s = n.length * r, a = new t(s), o = 0; o < n.length; ++o)
      for (var u = 0; u < r; ++u)
        a[o * r + u] = n[o][u];
    return a;
  }
  /**
  * creates a new WebGL context (it can create the canvas or use an existing one)
  * @method create
  * @param {Object} options supported are: 
  * - width
  * - height
  * - canvas
  * - container (string or element)
  * @return {WebGLRenderingContext} webgl context with all the extra functions (check gl in the doc for more info)
  */
  create(n = {}) {
    var t = null;
    if (n.canvas)
      if (typeof n.canvas == "string") {
        if (t = document.getElementById(n.canvas), !t) throw "Canvas element not found: " + n.canvas;
      } else
        t = n.canvas;
    else {
      var r = null;
      if (n.container && (r = n.container.constructor === String ? document.querySelector(n.container) : n.container), r && !n.width) {
        var s = r.getBoundingClientRect();
        n.width = s.width, n.height = s.height;
      }
      t = GL$1.createCanvas(n.width || 800, n.height || 600), r && r.appendChild(t);
    }
    "alpha" in n || (n.alpha = !1);
    var a = null, o = null;
    if (n.version == 2 ? o = ["webgl2", "experimental-webgl2"] : n.version == 1 || n.version === void 0 ? o = ["webgl", "experimental-webgl"] : n.version === 0 && (o = ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"]), !o)
      throw "Incorrect WebGL version, must be 1 or 2";
    for (var u = {
      alpha: n.alpha === void 0 ? !0 : n.alpha,
      depth: n.depth === void 0 ? !0 : n.depth,
      stencil: n.stencil === void 0 ? !0 : n.stencil,
      antialias: n.antialias === void 0 ? !0 : n.antialias,
      premultipliedAlpha: n.premultipliedAlpha === void 0 ? !0 : n.premultipliedAlpha,
      preserveDrawingBuffer: n.preserveDrawingBuffer === void 0 ? !0 : n.preserveDrawingBuffer
    }, h = 0; h < o.length; ++h) {
      try {
        a = t.getContext(o[h], u);
      } catch {
      }
      if (a)
        break;
    }
    if (!a)
      throw t.getContext("webgl") ? "WebGL supported but not with those parameters" : "WebGL not supported";
    a.webgl_version = a.constructor.name === "WebGL2RenderingContext" ? 2 : 1, global$1.gl = a, t.is_webgl = !0, t.gl = a, a.context_id = this.last_context_id++;
    var l = a.getSupportedExtensions();
    a.extensions = {};
    for (var h in l)
      a.extensions[l[h]] = a.getExtension(l[h]);
    if (a.derivatives_supported = a.extensions.OES_standard_derivatives != null || a.webgl_version > 1, a.webgl_version == 1 ? a.HIGH_PRECISION_FORMAT = a.extensions.OES_texture_half_float ? GL$1.HALF_FLOAT_OES : a.extensions.OES_texture_float ? GL$1.FLOAT : GL$1.UNSIGNED_BYTE : a.HIGH_PRECISION_FORMAT = GL$1.HALF_FLOAT_OES, a.max_texture_units = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), a._viewport_func ? console.warn("Creating LiteGL context over the same canvas twice") : (a._viewport_func = a.viewport, a.viewport_data = new Float32Array([0, 0, a.canvas.width, a.canvas.height]), a.viewport = function(b, I, S, N) {
      var C = this.viewport_data;
      C[0] = b | 0, C[1] = I | 0, C[2] = S | 0, C[3] = N | 0, this._viewport_func(b, I, S, N);
    }, a.getViewport = function(b) {
      return b ? (b[0] = a.viewport_data[0], b[1] = a.viewport_data[1], b[2] = a.viewport_data[2], b[3] = a.viewport_data[3], b) : new Float32Array(a.viewport_data);
    }, a.setViewport = function(b, I) {
      a.viewport_data.set(b), I && (a.viewport_data[1] = this.drawingBufferHeight - b[1] - b[3]), this._viewport_func(b[0], a.viewport_data[1], b[2], b[3]);
    }), !GL$1.reverse) {
      GL$1.reverse = {};
      for (var h in a)
        a[h] && a[h].constructor === Number && (GL$1.reverse[a[h]] = h);
    }
    if (typeof glMatrix == "undefined")
      throw "glMatrix not found, LiteGL requires glMatrix to be included";
    var c = 0;
    a.shaders = {}, a.textures = {}, a.meshes = {}, a.makeCurrent = function() {
      global$1.gl = this;
    }, a.execute = function(b) {
      var I = global$1.gl;
      global$1.gl = this, b(), global$1.gl = I;
    }, a.animate = function(b) {
      if (b === !1) {
        global$1.cancelAnimationFrame(this._requestFrame_id), this._requestFrame_id = null;
        return;
      }
      var I = global$1.requestAnimationFrame, S = getTime(), N = this;
      function C() {
        if (!a.destroyed) {
          N._requestFrame_id = I(C);
          var D = getTime(), M = (D - S) * 1e-3;
          if (N.mouse && (N.mouse.last_buttons = N.mouse.buttons), N.onupdate && N.onupdate(M), LEvent.trigger(N, "update", M), N.ondraw) {
            var P = global$1.gl;
            global$1.gl = N, N.ondraw(), LEvent.trigger(N, "draw"), global$1.gl = P;
          }
          S = D;
        }
      }
      this._requestFrame_id = I(C);
    }, a.destroy = function() {
      T && (document.removeEventListener("keydown", T), document.removeEventListener("keyup", T)), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.destroyed = !0, global$1.gl == this && (global$1.gl = null);
    };
    var d = a.mouse = {
      buttons: 0,
      //this should always be up-to-date with mouse state
      last_buttons: 0,
      //button state in the previous frame
      left_button: !1,
      middle_button: !1,
      right_button: !1,
      position: new Float32Array(2),
      x: 0,
      //in canvas coordinates
      y: 0,
      deltax: 0,
      deltay: 0,
      clientx: 0,
      //in client coordinates
      clienty: 0,
      isInsideRect: function(b, I, S, N, C) {
        var D = this.y;
        return C && (D = a.canvas.height - D), this.x > b && this.x < b + S && D > I && D < I + N;
      },
      /**
      * returns true if button num is pressed (where num could be GL.LEFT_MOUSE_BUTTON, GL.RIGHT_MOUSE_BUTTON, GL.MIDDLE_MOUSE_BUTTON
      * @method captureMouse
      * @param {boolean} capture_wheel capture also the mouse wheel
      */
      isButtonPressed: function(b) {
        if (b == GL$1.LEFT_MOUSE_BUTTON)
          return this.buttons & GL$1.LEFT_MOUSE_BUTTON_MASK;
        if (b == GL$1.MIDDLE_MOUSE_BUTTON)
          return this.buttons & GL$1.MIDDLE_MOUSE_BUTTON_MASK;
        if (b == GL$1.RIGHT_MOUSE_BUTTON)
          return this.buttons & GL$1.RIGHT_MOUSE_BUTTON_MASK;
      },
      wasButtonPressed: function(b) {
        var I = 0;
        return b == GL$1.LEFT_MOUSE_BUTTON ? I = GL$1.LEFT_MOUSE_BUTTON_MASK : b == GL$1.MIDDLE_MOUSE_BUTTON ? I = GL$1.MIDDLE_MOUSE_BUTTON_MASK : b == GL$1.RIGHT_MOUSE_BUTTON && (I = GL$1.RIGHT_MOUSE_BUTTON_MASK), this.buttons & I && !(this.last_buttons & I);
      }
    };
    a.captureMouse = function(b, I) {
      t.addEventListener("pointerdown", f), t.addEventListener("pointermove", f), t.addEventListener("dragstart", f), b && t.addEventListener("wheel", f, !1), t.addEventListener("contextmenu", function(S) {
        return S.preventDefault(), !1;
      }), I && this.captureTouch(!0);
    };
    function f(b) {
      if (!a.ignore_events) {
        var I = a.mouse.buttons;
        GL$1.augmentEvent(b, t), b.eventType = b.eventType || b.type;
        var S = getTime();
        if (d.dragging = b.dragging, d.position[0] = b.canvasx, d.position[1] = b.canvasy, d.x = b.canvasx, d.y = b.canvasy, d.mousex = b.mousex, d.mousey = b.mousey, d.canvasx = b.canvasx, d.canvasy = b.canvasy, d.clientx = b.mousex, d.clienty = b.mousey, d.buttons = b.buttons, d.left_button = !!(d.buttons & GL$1.LEFT_MOUSE_BUTTON_MASK), d.middle_button = !!(d.buttons & GL$1.MIDDLE_MOUSE_BUTTON_MASK), d.right_button = !!(d.buttons & GL$1.RIGHT_MOUSE_BUTTON_MASK), b.eventType == "pointerdown") {
          if (I == 0) {
            t.removeEventListener("pointermove", f);
            var N = t.ownerDocument;
            N.addEventListener("pointermove", f), N.addEventListener("pointerup", f);
          }
          c = S, a.onmousedown && a.onmousedown(b), LEvent.trigger(a, "pointerdown");
        } else if (b.eventType == "pointermove")
          a.onmousemove && a.onmousemove(b), LEvent.trigger(a, "pointermove", b);
        else if (b.eventType == "pointerup") {
          if (a.mouse.buttons == 0) {
            t.addEventListener("pointermove", f);
            var N = t.ownerDocument;
            N.removeEventListener("pointermove", f), N.removeEventListener("pointerup", f);
          }
          b.click_time = S - c, a.onmouseup && a.onmouseup(b), LEvent.trigger(a, "pointerup", b);
        } else b.eventType == "wheel" ? (b.type == "wheel" ? b.wheel = -b.deltaY : b.wheel = b.wheelDeltaY != null ? b.wheelDeltaY : b.detail * -60, b.delta = b.wheelDelta !== void 0 ? b.wheelDelta / 40 : b.deltaY ? -b.deltaY / 3 : 0, a.onmousewheel && a.onmousewheel(b), LEvent.trigger(a, "wheel", b)) : b.eventType == "dragstart" && (a.ondragstart && a.ondragstart(b), LEvent.trigger(a, "dragstart", b));
        if (a.onmouse && a.onmouse(b), !b.skip_preventDefault)
          return b.eventType != "pointermove" && b.stopPropagation(), b.preventDefault(), !1;
      }
    }
    var _ = !1;
    a.captureTouch = function(b) {
      _ = b, t.addEventListener("touchstart", E, !0), t.addEventListener("touchmove", E, !0), t.addEventListener("touchend", E, !0), t.addEventListener("touchcancel", E, !0), t.addEventListener("gesturestart", m), t.addEventListener("gesturechange", m), t.addEventListener("gestureend", m);
    };
    function E(b) {
      var I = b.changedTouches, S = I[0], N = "";
      if (!(a.ontouch && a.ontouch(b) === !0) && LEvent.trigger(a, b.type, b) !== !0 && _ && !(b.touches.length && b.changedTouches[0].identifier !== b.touches[0].identifier) && !(I > 1)) {
        switch (b.type) {
          case "touchstart":
            N = "pointerdown";
            break;
          case "touchmove":
            N = "pointermove";
            break;
          case "touchend":
            N = "pointerup";
            break;
          default:
            return;
        }
        var C = document.createEvent("MouseEvent");
        C.initMouseEvent(
          N,
          !0,
          !0,
          window,
          1,
          S.screenX,
          S.screenY,
          S.clientX,
          S.clientY,
          !1,
          !1,
          !1,
          !1,
          0,
          null
        ), C.originalEvent = C, C.is_touch = !0, S.target.dispatchEvent(C), b.preventDefault();
      }
    }
    function m(b) {
      b.eventType = b.type, !(a.ongesture && a.ongesture(b) === !1) && LEvent.trigger(a, b.type, b) !== !1 && b.preventDefault();
    }
    a.keys = {};
    var T = null;
    a.captureKeys = function(b, I) {
      if (T)
        return;
      a.keys = {}, I && a.canvas, document.addEventListener("keydown", S), document.addEventListener("keyup", S);
      function S(N) {
        L(N, b);
      }
      T = S;
    };
    function L(b, I) {
      b.eventType = b.type;
      var S = b.target.nodeName.toLowerCase();
      if (!(S === "input" || S === "textarea" || S === "select")) {
        b.character = String.fromCharCode(b.keyCode).toLowerCase();
        var N = !1, C = GL$1.mapKeyCode(b.keyCode);
        C || (C = b.character), !b.altKey && !b.ctrlKey && !b.metaKey && (C && (a.keys[C] = b.type == "keydown"), N = a.keys[b.keyCode], a.keys[b.keyCode] = b.type == "keydown"), N != a.keys[b.keyCode] && (b.type == "keydown" && a.onkeydown ? a.onkeydown(b) : b.type == "keyup" && a.onkeyup && a.onkeyup(b), LEvent.trigger(a, b.type, b)), a.onkey && a.onkey(b), I && (b.isChar || GL$1.blockable_keys[b.keyIdentifier || b.key]) && b.preventDefault();
      }
    }
    a.gamepads = null, a.captureGamepads = function() {
      var b = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
      b && (this.gamepads = b.call(navigator));
    }, a.getGamepads = function(b) {
      var I = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
      if (I) {
        var S = I.call(navigator);
        this.gamepads || (this.gamepads = []);
        for (var N = 0; N < 4; N++) {
          var C = S[N];
          if (C && !b && G(C), C && !C.prev_buttons) {
            C.prev_buttons = new Uint8Array(32);
            var D = new CustomEvent("gamepadconnected");
            D.eventType = D.type, D.gamepad = C, this.ongamepadconnected && this.ongamepadconnected(D), LEvent.trigger(a, "gamepadconnected", D);
          }
          if (C)
            for (var M = 0; M < C.buttons.length; ++M) {
              var P = C.buttons[M];
              if (P.was_pressed = !1, P.pressed && !C.prev_buttons[M]) {
                P.was_pressed = !0;
                var D = new CustomEvent("gamepadButtonDown");
                D.eventType = D.type, D.button = P, D.which = M, D.gamepad = C, a.onbuttondown && a.onbuttondown(D), LEvent.trigger(a, "buttondown", D);
              } else if (!P.pressed && C.prev_buttons[M]) {
                var D = new CustomEvent("gamepadButtonUp");
                D.eventType = D.type, D.button = P, D.which = M, D.gamepad = C, a.onbuttondown && a.onbuttondown(D), LEvent.trigger(a, "buttonup", D);
              }
              C.prev_buttons[M] = P.pressed ? 1 : 0;
            }
        }
        return this.gamepads = S, S;
      }
    };
    function G(b) {
      var I = b.xbox || { axes: [], buttons: {}, hat: "" };
      I.axes.lx = b.axes[0], I.axes.ly = b.axes[1], I.axes.rx = b.axes[2], I.axes.ry = b.axes[3], I.axes.triggers = b.axes[4];
      for (var S = 0; S < b.buttons.length; S++)
        switch (S) {
          case 0:
            I.buttons.a = b.buttons[S].pressed;
            break;
          case 1:
            I.buttons.b = b.buttons[S].pressed;
            break;
          case 2:
            I.buttons.x = b.buttons[S].pressed;
            break;
          case 3:
            I.buttons.y = b.buttons[S].pressed;
            break;
          case 4:
            I.buttons.lb = b.buttons[S].pressed;
            break;
          case 5:
            I.buttons.rb = b.buttons[S].pressed;
            break;
          case 6:
            I.buttons.lt = b.buttons[S].pressed;
            break;
          case 7:
            I.buttons.rt = b.buttons[S].pressed;
            break;
          case 8:
            I.buttons.back = b.buttons[S].pressed;
            break;
          case 9:
            I.buttons.start = b.buttons[S].pressed;
            break;
          case 10:
            I.buttons.ls = b.buttons[S].pressed;
            break;
          case 11:
            I.buttons.rs = b.buttons[S].pressed;
            break;
          case 12:
            b.buttons[S].pressed && (I.hat += "up");
            break;
          case 13:
            b.buttons[S].pressed && (I.hat += "down");
            break;
          case 14:
            b.buttons[S].pressed && (I.hat += "left");
            break;
          case 15:
            b.buttons[S].pressed && (I.hat += "right");
            break;
          case 16:
            I.buttons.home = b.buttons[S].pressed;
            break;
        }
      b.xbox = I;
    }
    a.fullscreen = function() {
      var b = this.canvas;
      b.requestFullScreen ? b.requestFullScreen() : b.webkitRequestFullScreen ? b.webkitRequestFullScreen() : b.mozRequestFullScreen ? b.mozRequestFullScreen() : console.error("Fullscreen not supported");
    }, a.snapshot = function(b, I, S, N, C) {
      var D = GL$1.createCanvas(S, N), R = D.getContext("2d"), M = R.getImageData(0, 0, D.width, D.height), P = new Uint8Array(S * N * 4);
      if (a.readPixels(b, I, D.width, D.height, a.RGBA, a.UNSIGNED_BYTE, P), M.data.set(P), R.putImageData(M, 0, 0), C)
        return D;
      var A = GL$1.createCanvas(S, N), R = A.getContext("2d");
      return R.translate(0, N), R.scale(1, -1), R.drawImage(D, 0, 0), A;
    };
    var O = {};
    return a.loadTexture = function(b, I, S) {
      if (this.textures[b])
        return this.textures[b];
      if (O[b])
        return null;
      var N = new Image();
      return N.url = b, N.onload = function() {
        var C = GL$1.Texture.fromImage(this, I);
        C.img = this, a.textures[this.url] = C, delete O[this.url], S && S(C);
      }, N.src = b, O[b] = !0, null;
    }, a.drawTexture = (function() {
      var b = mat3.create(), I = vec2.create(), S = vec2.create(), N = vec4.create(), C = vec4.fromValues(1, 1, 1, 1), D = vec2.create(), M = { u_texture: 0, u_position: I, u_color: C, u_size: S, u_texture_area: N, u_viewport: D, u_transform: b };
      return (function(P, A, R, B, X, F, V, $, U, H, z) {
        I[0] = A, I[1] = R, B === void 0 && (B = P.width), X === void 0 && (X = P.height), S[0] = B, S[1] = X, F === void 0 && (F = 0), V === void 0 && (V = 0), $ === void 0 && ($ = P.width), U === void 0 && (U = P.height), N[0] = F / P.width, N[1] = V / P.height, N[2] = (F + $) / P.width, N[3] = (V + U) / P.height, D[0] = this.viewport_data[2], D[1] = this.viewport_data[3], H = H || Shader.getPartialQuadShader(this);
        var K = Mesh$1.getScreenQuad(this);
        P.bind(0), H.uniforms(M), z && H.uniforms(z), H.draw(K, a.TRIANGLES);
      });
    })(), a.canvas.addEventListener("webglcontextlost", function(b) {
      b.preventDefault(), a.context_lost = !0, a.onlosecontext && a.onlosecontext(b);
    }, !1), a.reset = function() {
      a.viewport(0, 0, this.canvas.width, this.canvas.height), a.disable(a.BLEND), a.disable(a.CULL_FACE), a.disable(a.DEPTH_TEST), a.frontFace(a.CCW), a._current_texture_drawto = null, a._current_fbo_color = null, a._current_fbo_depth = null;
    }, a.dump = function() {
      console.log("userAgent: ", navigator.userAgent), console.log("Supported extensions:");
      var b = a.getSupportedExtensions();
      console.log(b.join(","));
      var I = ["VENDOR", "VERSION", "MAX_VERTEX_ATTRIBS", "MAX_VARYING_VECTORS", "MAX_VERTEX_UNIFORM_VECTORS", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", "MAX_FRAGMENT_UNIFORM_VECTORS", "MAX_TEXTURE_SIZE", "MAX_TEXTURE_IMAGE_UNITS"];
      console.log("WebGL info:");
      for (var S in I)
        console.log(" * " + I[S] + ": " + a.getParameter(a[I[S]]));
      console.log("*************************************************");
    }, a.reset(), a;
  }
  mapKeyCode(n) {
    var t = {
      8: "BACKSPACE",
      9: "TAB",
      13: "ENTER",
      16: "SHIFT",
      17: "CTRL",
      27: "ESCAPE",
      32: "SPACE",
      37: "LEFT",
      38: "UP",
      39: "RIGHT",
      40: "DOWN"
    };
    return t[n] || (n >= 65 && n <= 90 ? String.fromCharCode(n) : null);
  }
  //adds extra info to the MouseEvent (coordinates in canvas axis, deltas and button state)
  augmentEvent(n, t) {
    var r = null;
    t = t || n.target || gl.canvas, r = t.getBoundingClientRect(), n.mousex = n.clientX - r.left, n.mousey = n.clientY - r.top, n.canvasx = n.mousex, n.canvasy = r.height - n.mousey, n.deltax = 0, n.deltay = 0, n.type == "pointerdown" ? this.dragging = !0 : n.type == "pointermove" || n.type == "pointerup" && n.buttons == 0 && (this.dragging = !1), n.movementX !== void 0 && !GL$1.isMobile() ? (n.deltax = n.movementX, n.deltay = n.movementY) : (n.deltax = n.mousex - this.last_pos[0], n.deltay = n.mousey - this.last_pos[1]), this.last_pos[0] = n.mousex, this.last_pos[1] = n.mousey, n.dragging = this.dragging, n.leftButton = !!(gl.mouse.buttons & GL$1.LEFT_MOUSE_BUTTON_MASK), n.middleButton = !!(gl.mouse.buttons & GL$1.MIDDLE_MOUSE_BUTTON_MASK), n.rightButton = !!(gl.mouse.buttons & GL$1.RIGHT_MOUSE_BUTTON_MASK), n.buttons_mask = 0, n.leftButton && (n.buttons_mask = 1), n.middleButton && (n.buttons_mask |= 2), n.rightButton && (n.buttons_mask |= 4), n.isButtonPressed = function(s) {
      return this.buttons_mask & 1 << s;
    };
  }
  /**
  * Tells you if the app is running on a mobile device (iOS or Android)
  * @method isMobile
  * @return {boolean} true if is running on a iOS or Android device
  */
  isMobile() {
    return this.mobile !== void 0 ? this.mobile : global$1.navigator ? navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/Android/i) ? this.mobile = !0 : this.mobile = !1 : this.mobile = !1;
  }
}();
const EPSILON = 1e-6;
var typed_arrays = [Uint8Array, Int8Array, Uint16Array, Int16Array, Uint32Array, Int32Array, Float32Array, Float64Array];
function typedToArray() {
  return Array.prototype.slice.call(this);
}
typed_arrays.forEach(function(n) {
  n.prototype.toJSON || Object.defineProperty(n.prototype, "toJSON", {
    value: typedToArray,
    enumerable: !1
  });
});
typeof performance != "undefined" ? global$1.getTime = performance.now.bind(performance) : global$1.getTime = Date.now.bind(Date);
GL$1.getTime = global$1.getTime;
typeof Image != "undefined" && (Image.prototype.getPixels = function() {
  var n = document.createElement("canvas");
  n.width = this.width, n.height = this.height;
  var t = n.getContext("2d");
  return t.drawImage(this, 0, 0), t.getImageData(0, 0, this.width, this.height).data;
});
String.prototype.hasOwnProperty("replaceAll") || Object.defineProperty(String.prototype, "replaceAll", {
  value: function(n) {
    var t = this;
    for (var r in n)
      t = t.split(r).join(n[r]);
    return t;
  },
  enumerable: !1
});
String.prototype.hasOwnProperty("hashCode") || Object.defineProperty(String.prototype, "hashCode", {
  value: function() {
    var n = 0, t, r, s;
    if (this.length == 0) return n;
    for (t = 0, s = this.length; t < s; ++t)
      r = this.charCodeAt(t), n = (n << 5) - n + r, n |= 0;
    return n;
  },
  enumerable: !1
});
Array.prototype.hasOwnProperty("clone") || Object.defineProperty(Array.prototype, "clone", { value: Array.prototype.concat, enumerable: !1 });
Float32Array.prototype.hasOwnProperty("clone") || Object.defineProperty(Float32Array.prototype, "clone", { value: function() {
  return new Float32Array(this);
}, enumerable: !1 });
global$1.HttpRequest = GL$1.request = function n(t, r, s, a, o) {
  var u = !0;
  if (o && o.async !== void 0 && (u = o.async), r) {
    var h = null, l = [];
    for (var c in r)
      l.push(c + "=" + r[c]);
    h = l.join("&"), t = t + "?" + h;
  }
  var d = new XMLHttpRequest();
  if (d.open("GET", t, u), d.onload = function(f) {
    if (this.response, this.getResponseHeader("Content-Type"), this.status != 200) {
      LEvent.trigger(d, "fail", this.status), a && a(this.status);
      return;
    }
    LEvent.trigger(d, "done", this.response), s && s(this.response);
  }, d.onerror = function(f) {
    LEvent.trigger(d, "fail", f);
  }, o) {
    for (var c in o)
      d[c] = o[c];
    o.binary && (d.responseType = "arraybuffer");
  }
  return d.send(), d;
};
global$1.XMLHttpRequest && (XMLHttpRequest.prototype.hasOwnProperty("done") || Object.defineProperty(XMLHttpRequest.prototype, "done", { enumerable: !1, value: function(n) {
  return LEvent.bind(this, "done", function(t, r) {
    n(r);
  }), this;
} }), XMLHttpRequest.prototype.hasOwnProperty("fail") || Object.defineProperty(XMLHttpRequest.prototype, "fail", { enumerable: !1, value: function(n) {
  return LEvent.bind(this, "fail", function(t, r) {
    n(r);
  }), this;
} }));
if (typeof glMatrix == "undefined")
  throw new Error("You must include glMatrix on your project");
Math.clamp = function(n, t, r) {
  return t > n ? t : r < n ? r : n;
};
vec3.create;
vec3.create;
vec3.ZERO = vec3.fromValues(0, 0, 0);
vec3.FRONT = vec3.fromValues(0, 0, -1);
vec3.UP = vec3.fromValues(0, 1, 0);
vec3.RIGHT = vec3.fromValues(1, 0, 0);
vec2.rotate = function(n, t, r) {
  var s = t[0], a = t[1], o = Math.cos(r), u = Math.sin(r);
  return n[0] = s * o - a * u, n[1] = s * u + a * o, n;
};
vec3.zero = function(n) {
  return n[0] = n[1] = 0, n;
};
vec2.perpdot = function(n, t) {
  return n[1] * t[0] + -n[0] * t[1];
};
vec2.computeSignedAngle = function(n, t) {
  return Math.atan2(vec2.perpdot(n, t), vec2.dot(n, t));
};
vec2.random = function(n, t) {
  return t = t || 1, n[0] = Math.random() * t, n[1] = Math.random() * t, n;
};
vec3.zero = function(n) {
  return n[0] = n[1] = n[2] = 0, n;
};
vec3.minValue = function(n) {
  return n[0] < n[1] && n[0] < n[2] ? n[0] : n[1] < n[2] ? n[1] : n[2];
};
vec3.maxValue = function(n) {
  return n[0] > n[1] && n[0] > n[2] ? n[0] : n[1] > n[2] ? n[1] : n[2];
};
vec3.minValue = function(n) {
  return n[0] < n[1] && n[0] < n[2] ? n[0] : n[1] < n[2] ? n[1] : n[2];
};
vec3.addValue = function(n, t, r) {
  n[0] = t[0] + r, n[1] = t[1] + r, n[2] = t[2] + r;
};
vec3.subValue = function(n, t, r) {
  n[0] = t[0] - r, n[1] = t[1] - r, n[2] = t[2] - r;
};
vec3.toArray = function(n) {
  return [n[0], n[1], n[2]];
};
vec3.rotateX = function(n, t, r) {
  var s = t[1], a = t[2], o = Math.cos(r), u = Math.sin(r);
  return n[0] = t[0], n[1] = s * o - a * u, n[2] = s * u + a * o, n;
};
vec3.rotateY = function(n, t, r) {
  var s = t[0], a = t[2], o = Math.cos(r), u = Math.sin(r);
  return n[0] = s * o - a * u, n[1] = t[1], n[2] = s * u + a * o, n;
};
vec3.rotateZ = function(n, t, r) {
  var s = t[0], a = t[1], o = Math.cos(r), u = Math.sin(r);
  return n[0] = s * o - a * u, n[1] = s * u + a * o, n[2] = t[2], n;
};
vec3.angle = function(n, t) {
  return Math.acos(vec3.dot(n, t));
};
vec3.signedAngle = function(n, t, r) {
  var s = vec3.angle(n, t), a = n[1] * t[2] - n[2] * t[1], o = n[2] * t[0] - n[0] * t[2], u = n[0] * t[1] - n[1] * t[0], h = Math.sign(r[0] * a + r[1] * o + r[2] * u);
  return s * h;
};
vec3.random = function(n, t) {
  return t = t || 1, n[0] = Math.random() * t, n[1] = Math.random() * t, n[2] = Math.random() * t, n;
};
vec3.polarToCartesian = function(n, t) {
  var r = t[0], s = t[1], a = t[2];
  return n[0] = r * Math.cos(s) * Math.sin(a), n[1] = r * Math.sin(s), n[2] = r * Math.cos(s) * Math.cos(a), n;
};
vec3.reflect = function(n, t, r) {
  var s = t[0], a = t[1], o = t[2];
  return vec3.scale(n, r, -2 * vec3.dot(t, r)), n[0] += s, n[1] += a, n[2] += o, n;
};
vec4.random = function(n, t) {
  return t = t || 1, n[0] = Math.random() * t, n[1] = Math.random() * t, n[2] = Math.random() * t, n[3] = Math.random() * t, n;
};
vec4.toArray = function(n) {
  return [n[0], n[1], n[2], n[3]];
};
mat3.IDENTITY = mat3.create();
mat4.IDENTITY = mat4.create();
mat4.toArray = function(n) {
  return [n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]];
};
mat4.setUpAndOrthonormalize = function(n, t, r) {
  t != n && mat4.copy(n, t);
  var s = n.subarray(0, 3);
  vec3.normalize(n.subarray(4, 7), r);
  var a = n.subarray(8, 11);
  vec3.cross(s, r, a), vec3.normalize(s, s), vec3.cross(a, s, r), vec3.normalize(a, a);
};
mat4.multiplyVec3 = function(n, t, r) {
  var s = r[0], a = r[1], o = r[2];
  return n[0] = t[0] * s + t[4] * a + t[8] * o + t[12], n[1] = t[1] * s + t[5] * a + t[9] * o + t[13], n[2] = t[2] * s + t[6] * a + t[10] * o + t[14], n;
};
mat4.projectVec3 = function(n, t, r) {
  var s = r[0], a = r[1], o = r[2], u = t[0] * s + t[4] * a + t[8] * o + t[12], h = t[1] * s + t[5] * a + t[9] * o + t[13], l = t[2] * s + t[6] * a + t[10] * o + t[14], c = t[3] * s + t[7] * a + t[11] * o + t[15];
  return n[0] = (u / c + 1) / 2, n[1] = (h / c + 1) / 2, n[2] = (l / c + 1) / 2, n;
};
vec3.project = function(n, t, r, s) {
  s = s || gl.viewport_data;
  var a = r, o = t[0], u = t[1], h = t[2], l = a[0] * o + a[4] * u + a[8] * h + a[12], c = a[1] * o + a[5] * u + a[9] * h + a[13], d = a[2] * o + a[6] * u + a[10] * h + a[14], f = a[3] * o + a[7] * u + a[11] * h + a[15], _ = (l / f + 1) / 2, E = 1 - (c / f + 1) / 2, m = (d / f + 1) / 2;
  return n[0] = _ * s[2] + s[0], n[1] = E * s[3] + s[1], n[2] = m, n;
};
var unprojectMat = mat4.create(), unprojectVec = vec4.create();
vec3.unproject = function(n, t, r, s) {
  var a = unprojectMat, o = unprojectVec;
  return o[0] = (t[0] - s[0]) * 2 / s[2] - 1, o[1] = (t[1] - s[1]) * 2 / s[3] - 1, o[2] = 2 * t[2] - 1, o[3] = 1, !mat4.invert(a, r) || (vec4.transformMat4(o, o, a), o[3] === 0) ? null : (n[0] = o[0] / o[3], n[1] = o[1] / o[3], n[2] = o[2] / o[3], n);
};
mat4.rotateVec3 = function(n, t, r) {
  var s = r[0], a = r[1], o = r[2];
  return n[0] = t[0] * s + t[4] * a + t[8] * o, n[1] = t[1] * s + t[5] * a + t[9] * o, n[2] = t[2] * s + t[6] * a + t[10] * o, n;
};
mat4.fromTranslationFrontTop = function(n, t, r, s) {
  return vec3.cross(n.subarray(0, 3), r, s), n.set(s, 4), n.set(r, 8), n.set(t, 12), n;
};
mat4.translationMatrix = function(n) {
  var t = mat4.create();
  return t[12] = n[0], t[13] = n[1], t[14] = n[2], t;
};
mat4.setTranslation = function(n, t) {
  return n[12] = t[0], n[13] = t[1], n[14] = t[2], n;
};
mat4.getTranslation = function(n, t) {
  return n[0] = t[12], n[1] = t[13], n[2] = t[14], n;
};
mat4.toRotationMat4 = function(n, t) {
  return mat4.copy(n, t), n[12] = n[13] = n[14] = 0, n;
};
mat4.swapRows = function(n, t, r, s) {
  if (n != t)
    return mat4.copy(n, t), n[4 * r] = t[4 * s], n[4 * r + 1] = t[4 * s + 1], n[4 * r + 2] = t[4 * s + 2], n[4 * r + 3] = t[4 * s + 3], n[4 * s] = t[4 * r], n[4 * s + 1] = t[4 * r + 1], n[4 * s + 2] = t[4 * r + 2], n[4 * s + 3] = t[4 * r + 3], n;
  var a = new Float32Array(matrix.subarray(r * 4, r * 5));
  return matrix.set(matrix.subarray(s * 4, s * 5), r * 4), matrix.set(a, s * 4), n;
};
mat4.scaleAndAdd = function(n, t, r, s) {
  return n[0] = t[0] + r[0] * s, n[1] = t[1] + r[1] * s, n[2] = t[2] + r[2] * s, n[3] = t[3] + r[3] * s, n[4] = t[4] + r[4] * s, n[5] = t[5] + r[5] * s, n[6] = t[6] + r[6] * s, n[7] = t[7] + r[7] * s, n[8] = t[8] + r[8] * s, n[9] = t[9] + r[9] * s, n[10] = t[10] + r[10] * s, n[11] = t[11] + r[11] * s, n[12] = t[12] + r[12] * s, n[13] = t[13] + r[13] * s, n[14] = t[14] + r[14] * s, n[15] = t[15] + r[15] * s, n;
};
quat.fromAxisAngle = function(n, t) {
  var r = quat.create();
  t = t * 0.5;
  var s = Math.sin(t);
  return r[0] = s * n[0], r[1] = s * n[1], r[2] = s * n[2], r[3] = Math.cos(t), r;
};
quat.lookRotation = (function() {
  var n = vec3.create(), t = vec3.create(), r = vec3.create();
  return function(s, a, o) {
    vec3.normalize(n, a), vec3.cross(t, o, n), vec3.normalize(t, t), vec3.cross(r, n, t);
    var u = t[0], h = t[1], l = t[2], c = r[0], d = r[1], f = r[2], _ = n[0], E = n[1], m = n[2], T = u + d + m;
    if (T > 0) {
      var L = Math.sqrt(T + 1);
      return s[3] = L * 0.5, L = 0.5 / L, s[0] = (f - E) * L, s[1] = (_ - l) * L, s[2] = (h - c) * L, s;
    }
    if (u >= d && u >= m) {
      var G = Math.sqrt(1 + u - d - m), O = 0.5 / G;
      return s[0] = 0.5 * G, s[1] = (h + c) * O, s[2] = (l + _) * O, s[3] = (f - E) * O, s;
    }
    if (d > m) {
      var b = Math.sqrt(1 + d - u - m), I = 0.5 / b;
      return s[0] = (c + h) * I, s[1] = 0.5 * b, s[2] = (E + f) * I, s[3] = (_ - l) * I, s;
    }
    var S = Math.sqrt(1 + m - u - d), N = 0.5 / S;
    return s[0] = (_ + l) * N, s[1] = (E + f) * N, s[2] = 0.5 * S, s[3] = (h - c) * N, s;
  };
})();
quat.toEuler = function(n, t) {
  var r = Math.atan2(2 * t[1] * t[3] - 2 * t[0] * t[2], 1 - 2 * t[1] * t[1] - 2 * t[2] * t[2]), s = Math.asin(2 * t[0] * t[1] + 2 * t[2] * t[3]), a = Math.atan2(2 * t[0] * t[3] - 2 * t[1] * t[2], 1 - 2 * t[0] * t[0] - 2 * t[2] * t[2]);
  return n || (n = vec3.create()), vec3.set(n, r, s, a), n;
};
quat.fromEuler = function(n, t) {
  var r = t[0], s = t[1], a = t[2], o = Math.cos(r), u = Math.cos(s), h = Math.cos(a), l = Math.sin(r), c = Math.sin(s), d = Math.sin(a), f = Math.sqrt(1 + o * u + o * h - l * c * d + u * h) * 0.5;
  f == 0 && (f = 1e-6);
  var _ = (u * d + o * d + l * c * h) / (4 * f), E = (l * u + l * h + o * c * d) / (4 * f), m = (-l * d + o * c * h + c) / (4 * f);
  return quat.set(n, _, E, m, f), quat.normalize(n, n), n;
};
quat.fromMat4 = function(n, t) {
  var r = t[0] + t[5] + t[10];
  if (r > 0) {
    var s = Math.sqrt(r + 1);
    n[3] = s * 0.5;
    var a = 0.5 / s;
    n[0] = (t[9] - t[6]) * a, n[1] = (t[2] - t[8]) * a, n[2] = (t[4] - t[1]) * a;
  } else {
    var o = 0;
    t[5] > t[0] && (o = 1), t[10] > t[o * 4 + o] && (o = 2);
    var u = (o + 1) % 3, h = (u + 1) % 3, s = Math.sqrt(t[o * 4 + o] - t[u * 4 + u] - t[h * 4 + h] + 1);
    n[o] = 0.5 * s;
    var a = 0.5 / s;
    n[3] = (t[h * 4 + u] - t[u * 4 + h]) * a, n[u] = (t[u * 4 + o] + t[o * 4 + u]) * a, n[h] = (t[h * 4 + o] + t[o * 4 + h]) * a;
  }
  quat.normalize(n, n);
};
vec3.getMat3Column = function(n, t, r) {
  return n[0] = t[r * 3], n[1] = t[r * 3 + 1], n[2] = t[r * 3 + 2], n;
};
mat3.setColumn = function(n, t, r) {
  return n[r * 3] = t[0], n[r * 3 + 1] = t[1], n[r * 3 + 2] = t[2], n;
};
quat.fromMat3AndQuat = (function() {
  var n = mat3.create(), t = quat.create(), r = vec3.create(), s = vec3.create(), a = vec3.create(), o = vec3.create(), u = vec3.create(), h = vec3.create(), l = vec3.create(), c = vec3.create(), d = vec3.create(), f = vec3.create();
  return mat3.create(), function(_, E, m) {
    m = m || 25;
    for (var T = 0; T < m; ++T) {
      var L = mat3.fromQuat(n, _);
      vec3.getMat3Column(r, L, 0), vec3.getMat3Column(s, L, 1), vec3.getMat3Column(a, L, 2), vec3.getMat3Column(o, E, 0), vec3.getMat3Column(u, E, 1), vec3.getMat3Column(h, E, 2), vec3.cross(l, r, o), vec3.cross(c, s, u), vec3.cross(d, a, h), vec3.add(f, l, c), vec3.add(f, f, d);
      var G = 1 / Math.abs(vec3.dot(r, o) + vec3.dot(s, u) + vec3.dot(a, h)) + 1e-9;
      vec3.scale(f, f, G);
      var O = vec3.length(f);
      if (O < 1e-9)
        break;
      vec3.scale(f, f, 1 / O), quat.setAxisAngle(t, f, O), quat.mul(_, t, _), quat.normalize(_, _);
    }
    return _;
  };
})();
quat.rotateToFrom = (function() {
  var n = vec3.create();
  return function(t, r, s) {
    t = t || quat.create();
    var a = vec3.cross(n, r, s), o = vec3.dot(r, s);
    return o < -1 + 0.01 ? (t[0] = 0, t[1] = 1, t[2] = 0, t[3] = 0, t) : (t[0] = a[0] * 0.5, t[1] = a[1] * 0.5, t[2] = a[2] * 0.5, t[3] = (1 + o) * 0.5, quat.normalize(t, t), t);
  };
})();
quat.lookAt = (function() {
  var n = vec3.create();
  return function(t, r, s) {
    var a = vec3.dot(vec3.FRONT, r);
    if (Math.abs(a - -1) < 1e-6)
      return t.set(vec3.UP), t[3] = Math.PI, t;
    if (Math.abs(a - 1) < 1e-6)
      return quat.identity(t);
    var o = Math.acos(a);
    return vec3.cross(n, vec3.FRONT, r), vec3.normalize(n, n), quat.setAxisAngle(t, n, o), t;
  };
})();
GL$1.Indexer = function n() {
  this.unique = [], this.indices = [], this.map = {};
};
GL$1.Indexer.prototype = {
  add: function(n) {
    var t = JSON.stringify(n);
    return t in this.map || (this.map[t] = this.unique.length, this.unique.push(n)), this.map[t];
  }
};
GL$1.Buffer = function n(t, r, s, a, o) {
  GL$1.debug && console.log("GL.Buffer created"), o !== null && (o = o || global$1.gl), this.gl = o, this.buffer = null, this.target = t, this.attribute = null, this.data = r, this.spacing = s || 3, this.data && this.gl && this.upload(a);
};
GL$1.Buffer.prototype.bind = function(n, t) {
  t = t || this.gl, t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.enableVertexAttribArray(n), t.vertexAttribPointer(n, this.spacing, this.buffer.gl_type, !1, 0, 0);
};
GL$1.Buffer.prototype.unbind = function(n, t) {
  t = t || this.gl, t.disableVertexAttribArray(n);
};
GL$1.Buffer.prototype.forEach = function(n) {
  for (var t = this.data, r = 0, s = this.spacing, a = t.length; r < a; r += s)
    n(t.subarray(r, r + s), r);
  return this;
};
GL$1.Buffer.prototype.applyTransform = function(n) {
  for (var t = this.data, r = 0, s = this.spacing, a = t.length; r < a; r += s) {
    var o = t.subarray(r, r + s);
    vec3.transformMat4(o, o, n);
  }
  return this;
};
GL$1.Buffer.prototype.upload = function(n) {
  var t = this.spacing || 3, r = this.gl;
  if (r) {
    if (!this.data)
      throw "No data supplied";
    var s = this.data;
    if (!s.buffer)
      throw "Buffers must be typed arrays";
    if (this.buffer = this.buffer || r.createBuffer(), !!this.buffer) {
      switch (this.buffer.length = s.length, this.buffer.spacing = t, s.constructor) {
        case Int8Array:
          this.buffer.gl_type = r.BYTE;
          break;
        case Uint8ClampedArray:
        case Uint8Array:
          this.buffer.gl_type = r.UNSIGNED_BYTE;
          break;
        case Int16Array:
          this.buffer.gl_type = r.SHORT;
          break;
        case Uint16Array:
          this.buffer.gl_type = r.UNSIGNED_SHORT;
          break;
        case Int32Array:
          this.buffer.gl_type = r.INT;
          break;
        case Uint32Array:
          this.buffer.gl_type = r.UNSIGNED_INT;
          break;
        case Float32Array:
          this.buffer.gl_type = r.FLOAT;
          break;
        default:
          throw "unsupported buffer type";
      }
      this.target == r.ARRAY_BUFFER && (this.buffer.gl_type == r.INT || this.buffer.gl_type == r.UNSIGNED_INT) && (console.warn("WebGL does not support UINT32 or INT32 as vertex buffer types, converting to FLOAT"), this.buffer.gl_type = r.FLOAT, s = new Float32Array(s)), r.bindBuffer(this.target, this.buffer), r.bufferData(this.target, s, n || this.stream_type || r.STATIC_DRAW);
    }
  }
};
GL$1.Buffer.prototype.compile = GL$1.Buffer.prototype.upload;
GL$1.Buffer.prototype.setData = function(n, t) {
  if (!n.buffer)
    throw "Data must be typed array";
  if (t = t || 0, this.data) {
    if (this.data.length < n.length)
      throw "buffer is not big enough, you cannot set data to a smaller buffer";
  } else {
    this.data = n, this.upload();
    return;
  }
  if (this.data != n) {
    if (this.data.length == n.length) {
      this.data.set(n), this.upload();
      return;
    }
    var r = new Uint8Array(n.buffer, n.buffer.byteOffset, n.buffer.byteLength), s = new Uint8Array(this.data.buffer);
    s.set(r, t), this.uploadRange(t, r.length);
  }
};
GL$1.Buffer.prototype.uploadRange = function(n, t) {
  if (!this.data)
    throw "No data stored in this buffer";
  var r = this.data;
  if (!r.buffer)
    throw "Buffers must be typed arrays";
  var s = new Uint8Array(this.data.buffer, n, t), a = this.gl;
  a.bindBuffer(this.target, this.buffer), a.bufferSubData(this.target, n, s);
};
GL$1.Buffer.prototype.clone = function(n) {
  var t = new GL$1.Buffer();
  if (n)
    for (var r in this)
      t[r] = this[r];
  else
    this.target && (t.target = this.target), this.gl && (t.gl = this.gl), this.spacing && (t.spacing = this.spacing), this.data && (t.data = new global$1[this.data.constructor](this.data), t.upload());
  return t;
};
GL$1.Buffer.prototype.toJSON = function() {
  if (!this.data)
    return console.error("cannot serialize a mesh without data"), null;
  function n(t) {
    if (t) {
      if (t.name)
        return t.name;
      if (t.toString) {
        var r = t.toString().match(
          /function\s*(\w+)/
        );
        if (r && r.length == 2)
          return r[1];
      }
    }
  }
  return {
    data_type: n(this.data),
    data: this.data.toJSON(),
    target: this.target,
    attribute: this.attribute,
    spacing: this.spacing
  };
};
GL$1.Buffer.prototype.fromJSON = function(n) {
  var t = global$1[n.data_type] || Float32Array;
  this.data = new t(n.data), this.target = n.target, this.spacing = n.spacing || 3, this.attribute = n.attribute, this.upload(GL$1.STATIC_DRAW);
};
GL$1.Buffer.prototype.delete = function() {
  var n = this.gl;
  n.deleteBuffer(this.buffer), this.buffer = null;
};
var st;
let Mesh$1 = (st = class {
  constructor(t, r, s, a) {
    if (GL$1.debug && console.log("GL.Mesh created"), a !== null && (a = a || global$1.gl, this.gl = a), this._context_id = a.context_id, this.vertexBuffers = {}, this.indexBuffers = {}, this.info = {
      groups: []
    }, this._bounding = BBox.create(), (t || r) && this.addBuffers(t, r, s ? s.stream_type : null), s)
      for (var o in s)
        this[o] = s[o];
  }
  set bounding(t) {
    if (t) {
      if (t.length < 13)
        throw "Bounding must use the BBox bounding format of 13 floats: center, halfsize, min, max, radius";
      this._bounding.set(t);
    }
  }
  get bounding() {
    return this._bounding;
  }
  /**
  * Adds buffer to mesh
  * @method addBuffer
  * @param {string} name
  * @param {Buffer} buffer 
  */
  addBuffer(t, r) {
    if (r.target == gl.ARRAY_BUFFER ? this.vertexBuffers[t] = r : this.indexBuffers[t] = r, !r.attribute) {
      var s = GL$1.Mesh.common_buffers[t];
      s && (r.attribute = s.attribute);
    }
  }
  /**
  * Adds vertex and indices buffers to a mesh
  * @method addBuffers
  * @param {Object} vertexBuffers object with all the vertex streams
  * @param {Object} indexBuffers object with all the indices streams
  * @param {enum} stream_type default gl.STATIC_DRAW (other: gl.DYNAMIC_DRAW, gl.STREAM_DRAW )
  */
  addBuffers(t, r, s) {
    var a = 0;
    this.vertexBuffers.vertices && (a = this.vertexBuffers.vertices.data.length / 3);
    for (var o in t) {
      var u = t[o];
      if (u) {
        if (u.constructor == GL$1.Buffer)
          u = u.data;
        else if (typeof u[0] != "number") {
          for (var h = [], l = 0, c = 1e4; l < u.length; l += c)
            h = Array.prototype.concat.apply(h, u.slice(l, l + c));
          u = h;
        }
        var d = GL$1.Mesh.common_buffers[o];
        if (u.constructor === Array) {
          var f = GL$1.Mesh.default_datatype;
          d && d.type && (f = d.type), u = new f(u);
        }
        o == "vertices" && (a = u.length / 3);
        var _ = u.length / a;
        d && d.spacing && (_ = d.spacing);
        var E = "a_" + o;
        d && d.attribute && (E = d.attribute), this.vertexBuffers[o] ? this.updateVertexBuffer(o, E, _, u, s) : this.createVertexBuffer(o, E, _, u, s);
      }
    }
    if (r)
      for (var o in r) {
        var u = r[o];
        if (u) {
          if (u.constructor == GL$1.Buffer && (u = u.data), typeof u[0] != "number") {
            h = [];
            for (var o = 0, c = 1e4; o < u.length; o += c)
              h = Array.prototype.concat.apply(h, u.slice(o, o + c));
            u = h;
          }
          if (u.constructor === Array) {
            var f = Uint16Array;
            a > 256 * 256 && (f = Uint32Array), u = new f(u);
          }
          this.createIndexBuffer(o, u);
        }
      }
  }
  /**
  * Creates a new empty buffer and attachs it to this mesh
  * @method createVertexBuffer
  * @param {String} name "vertices","normals"...
  * @param {String} attribute name of the stream in the shader "a_vertex","a_normal",... [optional, if omitted is used the common_buffers]
  * @param {number} spacing components per vertex [optional, if ommited is used the common_buffers, if not found then uses 3 ]
  * @param {ArrayBufferView} buffer_data the data in typed array format [optional, if ommited it created an empty array of getNumVertices() * spacing]
  * @param {enum} stream_type [optional, default = gl.STATIC_DRAW (other: gl.DYNAMIC_DRAW, gl.STREAM_DRAW ) ]
  */
  createVertexBuffer(t, r, s, a, o) {
    var u = GL$1.Mesh.common_buffers[t];
    if (!r && u && (r = u.attribute), !r)
      throw "Buffer added to mesh without attribute name";
    if (!s && u && (u && u.spacing ? s = u.spacing : s = 3), !a) {
      var h = this.getNumVertices();
      if (!h)
        throw "Cannot create an empty buffer in a mesh without vertices (vertices are needed to know the size)";
      a = new GL$1.Mesh.default_datatype(h * s);
    }
    if (!a.buffer)
      throw "Buffer data MUST be typed array";
    var l = this.vertexBuffers[t] = new GL$1.Buffer(gl.ARRAY_BUFFER, a, s, o, this.gl);
    return l.name = t, l.attribute = r, l;
  }
  /**
  * Updates a vertex buffer 
  * @method updateVertexBuffer
  * @param {String} name the name of the buffer
  * @param {String} attribute the name of the attribute in the shader
  * @param {number} spacing number of numbers per component (3 per vertex, 2 per uvs...), default 3
  * @param {*} data the array with all the data
  * @param {enum} stream_type default gl.STATIC_DRAW (other: gl.DYNAMIC_DRAW, gl.STREAM_DRAW 
  */
  updateVertexBuffer(t, r, s, a, o) {
    var u = this.vertexBuffers[t];
    if (!u) {
      console.log("buffer not found: ", t);
      return;
    }
    a.length && (u.attribute = r, u.spacing = s, u.data = a, u.upload(o));
  }
  /**
  * Removes a vertex buffer from the mesh
  * @method removeVertexBuffer
  * @param {String} name "vertices","normals"...
  * @param {Boolean} free if you want to remove the data from the GPU
  */
  removeVertexBuffer(t, r) {
    var s = this.vertexBuffers[t];
    s && (r && s.delete(), delete this.vertexBuffers[t]);
  }
  /**
  * Returns a vertex buffer
  * @method getVertexBuffer
  * @param {String} name of vertex buffer
  * @return {Buffer} the buffer
  */
  getVertexBuffer(t) {
    return this.vertexBuffers[t];
  }
  /**
  * Creates a new empty index buffer and attachs it to this mesh
  * @method createIndexBuffer
  * @param {String} name 
  * @param {Typed array} data 
  * @param {enum} stream_type gl.STATIC_DRAW, gl.DYNAMIC_DRAW, gl.STREAM_DRAW
  */
  createIndexBuffer(t, r, s) {
    if (r.constructor === Array) {
      var a = Uint16Array, o = this.vertexBuffers.vertices;
      if (o) {
        var u = o.data.length / 3;
        u > 256 * 256 && (a = Uint32Array), r = new a(r);
      }
    }
    var h = this.indexBuffers[t] = new GL$1.Buffer(gl.ELEMENT_ARRAY_BUFFER, r, 0, s, this.gl);
    return h;
  }
  /**
  * Returns a vertex buffer
  * @method getBuffer
  * @param {String} name of vertex buffer
  * @return {Buffer} the buffer
  */
  getBuffer(t) {
    return this.vertexBuffers[t];
  }
  /**
  * Returns a index buffer
  * @method getIndexBuffer
  * @param {String} name of index buffer
  * @return {Buffer} the buffer
  */
  getIndexBuffer(t) {
    return this.indexBuffers[t];
  }
  /**
  * Removes an index buffer from the mesh
  * @method removeIndexBuffer
  * @param {String} name "vertices","normals"...
  * @param {Boolean} free if you want to remove the data from the GPU
  */
  removeIndexBuffer(t, r) {
    var s = this.indexBuffers[t];
    s && (r && s.delete(), delete this.indexBuffers[t]);
  }
  /**
  * Uploads data inside buffers to VRAM.
  * @method upload
  * @param {number} buffer_type gl.STATIC_DRAW, gl.DYNAMIC_DRAW, gl.STREAM_DRAW
  */
  upload(t) {
    for (var r in this.vertexBuffers) {
      var s = this.vertexBuffers[r];
      s.upload(t);
    }
    for (var a in this.indexBuffers) {
      var s = this.indexBuffers[a];
      s.upload();
    }
  }
  deleteBuffers() {
    for (var t in this.vertexBuffers) {
      var r = this.vertexBuffers[t];
      r.delete();
    }
    this.vertexBuffers = {};
    for (var t in this.indexBuffers) {
      var r = this.indexBuffers[t];
      r.delete();
    }
    this.indexBuffers = {};
  }
  bindBuffers(t) {
    for (var r in this.vertexBuffers) {
      var s = this.vertexBuffers[r], a = s.attribute || r, o = t.attributes[a];
      o == null || !s.buffer || (gl.bindBuffer(gl.ARRAY_BUFFER, s.buffer), gl.enableVertexAttribArray(o), gl.vertexAttribPointer(o, s.buffer.spacing, s.buffer.gl_type, !1, 0, 0));
    }
  }
  unbindBuffers(t) {
    for (var r in this.vertexBuffers) {
      var s = this.vertexBuffers[r], a = s.attribute || r, o = t.attributes[a];
      o == null || !s.buffer || gl.disableVertexAttribArray(t.attributes[a]);
    }
  }
  /**
  * Creates a clone of the mesh, the datarrays are cloned too
  * @method clone
  */
  clone(r) {
    var r = r || global$1.gl, s = {}, a = {};
    for (var o in this.vertexBuffers) {
      var u = this.vertexBuffers[o];
      s[o] = new u.data.constructor(u.data);
    }
    for (var o in this.indexBuffers) {
      var u = this.indexBuffers[o];
      a[o] = new u.data.constructor(u.data);
    }
    return new GL$1.Mesh(s, a, void 0, r);
  }
  /**
  * Creates a clone of the mesh, but the data-arrays are shared between both meshes (useful for sharing a mesh between contexts)
  * @method cloneShared
  */
  cloneShared(r) {
    var r = r || global$1.gl;
    return new GL$1.Mesh(this.vertexBuffers, this.indexBuffers, void 0, r);
  }
  /**
  * Creates an object with the info of the mesh (useful to transfer to workers)
  * @method toObject
  */
  toObject() {
    var t = {}, r = {};
    for (var s in this.vertexBuffers) {
      var a = this.vertexBuffers[s];
      t[s] = {
        spacing: a.spacing,
        data: new a.data.constructor(a.data)
        //clone
      };
    }
    for (var s in this.indexBuffers) {
      var a = this.indexBuffers[s];
      r[s] = {
        data: new a.data.constructor(a.data)
        //clone
      };
    }
    return {
      vertexBuffers: t,
      indexBuffers: r,
      info: this.info ? GL$1.cloneObject(this.info) : null,
      bounding: this._bounding.toJSON()
    };
  }
  toJSON() {
    var t = {
      vertexBuffers: {},
      indexBuffers: {},
      info: this.info ? GL$1.cloneObject(this.info) : null,
      bounding: this._bounding.toJSON()
    };
    for (var r in this.vertexBuffers)
      t.vertexBuffers[r] = this.vertexBuffers[r].toJSON();
    for (var r in this.indexBuffers)
      t.indexBuffers[r] = this.indexBuffers[r].toJSON();
    return t;
  }
  fromJSON(t) {
    this.vertexBuffers = {}, this.indexBuffers = {};
    for (var r in t.vertexBuffers)
      if (t.vertexBuffers[r]) {
        var s = new GL$1.Buffer();
        s.fromJSON(t.vertexBuffers[r]), !s.attribute && GL$1.Mesh.common_buffers[r] && (s.attribute = GL$1.Mesh.common_buffers[r].attribute), this.vertexBuffers[r] = s;
      }
    for (var r in t.indexBuffers)
      if (t.indexBuffers[r]) {
        var s = new GL$1.Buffer();
        s.fromJSON(t.indexBuffers[r]), this.indexBuffers[r] = s;
      }
    t.info && (this.info = GL$1.cloneObject(t.info)), t.bounding && (this.bounding = t.bounding);
  }
  /**
  * Computes some data about the mesh
  * @method generateMetadata
  */
  generateMetadata() {
    var t = {}, r = this.vertexBuffers.vertices.data, s = this.indexBuffers.triangles.data;
    t.vertices = r.length / 3, s ? t.faces = s.length / 3 : t.faces = r.length / 9, t.indexed = !!this.metadata.faces, this.metadata = t;
  }
  /*
  	//never tested
  	Mesh.prototype.draw = function(shader, mode, range_start, range_length)
  	{
  		if(range_length == 0) return;
  
  		// Create and enable attribute pointers as necessary.
  		var length = 0;
  		for (var attribute in this.vertexBuffers) {
  		var buffer = this.vertexBuffers[attribute];
  		var location = shader.attributes[attribute] ||
  			gl.getAttribLocation(shader.program, attribute);
  		if (location == -1 || !buffer.buffer) continue;
  		shader.attributes[attribute] = location;
  		gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
  		gl.enableVertexAttribArray(location);
  		gl.vertexAttribPointer(location, buffer.buffer.spacing, gl.FLOAT, false, 0, 0);
  		length = buffer.buffer.length / buffer.buffer.spacing;
  		}
  
  		//range rendering
  		var offset = 0;
  		if(arguments.length > 3) //render a polygon range
  			offset = range_start * (this.indexBuffer ? this.indexBuffer.constructor.BYTES_PER_ELEMENT : 1); //in bytes (Uint16 == 2 bytes)
  
  		if(arguments.length > 4)
  			length = range_length;
  		else if (this.indexBuffer)
  			length = this.indexBuffer.buffer.length - offset;
  
  		// Disable unused attribute pointers.
  		for (var attribute in shader.attributes) {
  		if (!(attribute in this.vertexBuffers)) {
  			gl.disableVertexAttribArray(shader.attributes[attribute]);
  		}
  		}
  
  		// Draw the geometry.
  		if (length && (!this.indexBuffer || indexBuffer.buffer)) {
  		if (this.indexBuffer) {
  			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer.buffer);
  			gl.drawElements(mode, length, gl.UNSIGNED_SHORT, offset);
  		} else {
  			gl.drawArrays(mode, offset, length);
  		}
  		}
  
  		return this;
  	}
  */
  /**
  * Creates a new index stream with wireframe 
  * @method computeWireframe
  */
  computeWireframe() {
    var t = this.indexBuffers.triangles, r = this.vertexBuffers.vertices.data, s = r.length / 3;
    if (t) {
      for (var h = t.data, l = new GL$1.Indexer(), u = 0; u < h.length; u += 3)
        for (var c = h.subarray(u, u + 3), d = 0; d < c.length; d++) {
          var f = c[d], _ = c[(d + 1) % c.length];
          l.add([Math.min(f, _), Math.max(f, _)]);
        }
      for (var E = l.unique, o = s > 256 * 256 ? new Uint32Array(E.length * 2) : new Uint16Array(E.length * 2), u = 0, m = E.length; u < m; ++u)
        o.set(E[u], u * 2);
    } else
      for (var a = s / 3, o = s > 256 * 256 ? new Uint32Array(a * 6) : new Uint16Array(a * 6), u = 0; u < s; u += 3)
        o[u * 2] = u, o[u * 2 + 1] = u + 1, o[u * 2 + 2] = u + 1, o[u * 2 + 3] = u + 2, o[u * 2 + 4] = u + 2, o[u * 2 + 5] = u;
    return this.createIndexBuffer("wireframe", o), this;
  }
  /**
  * Multiplies every normal by -1 and uploads it
  * @method flipNormals
  * @param {enum} stream_type default gl.STATIC_DRAW (other: gl.DYNAMIC_DRAW, gl.STREAM_DRAW)
  */
  flipNormals(t) {
    var r = this.vertexBuffers.normals;
    if (r) {
      for (var o = r.data, u = o.length, s = 0; s < u; ++s)
        o[s] *= -1;
      r.upload(t), this.indexBuffers.triangles || this.computeIndices();
      for (var a = this.indexBuffers.triangles, o = a.data, u = o.length, s = 0; s < u; s += 3) {
        var h = o[s];
        o[s] = o[s + 1], o[s + 1] = h;
      }
      a.upload(t);
    }
  }
  /**
  * Compute indices for a mesh where vertices are shared
  * @method computeIndices
  */
  computeIndices() {
    var t = [], r = [], s = [], a = [], o = this.vertexBuffers.vertices, u = this.vertexBuffers.normals, h = this.vertexBuffers.coords, l = o.data, c = null;
    u && (c = u.data);
    var d = null;
    h && (d = h.data);
    for (var f = {}, _ = l.length / 3, E = 0; E < _; ++E) {
      var m = l.subarray(E * 3, (E + 1) * 3), T = m[0] * 1e3 | 0, L = 0, G = f[T];
      if (G)
        for (var O = G.length; L < O; L++) {
          var b = t[G[L]];
          if (vec3.sqrDist(m, b) < 0.01) {
            a.push(L);
            break;
          }
        }
      if (!(G && L != O)) {
        var I = L;
        t.push(m), f[T] ? f[T].push(I) : f[T] = [I], c && r.push(c.subarray(E * 3, (E + 1) * 3)), d && s.push(d.subarray(E * 2, (E + 1) * 2)), a.push(I);
      }
    }
    this.vertexBuffers = {}, this.createVertexBuffer("vertices", GL$1.Mesh.common_buffers.vertices.attribute, 3, GL$1.linearizeArray(t)), c && this.createVertexBuffer("normals", GL$1.Mesh.common_buffers.normals.attribute, 3, GL$1.linearizeArray(r)), d && this.createVertexBuffer("coords", GL$1.Mesh.common_buffers.coords.attribute, 2, GL$1.linearizeArray(s)), this.createIndexBuffer("triangles", a);
  }
  /**
  * Breaks the indices
  * @method explodeIndices
  */
  explodeIndices(t) {
    t = t || "triangles";
    var r = this.getIndexBuffer(t);
    if (r) {
      var s = r.data, a = {};
      for (var o in this.vertexBuffers) {
        var u = GL$1.Mesh.common_buffers[o];
        a[o] = new (u.type || Float32Array)(u.spacing * s.length);
      }
      for (var o = 0, h = s.length; o < h; ++o) {
        var l = s[o];
        for (var c in this.vertexBuffers) {
          var d = this.vertexBuffers[c], u = GL$1.Mesh.common_buffers[c], f = d.spacing || u.spacing, _ = a[c];
          _.set(d.data.subarray(l * f, l * f + f), o * f);
        }
      }
      for (var o in a) {
        var E = this.vertexBuffers[o];
        this.createVertexBuffer(o, E.attribute, E.spacing, a[o]);
      }
      delete this.indexBuffers[t];
    }
  }
  /**
  * Creates a stream with the normals
  * @method computeNormals
  * @param {enum} stream_type default gl.STATIC_DRAW (other: gl.DYNAMIC_DRAW, gl.STREAM_DRAW)
  */
  computeNormals(t) {
    var r = this.vertexBuffers.vertices;
    if (!r)
      return console.error("Cannot compute normals of a mesh without vertices");
    var s = this.vertexBuffers.vertices.data;
    s.length / 3;
    var a = new Float32Array(s.length), o = null;
    this.indexBuffers.triangles && (o = this.indexBuffers.triangles.data);
    for (var u = GL$1.temp_vec3, h = GL$1.temp2_vec3, l, c, d, f, _, E, m, T, L, G = o ? o.length : s.length, O = 0; O < G; O += 3)
      o ? (l = o[O], c = o[O + 1], d = o[O + 2], f = s.subarray(l * 3, l * 3 + 3), _ = s.subarray(c * 3, c * 3 + 3), E = s.subarray(d * 3, d * 3 + 3), m = a.subarray(l * 3, l * 3 + 3), T = a.subarray(c * 3, c * 3 + 3), L = a.subarray(d * 3, d * 3 + 3)) : (f = s.subarray(O * 3, O * 3 + 3), _ = s.subarray(O * 3 + 3, O * 3 + 6), E = s.subarray(O * 3 + 6, O * 3 + 9), m = a.subarray(O * 3, O * 3 + 3), T = a.subarray(O * 3 + 3, O * 3 + 6), L = a.subarray(O * 3 + 6, O * 3 + 9)), vec3.sub(u, _, f), vec3.sub(h, E, f), vec3.cross(u, u, h), vec3.normalize(u, u), vec3.add(m, m, u), vec3.add(T, T, u), vec3.add(L, L, u);
    if (o)
      for (var O = 0, G = a.length; O < G; O += 3) {
        var b = a.subarray(O, O + 3);
        vec3.normalize(b, b);
      }
    var I = this.vertexBuffers.normals;
    if (I)
      I.data = a, I.upload(t);
    else
      return this.createVertexBuffer("normals", GL$1.Mesh.common_buffers.normals.attribute, 3, a);
    return I;
  }
  /**
  * Creates a new stream with the tangents
  * @method computeTangents
  */
  computeTangents() {
    var t = this.vertexBuffers.vertices;
    if (!t)
      return console.error("Cannot compute tangents of a mesh without vertices");
    var r = this.vertexBuffers.normals;
    if (!r)
      return console.error("Cannot compute tangents of a mesh without normals");
    var s = this.vertexBuffers.coords;
    if (!s)
      return console.error("Cannot compute tangents of a mesh without uvs");
    var a = this.indexBuffers.triangles;
    if (!a)
      return console.error("Cannot compute tangents of a mesh without indices");
    var o = t.data, u = r.data, h = s.data, l = a.data;
    if (!(!o || !u || !h)) {
      var c = o.length / 3, d = new Float32Array(c * 4), f = new Float32Array(c * 3 * 2), _ = f.subarray(c * 3), E, m, T = vec3.create(), L = vec3.create(), G = vec3.create(), O = vec3.create();
      for (E = 0, m = l.length; E < m; E += 3) {
        var b = l[E], I = l[E + 1], S = l[E + 2], N = o.subarray(b * 3, b * 3 + 3), C = o.subarray(I * 3, I * 3 + 3), D = o.subarray(S * 3, S * 3 + 3), M = h.subarray(b * 2, b * 2 + 2), P = h.subarray(I * 2, I * 2 + 2), A = h.subarray(S * 2, S * 2 + 2), R = C[0] - N[0], B = D[0] - N[0], X = C[1] - N[1], F = D[1] - N[1], V = C[2] - N[2], $ = D[2] - N[2], U = P[0] - M[0], H = A[0] - M[0], z = P[1] - M[1], K = A[1] - M[1], tt, W = U * K - H * z;
        Math.abs(W) < 1e-9 ? tt = 0 : tt = 1 / W, vec3.copy(T, [(K * R - z * B) * tt, (K * X - z * F) * tt, (K * V - z * $) * tt]), vec3.copy(L, [(U * B - H * R) * tt, (U * F - H * X) * tt, (U * $ - H * V) * tt]), vec3.add(f.subarray(b * 3, b * 3 + 3), f.subarray(b * 3, b * 3 + 3), T), vec3.add(f.subarray(I * 3, I * 3 + 3), f.subarray(I * 3, I * 3 + 3), T), vec3.add(f.subarray(S * 3, S * 3 + 3), f.subarray(S * 3, S * 3 + 3), T), vec3.add(_.subarray(b * 3, b * 3 + 3), _.subarray(b * 3, b * 3 + 3), L), vec3.add(_.subarray(I * 3, I * 3 + 3), _.subarray(I * 3, I * 3 + 3), L), vec3.add(_.subarray(S * 3, S * 3 + 3), _.subarray(S * 3, S * 3 + 3), L);
      }
      for (E = 0, m = o.length; E < m; E += 3) {
        var Q = u.subarray(E, E + 3), J = f.subarray(E, E + 3);
        vec3.subtract(G, J, vec3.scale(G, Q, vec3.dot(Q, J))), vec3.normalize(G, G);
        var q = vec3.dot(vec3.cross(O, Q, J), _.subarray(E, E + 3)) < 0 ? -1 : 1;
        d.set([G[0], G[1], G[2], q], E / 3 * 4);
      }
      this.createVertexBuffer("tangents", st.common_buffers.tangents.attribute, 4, d);
    }
  }
  /**
  * Creates texture coordinates using a triplanar aproximation
  * @method computeTextureCoordinates
  */
  computeTextureCoordinates(t) {
    var r = this.vertexBuffers.vertices;
    if (!r)
      return console.error("Cannot compute uvs of a mesh without vertices");
    this.explodeIndices("triangles"), r = this.vertexBuffers.vertices;
    var s = r.data, a = s.length / 3, o = this.vertexBuffers.coords, u = new Float32Array(a * 2), h = this.indexBuffers.triangles, l = null;
    h && (l = h.data);
    var c = vec3.create(), d = vec3.create(), f = vec3.create(), _ = this.getBoundingBox(), E = BBox.getCenter(_), m = vec3.create();
    m.set(BBox.getHalfsize(_)), vec3.scale(m, m, 2);
    for (var T = l ? l.length : s.length / 3, L = 0; L < T; L += 3) {
      if (l)
        var G = l[L], O = l[L + 1], b = l[L + 2], I = s.subarray(G * 3, G * 3 + 3), S = s.subarray(O * 3, O * 3 + 3), N = s.subarray(b * 3, b * 3 + 3), C = u.subarray(G * 2, G * 2 + 2), D = u.subarray(O * 2, O * 2 + 2), M = u.subarray(b * 2, b * 2 + 2);
      else
        var I = s.subarray(L * 3, L * 3 + 3), S = s.subarray((L + 1) * 3, (L + 1) * 3 + 3), N = s.subarray((L + 2) * 3, (L + 2) * 3 + 3), C = u.subarray(L * 2, L * 2 + 2), D = u.subarray((L + 1) * 2, (L + 1) * 2 + 2), M = u.subarray((L + 2) * 2, (L + 2) * 2 + 2);
      vec3.sub(d, I, S), vec3.sub(f, I, N), vec3.cross(c, d, f), c[0] = Math.abs(c[0]), c[1] = Math.abs(c[1]), c[2] = Math.abs(c[2]), c[0] > c[1] && c[0] > c[2] ? (C[0] = (I[2] - E[2]) / m[2], C[1] = (I[1] - E[1]) / m[1], D[0] = (S[2] - E[2]) / m[2], D[1] = (S[1] - E[1]) / m[1], M[0] = (N[2] - E[2]) / m[2], M[1] = (N[1] - E[1]) / m[1]) : c[1] > c[2] ? (C[0] = (I[0] - E[0]) / m[0], C[1] = (I[2] - E[2]) / m[2], D[0] = (S[0] - E[0]) / m[0], D[1] = (S[2] - E[2]) / m[2], M[0] = (N[0] - E[0]) / m[0], M[1] = (N[2] - E[2]) / m[2]) : (C[0] = (I[0] - E[0]) / m[0], C[1] = (I[1] - E[1]) / m[1], D[0] = (S[0] - E[0]) / m[0], D[1] = (S[1] - E[1]) / m[1], M[0] = (N[0] - E[0]) / m[0], M[1] = (N[1] - E[1]) / m[1]);
    }
    o ? (o.data = u, o.upload(t)) : this.createVertexBuffer("coords", st.common_buffers.coords.attribute, 2, u);
  }
  /**
  * Computes the number of vertices
  * @method getVertexNumber
  */
  getNumVertices() {
    var t = this.vertexBuffers.vertices;
    return t ? t.data.length / t.spacing : 0;
  }
  /**
  * Computes the number of triangles (takes into account indices)
  * @method getNumTriangles
  */
  getNumTriangles() {
    var t = this.getIndexBuffer("triangles");
    return t ? t.data.length / 3 : this.getNumVertices() / 3;
  }
  /**
  * Computes bounding information
  * @method Mesh.computeBoundingBox
  * @param {typed Array} vertices array containing all the vertices
  * @param {BBox} bb where to store the bounding box
  * @param {Array} mask [optional] to specify which vertices must be considered when creating the bbox, used to create BBox of a submesh
  */
  static computeBoundingBox(t, r, s) {
    if (t) {
      var a = 0;
      if (s) {
        for (var o = 0; o < s.length; ++o)
          if (s[o]) {
            a = o;
            break;
          }
        if (a == s.length) {
          console.warn("mask contains only zeros, no vertices marked");
          return;
        }
      }
      for (var u = vec3.clone(t.subarray(a * 3, a * 3 + 3)), h = vec3.clone(t.subarray(a * 3, a * 3 + 3)), l, o = a * 3; o < t.length; o += 3)
        s && !s[o / 3] || (l = t.subarray(o, o + 3), vec3.min(u, l, u), vec3.max(h, l, h));
      (isNaN(u[0]) || isNaN(u[1]) || isNaN(u[2]) || isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2])) && (u[0] = u[1] = u[2] = 0, h[0] = h[1] = h[2] = 0, console.warn("Warning: GL.Mesh has NaN values in vertices"));
      var c = vec3.add(vec3.create(), u, h);
      vec3.scale(c, c, 0.5);
      var d = vec3.subtract(vec3.create(), h, c);
      return BBox.setCenterHalfsize(r || BBox.create(), c, d);
    }
  }
  /**
  * returns the bounding box, if it is not computed, then computes it
  * @method getBoundingBox
  * @return {BBox} bounding box
  */
  getBoundingBox() {
    return this._bounding ? this._bounding : (this.updateBoundingBox(), this._bounding);
  }
  /**
  * Update bounding information of this mesh
  * @method updateBoundingBox
  */
  updateBoundingBox() {
    var t = this.vertexBuffers.vertices;
    t && (GL$1.Mesh.computeBoundingBox(t.data, this._bounding), this.info && this.info.groups && this.info.groups.length && this.computeGroupsBoundingBoxes());
  }
  /**
  * Update bounding information for every group submesh
  * @method computeGroupsBoundingBoxes
  */
  computeGroupsBoundingBoxes() {
    var t = null, r = this.getIndexBuffer("triangles");
    r && (t = r.data);
    var s = this.getVertexBuffer("vertices");
    if (!s)
      return !1;
    var a = s.data;
    if (!a.length)
      return !1;
    for (var o = this.info.groups, u = 0; u < o.length; ++u) {
      var h = o[u];
      h.bounding = h.bounding || BBox.create();
      var l = null;
      if (t) {
        for (var c = new Uint8Array(a.length / 3), d = h.start, f = 0, _ = h.length; f < _; f += 3)
          c[t[d + f]] = 1, c[t[d + f + 1]] = 1, c[t[d + f + 2]] = 1;
        GL$1.Mesh.computeBoundingBox(a, h.bounding, c);
      } else
        l = a.subarray(h.start * 3, (h.start + h.length) * 3), GL$1.Mesh.computeBoundingBox(l, h.bounding);
    }
    return !0;
  }
  /**
  * forces a bounding box to be set
  * @method setBoundingBox
  * @param {vec3} center center of the bounding box
  * @param {vec3} half_size vector from the center to positive corner
  */
  setBoundingBox(t, r) {
    BBox.setCenterHalfsize(this._bounding, t, r);
  }
  /**
  * Remove all local memory from the streams (leaving it only in the VRAM) to save RAM
  * @method freeData
  */
  freeData() {
    for (var t in this.vertexBuffers)
      this.vertexBuffers[t].data = null, delete this[this.vertexBuffers[t].name];
    for (var r in this.indexBuffers)
      this.indexBuffers[r].data = null, delete this[this.indexBuffers[r].name];
  }
  configure(t, r = {}) {
    var s = {}, a = {};
    for (var o in t)
      if (t[o]) {
        if (o == "vertexBuffers" || o == "vertex_buffers") {
          for (u in t[o])
            s[u] = t[o][u];
          continue;
        }
        if (o == "indexBuffers" || o == "index_buffers") {
          for (u in t[o])
            a[u] = t[o][u];
          continue;
        }
        o == "indices" || o == "lines" || o == "wireframe" || o == "triangles" ? a[o] = t[o] : GL$1.Mesh.common_buffers[o] ? s[o] = t[o] : r[o] = t[o];
      }
    this.addBuffers(s, a, r.stream_type);
    for (var u in r)
      this[u] = r[u];
    r.bounding || this.updateBoundingBox();
  }
  /**
  * Returns the amount of memory used by this mesh in bytes (sum of all buffers)
  * @method getMemory
  * @return {number} bytes
  */
  totalMemory() {
    var t = 0;
    for (var r in this.vertexBuffers)
      t += this.vertexBuffers[r].data.buffer.byteLength;
    for (var r in this.indexBuffers)
      t += this.indexBuffers[r].data.buffer.byteLength;
    return t;
  }
  slice(t, r) {
    var s = {}, a = this.indexBuffers.triangles;
    if (!a)
      return console.warn("splice in not indexed not supported yet"), null;
    var o = a.data, u = [], h = new Int32Array(o.length);
    h.fill(-1);
    var l = t + r;
    l >= o.length && (l = o.length);
    for (var c = 0, d = t; d < l; ++d) {
      var f = o[d];
      if (h[f] != -1) {
        u.push(h[f]);
        continue;
      }
      var _ = c++;
      h[f] = _, u.push(_);
      for (var E in this.vertexBuffers) {
        var m = this.vertexBuffers[E], T = m.data, L = m.spacing;
        s[E] || (s[E] = []);
        for (var G = s[E], O = 0; O < L; ++O)
          G.push(T[O + f * L]);
      }
    }
    var b = new GL$1.Mesh(s, { triangles: u }, null, gl);
    return b.updateBoundingBox(), b;
  }
  /**
  * returns a low poly version of the mesh that takes much less memory (but breaks tiling of uvs and smoothing groups)
  * @method simplify
  * @return {Mesh} simplified mesh
  */
  simplify() {
    var t = this.getBoundingBox(), r = BBox.getMin(t), s = BBox.getHalfsize(t), a = vec3.scale(vec3.create(), s, 2), o = new GL$1.Mesh(), u = vec3.create();
    for (var h in this.vertexBuffers) {
      var l = this.vertexBuffers[h], c = l.data, d = new Float32Array(c.length);
      if (h == "vertices")
        for (var f = 0, _ = c.length; f < _; f += 3) {
          var E = c.subarray(f, f + 3);
          vec3.sub(u, E, r), vec3.div(u, u, a), u[0] = Math.round(u[0] * 256) / 256, u[1] = Math.round(u[1] * 256) / 256, u[2] = Math.round(u[2] * 256) / 256, vec3.mul(u, u, a), vec3.add(u, u, r), d.set(u, f);
        }
      o.addBuffer();
    }
  }
  /**
  * Static method for the class Mesh to create a mesh from a list of common streams
  * @method Mesh.load
  * @param {Object} buffers object will all the buffers
  * @param {Object} options [optional]
  * @param {Mesh} output_mesh [optional] mesh to store the mesh, otherwise is created
  * @param {WebGLContext} gl [optional] if omitted, the global.gl is used
  */
  static load(t, r = {}, s, a) {
    r.no_gl && (a = null);
    var o = s || new GL$1.Mesh(null, null, null, a);
    return o.configure(t, r), o;
  }
  /**
  * Returns a mesh with all the meshes merged (you can apply transforms individually to every buffer)
  * @method Mesh.mergeMeshes
  * @param {Array} meshes array containing object like { mesh:, matrix:, texture_matrix: }
  * @param {Object} options { only_data: to get the mesh data without uploading it }
  * @return {GL.Mesh|Object} the mesh in GL.Mesh format or Object format (if options.only_data is true)
  */
  static mergeMeshes(t, r = {}) {
    for (var s = {}, a = {}, o = {}, u = [], h = 0, l = [], c = 0; c < t.length; ++c) {
      var d = t[c], f = d.mesh, _ = h;
      u.push(_);
      var E = f.vertexBuffers.vertices.data.length / 3;
      h += E;
      for (var m in f.vertexBuffers)
        s[m] ? s[m] += f.vertexBuffers[m].data.length : s[m] = f.vertexBuffers[m].data.length;
      for (var m in f.indexBuffers)
        a[m] ? a[m] += f.indexBuffers[m].data.length : a[m] = f.indexBuffers[m].data.length;
      var T = {
        name: "mesh_" + c,
        start: _,
        length: E,
        material: ""
      };
      l.push(T);
    }
    for (var m in s) {
      var L = r[m];
      if (L === null) {
        delete s[m];
        continue;
      }
      L || (L = Float32Array), s[m] = new L(s[m]), o[m] = 0;
    }
    for (var m in a)
      a[m] = new Uint32Array(a[m]), o[m] = 0;
    for (var c = 0; c < t.length; ++c) {
      var d = t[c], f = d.mesh, _ = 0, E = 0;
      for (var m in f.vertexBuffers)
        if (s[m]) {
          if (m == "vertices" && (E = f.vertexBuffers[m].data.length / 3), s[m].set(f.vertexBuffers[m].data, o[m]), d[m + "_matrix"]) {
            var G = d[m + "_matrix"];
            G.length == 16 ? O(s[m], o[m], f.vertexBuffers[m].data.length, G) : G.length == 9 && b(s[m], o[m], f.vertexBuffers[m].data.length, G);
          }
          o[m] += f.vertexBuffers[m].data.length;
        }
      for (var m in f.indexBuffers)
        a[m].set(f.indexBuffers[m].data, o[m]), I(a[m], o[m], f.indexBuffers[m].data.length, u[c]), o[m] += f.indexBuffers[m].data.length;
    }
    function O(N, C, D, M) {
      for (var P = C + D, A = C; A < P; A += 3) {
        var R = N.subarray(A, A + 3);
        vec3.transformMat4(R, R, M);
      }
    }
    function b(N, C, D, M) {
      for (var P = C + D, A = C; A < P; A += 2) {
        var R = N.subarray(A, A + 2);
        vec2.transformMat3(R, R, M);
      }
    }
    function I(N, C, D, M) {
      for (var P = C + D, A = C; A < P; ++A)
        N[A] += M;
    }
    var S = { info: { groups: l } };
    return typeof gl != "undefined" || r.only_data ? new GL$1.Mesh(s, a, S) : {
      vertexBuffers: s,
      indexBuffers: a,
      info: { groups: l }
    };
  }
  /**
  * It returns the mesh data encoded in the format specified
  * Only obj supported now
  * @method encode
  * @param {String} format to encode the data to (p.e. "obj")
  * @return {?} String with the info
  */
  encode(t, r) {
    t = t.toLowerCase();
    var s = st.encoders[t];
    if (s)
      return s.call(null, this, r);
    throw "Mesh.encode: no encoder found for format " + t;
  }
  /**
  * Returns a shared mesh containing a quad to be used when rendering to the screen
  * Reusing the same quad helps not filling the memory
  * @method getScreenQuad
  * @return {Mesh} the screen quad
  */
  static getScreenQuad(t) {
    t = t || global$1.gl;
    var r = t.meshes[":screen_quad"];
    if (r)
      return r;
    var s = new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0]), a = new Float32Array([0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1]);
    return r = new st({ vertices: s, coords: a }, void 0, void 0, t), t.meshes[":screen_quad"] = r;
  }
  /**
  * Returns a planar mesh (you can choose how many subdivisions)
  * @method Mesh.plane
  * @param {Object} options valid options: detail, detailX, detailY, size, width, heigth, xz (horizontal plane)
  */
  plane(t = {}, r) {
    t.triangles = [];
    var s = t.detailX || t.detail || 1, a = t.detailY || t.detail || 1, o = t.width || t.size || 1, u = t.height || t.size || 1, h = t.xz;
    o *= 0.5, u *= 0.5;
    var l = [], c = [], d = [], f = [], _ = vec3.fromValues(0, 0, 1);
    h && _.set([0, 1, 0]);
    for (var E = 0; E <= a; E++)
      for (var m = E / a, T = 0; T <= s; T++) {
        var L = T / s;
        if (h ? c.push((2 * L - 1) * o, 0, -(2 * m - 1) * u) : c.push((2 * L - 1) * o, (2 * m - 1) * u, 0), d.push(L, m), f.push(_[0], _[1], _[2]), T < s && E < a) {
          var G = T + E * (s + 1);
          h ? (l.push(G + 1, G + s + 1, G), l.push(G + 1, G + s + 2, G + s + 1)) : (l.push(G, G + 1, G + s + 1), l.push(G + s + 1, G + 1, G + s + 2));
        }
      }
    var O = BBox.fromCenterHalfsize([0, 0, 0], h ? [o, 0, u] : [o, u, 0]), b = { vertices: c, normals: f, coords: d, triangles: l };
    return st.load(b, { bounding: O }, r);
  }
  /**
  * Returns a 2D Mesh (be careful, stream is vertices2D, used for 2D engines )
  * @method Mesh.plane2D
  */
  plane2D(t, r) {
    var s = new Float32Array([-1, 1, 1, -1, 1, 1, -1, 1, -1, -1, 1, -1]), a = new Float32Array([0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0]);
    if (t && t.size)
      for (var o = t.size * 0.5, u = 0; u < s.length; ++u)
        s[u] *= o;
    return new st({ vertices2D: s, coords: a }, null, r);
  }
  /**
  * Returns a point mesh 
  * @method Mesh.point
  * @param {Object} options no options
  */
  point(t) {
    return new st({ vertices: [0, 0, 0] });
  }
  /**
  * Returns a cube mesh 
  * @method Mesh.cube
  * @param {Object} options valid options: size 
  */
  cube(t = {}, r) {
    var s = (t.size || 1) * 0.5, a = {};
    a.vertices = new Float32Array([-1, 1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, 1]);
    for (var o = 0, u = a.vertices.length; o < u; ++o)
      a.vertices[o] *= s;
    return a.normals = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0]), a.coords = new Float32Array([0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]), t.wireframe && (a.wireframe = new Uint16Array([0, 2, 2, 5, 5, 4, 4, 0, 6, 7, 7, 10, 10, 11, 11, 6, 0, 6, 2, 7, 5, 10, 4, 11])), t.bounding = BBox.fromCenterHalfsize([0, 0, 0], [s, s, s]), GL$1.Mesh.load(a, t, r);
  }
  /**
  * Returns a cube mesh of a given size
  * @method Mesh.cube
  * @param {Object} options valid options: size, sizex, sizey, sizez
  */
  box(t = {}, r) {
    var s = t.sizex || 1, a = t.sizey || 1, o = t.sizez || 1;
    s *= 0.5, a *= 0.5, o *= 0.5;
    var u = {};
    u.vertices = new Float32Array([-1, 1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, 1]);
    for (var h = 0, l = u.vertices.length; h < l; h += 3)
      u.vertices[h] *= s, u.vertices[h + 1] *= a, u.vertices[h + 2] *= o;
    return u.normals = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0]), u.coords = new Float32Array([0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]), t.wireframe && (u.wireframe = new Uint16Array([0, 2, 2, 5, 5, 4, 4, 0, 6, 7, 7, 10, 10, 11, 11, 6, 0, 6, 2, 7, 5, 10, 4, 11])), t.bounding = BBox.fromCenterHalfsize([0, 0, 0], [s, a, o]), GL$1.Mesh.load(u, t, r);
  }
  /**
  * Returns a circle mesh 
  * @method Mesh.circle
  * @param {Object} options valid options: size,radius, xz = in xz plane, otherwise xy plane
  */
  circle(t = {}, r) {
    var s = t.size || t.radius || 1, a = Math.ceil(t.slices || 24), o = t.xz || !1, u = t.empty || !1;
    a < 3 && (a = 3);
    var h = 2 * Math.PI / a, l = vec3.create(), c = vec3.create(), d = vec3.fromValues(0, 0, 1), f = vec2.fromValues(0.5, 0.5), _ = vec2.create();
    o && d.set([0, 1, 0]);
    var E = o ? 2 : 1, m = new Float32Array(3 * (a + 1)), T = new Float32Array(3 * (a + 1)), L = new Float32Array(2 * (a + 1)), G = null;
    m.set(l, 0), T.set(d, 0), L.set(f, 0);
    for (var O = 0, b = 0, I = 0; I < a; ++I)
      O = Math.sin(h * I), b = Math.cos(h * I), c[0] = O * s, c[E] = b * s, _[0] = O * 0.5 + 0.5, _[1] = b * 0.5 + 0.5, m.set(c, I * 3 + 3), T.set(d, I * 3 + 3), L.set(_, I * 2 + 2);
    if (u)
      m = m.subarray(3), T = m.subarray(3), L = m.subarray(2), G = null;
    else {
      var G = new Uint16Array(3 * a), S = 2, N = 1;
      o && (S = 1, N = 2);
      for (var I = 0; I < a - 1; ++I)
        G[I * 3] = 0, G[I * 3 + 1] = I + S, G[I * 3 + 2] = I + N;
      G[I * 3] = 0, o ? (G[I * 3 + 1] = I + 1, G[I * 3 + 2] = 1) : (G[I * 3 + 1] = 1, G[I * 3 + 2] = I + 1);
    }
    t.bounding = BBox.fromCenterHalfsize([0, 0, 0], o ? [s, 0, s] : [s, s, 0]);
    var C = { vertices: m, normals: T, coords: L, triangles: G };
    if (t.wireframe) {
      for (var D = new Uint16Array(a * 2), I = 0; I < a; I++)
        D[I * 2] = I, D[I * 2 + 1] = I + 1;
      D[0] = a, C.wireframe = D;
    }
    return GL$1.Mesh.load(C, t, r);
  }
  /**
  * Returns a cube mesh 
  * @method Mesh.cylinder
  * @param {Object} options valid options: radius, height, subdivisions 
  */
  cylinder(t = {}, r) {
    for (var s = t.radius || t.size || 1, a = t.height || t.size || 2, o = t.subdivisions || 64, u = new Float32Array(o * 6 * 3 * 2), h = new Float32Array(o * 6 * 3 * 2), l = new Float32Array(o * 6 * 2 * 2), c = 2 * Math.PI / o, d = null, f = 0; f < o; ++f) {
      var _ = f * c;
      d = [Math.sin(_), 0, Math.cos(_)], u.set([d[0] * s, a * 0.5, d[2] * s], f * 6 * 3), h.set(d, f * 6 * 3), l.set([f / o, 1], f * 6 * 2), d = [Math.sin(_), 0, Math.cos(_)], u.set([d[0] * s, a * -0.5, d[2] * s], f * 6 * 3 + 3), h.set(d, f * 6 * 3 + 3), l.set([f / o, 0], f * 6 * 2 + 2), d = [Math.sin(_ + c), 0, Math.cos(_ + c)], u.set([d[0] * s, a * -0.5, d[2] * s], f * 6 * 3 + 6), h.set(d, f * 6 * 3 + 6), l.set([(f + 1) / o, 0], f * 6 * 2 + 4), d = [Math.sin(_ + c), 0, Math.cos(_ + c)], u.set([d[0] * s, a * 0.5, d[2] * s], f * 6 * 3 + 9), h.set(d, f * 6 * 3 + 9), l.set([(f + 1) / o, 1], f * 6 * 2 + 6), d = [Math.sin(_), 0, Math.cos(_)], u.set([d[0] * s, a * 0.5, d[2] * s], f * 6 * 3 + 12), h.set(d, f * 6 * 3 + 12), l.set([f / o, 1], f * 6 * 2 + 8), d = [Math.sin(_ + c), 0, Math.cos(_ + c)], u.set([d[0] * s, a * -0.5, d[2] * s], f * 6 * 3 + 15), h.set(d, f * 6 * 3 + 15), l.set([(f + 1) / o, 0], f * 6 * 2 + 10);
    }
    var E = f * 6 * 3, m = f * 6 * 2, T = E;
    if (t.caps === !1)
      u = u.subarray(0, E), h = h.subarray(0, E), l = l.subarray(0, m);
    else
      for (var L = vec3.fromValues(0, a * 0.5, 0), G = vec3.fromValues(0, a * -0.5, 0), O = vec3.fromValues(0, 1, 0), b = vec3.fromValues(0, -1, 0), f = 0; f < o; ++f) {
        var _ = f * c, I = vec3.fromValues(Math.sin(_), 0, Math.cos(_)), S = vec3.fromValues(Math.sin(_ + c), 0, Math.cos(_ + c));
        u.set([I[0] * s, a * 0.5, I[2] * s], E + f * 6 * 3), h.set(O, E + f * 6 * 3), l.set([-I[0] * 0.5 + 0.5, I[2] * 0.5 + 0.5], m + f * 6 * 2), u.set([S[0] * s, a * 0.5, S[2] * s], E + f * 6 * 3 + 3), h.set(O, E + f * 6 * 3 + 3), l.set([-S[0] * 0.5 + 0.5, S[2] * 0.5 + 0.5], m + f * 6 * 2 + 2), u.set(L, E + f * 6 * 3 + 6), h.set(O, E + f * 6 * 3 + 6), l.set([0.5, 0.5], m + f * 6 * 2 + 4), u.set([S[0] * s, a * -0.5, S[2] * s], E + f * 6 * 3 + 9), h.set(b, E + f * 6 * 3 + 9), l.set([S[0] * 0.5 + 0.5, S[2] * 0.5 + 0.5], m + f * 6 * 2 + 6), u.set([I[0] * s, a * -0.5, I[2] * s], E + f * 6 * 3 + 12), h.set(b, E + f * 6 * 3 + 12), l.set([I[0] * 0.5 + 0.5, I[2] * 0.5 + 0.5], m + f * 6 * 2 + 8), u.set(G, E + f * 6 * 3 + 15), h.set(b, E + f * 6 * 3 + 15), l.set([0.5, 0.5], m + f * 6 * 2 + 10);
      }
    var N = {
      vertices: u,
      normals: h,
      coords: l
    };
    return t.bounding = BBox.fromCenterHalfsize([0, 0, 0], [s, a * 0.5, s]), t.info = { groups: [] }, t.caps !== !1 && (t.info.groups.push({ name: "side", start: 0, length: T / 3 }), t.info.groups.push({ name: "caps", start: T / 3, length: (u.length - T) / 3 })), st.load(N, t, r);
  }
  /**
  * Returns a cone mesh 
  * @method Mesh.cone
  * @param {Object} options valid options: radius, height, subdivisions 
  */
  cone(t = {}, r) {
    for (var s = t.radius || t.size || 1, a = t.height || t.size || 2, o = t.subdivisions || 64, u = new Float32Array(o * 3 * 3 * 2), h = new Float32Array(o * 3 * 3 * 2), l = new Float32Array(o * 2 * 3 * 2), c = 2 * Math.PI / o, d = null, f = s / a, _ = 0; _ < o; ++_) {
      var E = _ * c;
      d = [Math.sin(E + c * 0.5), f, Math.cos(E + c * 0.5)], vec3.normalize(d, d), u.set([0, a, 0], _ * 6 * 3), h.set(d, _ * 6 * 3), l.set([_ / o, 1], _ * 6 * 2), d = [Math.sin(E), f, Math.cos(E)], u.set([d[0] * s, 0, d[2] * s], _ * 6 * 3 + 3), vec3.normalize(d, d), h.set(d, _ * 6 * 3 + 3), l.set([_ / o, 0], _ * 6 * 2 + 2), d = [Math.sin(E + c), f, Math.cos(E + c)], u.set([d[0] * s, 0, d[2] * s], _ * 6 * 3 + 6), vec3.normalize(d, d), h.set(d, _ * 6 * 3 + 6), l.set([(_ + 1) / o, 0], _ * 6 * 2 + 4);
    }
    for (var m = 0, T = 0, L = vec3.fromValues(0, 0, 0), G = vec3.fromValues(0, -1, 0), _ = 0; _ < o; ++_) {
      var E = _ * c, O = vec3.fromValues(Math.sin(E), 0, Math.cos(E)), b = vec3.fromValues(Math.sin(E + c), 0, Math.cos(E + c));
      u.set([b[0] * s, 0, b[2] * s], m + _ * 6 * 3 + 9), h.set(G, m + _ * 6 * 3 + 9), l.set([b[0] * 0.5 + 0.5, b[2] * 0.5 + 0.5], T + _ * 6 * 2 + 6), u.set([O[0] * s, 0, O[2] * s], m + _ * 6 * 3 + 12), h.set(G, m + _ * 6 * 3 + 12), l.set([O[0] * 0.5 + 0.5, O[2] * 0.5 + 0.5], T + _ * 6 * 2 + 8), u.set(L, m + _ * 6 * 3 + 15), h.set(G, m + _ * 6 * 3 + 15), l.set([0.5, 0.5], T + _ * 6 * 2 + 10);
    }
    var I = {
      vertices: u,
      normals: h,
      coords: l
    };
    return t.bounding = BBox.fromCenterHalfsize([0, a * 0.5, 0], [s, a * 0.5, s]), st.load(I, t, r);
  }
  /**
  * Returns a sphere mesh 
  * @method Mesh.sphere
  * @param {Object} options valid options: radius, lat, long, subdivisions, hemi
  */
  sphere(t = {}, r) {
    for (var s = t.radius || t.size || 1, a = t.lat || t.subdivisions || 16, o = t.long || t.subdivisions || 16, u = new Float32Array((a + 1) * (o + 1) * 3), h = new Float32Array((a + 1) * (o + 1) * 3), l = new Float32Array((a + 1) * (o + 1) * 2), c = new Uint16Array(a * o * 6), d = t.hemi ? Math.PI * 0.5 : Math.PI, f = 0, _ = 0, E = 0; E <= a; E++)
      for (var m = E * d / a, T = Math.sin(m), L = Math.cos(m), G = 0; G <= o; G++) {
        var O = G * 2 * Math.PI / o, b = Math.sin(O), I = Math.cos(O), S = I * T, N = L, C = b * T, D = 1 - G / o, M = 1 - E / a;
        u.set([s * S, s * N, s * C], f), h.set([S, N, C], f), l.set([D, M], _), f += 3, _ += 2;
      }
    f = 0;
    for (var E = 0; E < a; E++)
      for (var G = 0; G < o; G++) {
        var P = E * (o + 1) + G, A = P + o + 1;
        c.set([A, P, P + 1], f), c.set([A + 1, A, P + 1], f + 3), f += 6;
      }
    var R = {
      vertices: u,
      normals: h,
      coords: l,
      triangles: c
    };
    if (t.wireframe) {
      for (var B = new Uint16Array(o * a * 4), X = 0, f = 0; f < a; f++) {
        for (var F = 0; F < o; F++)
          B[X] = f * (o + 1) + F, B[X + 1] = f * (o + 1) + F + 1, X += 2;
        B[X - o * 2] = f * (o + 1) + F;
      }
      for (var f = 0; f < o; f++)
        for (var F = 0; F < a; F++)
          B[X] = F * (o + 1) + f, B[X + 1] = (F + 1) * (o + 1) + f, X += 2;
      R.wireframe = B;
    }
    return t.hemi ? t.bounding = BBox.fromCenterHalfsize([0, s * 0.5, 0], [s, s * 0.5, s], s) : t.bounding = BBox.fromCenterHalfsize([0, 0, 0], [s, s, s], s), GL$1.Mesh.load(R, t, r);
  }
  /**
  * Returns a grid mesh (must be rendered using gl.LINES)
  * @method Mesh.grid
  * @param {Object} options valid options: size, lines
  */
  grid(t = {}, r) {
    var s = t.lines || 11;
    s < 0 && (s = 1);
    for (var a = t.size || 10, o = new Float32Array(s * 2 * 2 * 3), u = a * 0.5, h = 0, l = -u, c = a / (s - 1), d = 0; d < s; d++)
      o[h] = l, o[h + 2] = -u, o[h + 3] = l, o[h + 5] = u, o[h + 6] = u, o[h + 8] = l, o[h + 9] = -u, o[h + 11] = l, l += c, h += 12;
    return new GL$1.Mesh({ vertices: o }, t, r);
  }
  /**
  * Returns a icosahedron mesh (useful to create spheres by subdivision)
  * @method Mesh.icosahedron
  * @param {Object} options valid options: radius, subdivisions (max: 6)
  */
  icosahedron(t = {}, r) {
    var s = t.radius || t.size || 1, a = t.subdivisions === void 0 ? 0 : t.subdivisions;
    a > 6 && (a = 6);
    for (var o = (1 + Math.sqrt(5)) / 2, u = [
      -1,
      o,
      0,
      1,
      o,
      0,
      -1,
      -o,
      0,
      1,
      -o,
      0,
      0,
      -1,
      o,
      0,
      1,
      o,
      0,
      -1,
      -o,
      0,
      1,
      -o,
      o,
      0,
      -1,
      o,
      0,
      1,
      -o,
      0,
      -1,
      -o,
      0,
      1
    ], h = [], l = [], c = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], d = u.length, f = 0; f < d; f += 3) {
      var _ = Math.sqrt(u[f] * u[f] + u[f + 1] * u[f + 1] + u[f + 2] * u[f + 2]), E = u[f] / _, m = u[f + 1] / _, T = u[f + 2] / _;
      h.push(E, m, T), l.push(Math.atan2(E, T), Math.acos(m)), u[f] *= s / _, u[f + 1] *= s / _, u[f + 2] *= s / _;
    }
    var L = {};
    function G(C, D) {
      var M = c[C] < c[D] ? c[C] + ":" + c[D] : c[D] + ":" + c[C], P = L[M];
      if (P)
        return P;
      var A = u.length / 3;
      u.push(
        (u[c[C] * 3] + u[c[D] * 3]) * 0.5,
        (u[c[C] * 3 + 1] + u[c[D] * 3 + 1]) * 0.5,
        (u[c[C] * 3 + 2] + u[c[D] * 3 + 2]) * 0.5
      );
      var R = Math.sqrt(u[A * 3] * u[A * 3] + u[A * 3 + 1] * u[A * 3 + 1] + u[A * 3 + 2] * u[A * 3 + 2]), B = u[A * 3] / R, X = u[A * 3 + 1] / R, F = u[A * 3 + 2] / R;
      return h.push(B, X, F), l.push(Math.atan2(B, F) / Math.PI * 0.5, Math.acos(X) / Math.PI), u[A * 3] *= s / R, u[A * 3 + 1] *= s / R, u[A * 3 + 2] *= s / R, L[M] = A, A;
    }
    for (var O = 0; O < a; ++O) {
      for (var b = [], d = c.length, f = 0; f < d; f += 3) {
        var I = G(f, f + 1), S = G(f + 1, f + 2), N = G(f + 2, f);
        b.push(c[f], I, N), b.push(c[f + 1], S, I), b.push(c[f + 2], N, S), b.push(I, S, N);
      }
      c = b;
    }
    return t.bounding = BBox.fromCenterHalfsize([0, 0, 0], [s, s, s], s), new GL$1.Mesh.load({ vertices: u, coords: l, normals: h, triangles: c }, t, r);
  }
  // OBJ parser adapted from SpiderGL implementation *
  /**
  * Parses a OBJ string and returns an object with the info ready to be passed to GL.Mesh.load
  * @method Mesh.parseOBJ
  * @param {String} data all the OBJ info to be parsed
  * @param {Object} options
  * @return {Object} mesh information (vertices, coords, normals, indices)
  */
  static parseOBJ(t, r = {}) {
    for (var s = [], a = [], o = [], u = [], h = [], l = [], c = [], d = {}, f = 0, _ = null, E = null, m = 0, T = 0, L = 0, G = 0, O = 0, b = 0, I = null, S = !1, N = !1, C = !1, D = 0, M = r.noindex ? r.noindex : t.length > 1e7, P = r.flipAxis, A = P || r.flipNormals, R = null, B = [], X = 1, F = 2, V = 3, $ = 4, U = 5, H = 6, z = { v: X, vt: F, vn: V, f: $, g: U, o: H }, K = t.split(`
`), tt = K.length, W = 0; W < tt; ++W)
      if (_ = K[W].replace(/[ \t]+/g, " ").replace(/\s\s*$/, ""), _[0] != "#" && _ != "") {
        I = _.split(" ");
        var Q = z[I[0]];
        if (Q <= V && (G = parseFloat(I[1]), O = parseFloat(I[2]), Q != F && (I[3] == "\\" ? (++W, _ = K[W].replace(/[ \t]+/g, " ").replace(/\s\s*$/, ""), b = parseFloat(_)) : b = parseFloat(I[3]))), Q == X)
          P ? h.push(-1 * G, b, O) : h.push(G, O, b);
        else if (Q == F)
          l.push(G, O);
        else if (Q == V)
          A ? c.push(-O, -b, G) : c.push(G, O, b);
        else if (Q == $) {
          if (I.length < 4) continue;
          for (var J = [], q = 1; q < I.length; ++q) {
            if (!(I[q] in d) || M) {
              if (E = I[q].split("/"), E.length == 1)
                m = parseInt(E[0]) - 1, T = m, L = m;
              else if (E.length == 2)
                m = parseInt(E[0]) - 1, T = parseInt(E[1]) - 1, L = -1;
              else if (E.length == 3)
                m = parseInt(E[0]) - 1, T = parseInt(E[1]) - 1, L = parseInt(E[2]) - 1;
              else
                return console.err("Problem parsing: unknown number of values per face"), !1;
              if (q > 3 && M) {
                var Z = s.length;
                s.push(s[Z - (q - 3) * 9], s[Z - (q - 3) * 9 + 1], s[Z - (q - 3) * 9 + 2]), s.push(s[Z - 3], s[Z - 2], s[Z - 1]), Z = a.length, a.push(a[Z - (q - 3) * 6], a[Z - (q - 3) * 6 + 1]), a.push(a[Z - 2], a[Z - 1]), Z = o.length, o.push(o[Z - (q - 3) * 9], o[Z - (q - 3) * 9 + 1], o[Z - (q - 3) * 9 + 2]), o.push(o[Z - 3], o[Z - 2], o[Z - 1]);
              }
              G = 0, O = 0, b = 0, m * 3 + 2 < h.length && (S = !0, G = h[m * 3 + 0], O = h[m * 3 + 1], b = h[m * 3 + 2]), s.push(G, O, b), G = 0, O = 0, T * 2 + 1 < l.length && (N = !0, G = l[T * 2 + 0], O = l[T * 2 + 1]), a.push(G, O), G = 0, O = 0, b = 1, L != -1 && (L * 3 + 2 < c.length && (C = !0, G = c[L * 3 + 0], O = c[L * 3 + 1], b = c[L * 3 + 2]), o.push(G, O, b)), M || (d[I[q]] = f++);
            }
            if (!M) {
              var pt = d[I[q]];
              J.push(pt), D < pt && (D = pt);
            }
          }
          if (!M)
            for (var Bt = 2; Bt < J.length; Bt++)
              u.push(J[0], J[Bt - 1], J[Bt]);
        } else Q == U ? I.length > 1 && (R != null && (R.length = u.length - R.start, R.length > 0 && B.push(R)), R = {
          name: I[1],
          start: u.length,
          length: -1,
          material: ""
        }) : I[0] == "usemtl" && R && (R.material = I[1]);
      }
    if (!h.length)
      return console.error("OBJ doesnt have vertices, maybe the file is not a OBJ"), null;
    if (R && u.length - R.start > 1 && (R.length = u.length - R.start, B.push(R)), (D > 256 * 256 || M) && u.length > 0) {
      console.log("Deindexing mesh...");
      for (var Ie = new Float32Array(u.length * 3), xe = o && o.length ? new Float32Array(u.length * 3) : null, we = a && a.length ? new Float32Array(u.length * 2) : null, q = 0; q < u.length; q += 1)
        Ie.set(s.slice(u[q] * 3, u[q] * 3 + 3), q * 3), xe && xe.set(o.slice(u[q] * 3, u[q] * 3 + 3), q * 3), we && we.set(a.slice(u[q] * 2, u[q] * 2 + 2), q * 2);
      s = Ie, xe && (o = xe), we && (a = we), u = null;
    }
    var ne = {};
    S && (ne.vertices = new Float32Array(s)), C && o.length > 0 && (ne.normals = new Float32Array(o)), N && a.length > 0 && (ne.coords = new Float32Array(a)), u && u.length > 0 && (ne.triangles = new Uint16Array(u));
    var Oe = {};
    if (B.length > 1 && (Oe.groups = B), ne.info = Oe, r.only_data)
      return ne;
    var Ae = null;
    return Ae = st.load(ne, null, r.mesh), Ae.updateBoundingBox(), Ae;
  }
}, g(st, "common_buffers", {
  vertices: { spacing: 3, attribute: "a_vertex" },
  vertices2D: { spacing: 2, attribute: "a_vertex2D" },
  normals: { spacing: 3, attribute: "a_normal" },
  coords: { spacing: 2, attribute: "a_coord" },
  coords1: { spacing: 2, attribute: "a_coord1" },
  coords2: { spacing: 2, attribute: "a_coord2" },
  colors: { spacing: 4, attribute: "a_color" },
  tangents: { spacing: 3, attribute: "a_tangent" },
  bone_indices: { spacing: 4, attribute: "a_bone_indices", type: Uint8Array },
  weights: { spacing: 4, attribute: "a_weights" },
  extra: { spacing: 1, attribute: "a_extra" },
  extra2: { spacing: 2, attribute: "a_extra2" },
  extra3: { spacing: 3, attribute: "a_extra3" },
  extra4: { spacing: 4, attribute: "a_extra4" }
}), g(st, "default_datatype", Float32Array), //Here we store all basic mesh parsers (OBJ, STL) and encoders
g(st, "parsers", {}), g(st, "encoders", {}), g(st, "binary_file_formats", {}), //extensions that must be downloaded in binary
g(st, "compressors", {}), //used to compress binary meshes
g(st, "decompressors", {}), //used to decompress binary meshes
/**
* Returns am empty mesh and loads a mesh and parses it using the Mesh.parsers, by default only OBJ is supported
* @method Mesh.fromOBJ
* @param {Array} meshes array containing all the meshes
*/
g(st, "fromURL", function(t, r, s, a = {}) {
  s = s || global$1.gl;
  var o = new GL$1.Mesh(void 0, void 0, void 0, s);
  o.ready = !1;
  var u = t.lastIndexOf("."), h = t.substr(u + 1).toLowerCase();
  return a.binary = st.binary_file_formats[h], HttpRequest(t, null, function(l) {
    o.parse(l, h), delete o.ready, r && r.call(o, o, t);
  }, function(l) {
    r && r(null);
  }, a), o;
}), st);
GL$1.Mesh = Mesh$1;
GL$1.Mesh.EXTENSION = "wbin";
GL$1.Mesh.enable_wbin_compression = !0;
Mesh$1.prototype.delete = Mesh$1.prototype.deleteBuffers;
Mesh$1.parsers.obj = Mesh$1.parseOBJ;
Mesh$1.encoders.obj = function(n, t) {
  var r = n.getBuffer("vertices");
  if (!r)
    return null;
  var s = [];
  s.push(`# Generated with liteGL.js by Javi Agenjo
`);
  for (var a = r.data, o = 0; o < a.length; o += 3)
    s.push("v " + a[o].toFixed(4) + " " + a[o + 1].toFixed(4) + " " + a[o + 2].toFixed(4));
  var u = n.getBuffer("normals");
  if (u) {
    s.push("");
    for (var h = u.data, o = 0; o < h.length; o += 3)
      s.push("vn " + h[o].toFixed(4) + " " + h[o + 1].toFixed(4) + " " + h[o + 2].toFixed(4));
  }
  var l = n.getBuffer("coords");
  if (l) {
    s.push("");
    for (var c = l.data, o = 0; o < c.length; o += 2)
      s.push("vt " + c[o].toFixed(4) + " " + c[o + 1].toFixed(4) + "  0.0000");
  }
  var d = n.info.groups, f = n.getIndexBuffer("triangles");
  if (f) {
    var _ = f.data;
    (!d || !d.length) && (d = [{ start: 0, length: _.length, name: "mesh" }]);
    for (var E = 0; E < d.length; ++E) {
      var m = d[E];
      s.push("g " + m.name), s.push("usemtl " + (m.material || "mat_" + E));
      for (var T = m.start, L = T + m.length, o = T; o < L; o += 3)
        s.push("f " + (_[o] + 1) + "/" + (_[o] + 1) + "/" + (_[o] + 1) + " " + (_[o + 1] + 1) + "/" + (_[o + 1] + 1) + "/" + (_[o + 1] + 1) + " " + (_[o + 2] + 1) + "/" + (_[o + 2] + 1) + "/" + (_[o + 2] + 1));
    }
  } else {
    (!d || !d.length) && (d = [{ start: 0, length: a.length / 3, name: "mesh" }]);
    for (var E = 0; E < d.length; ++E) {
      var m = d[E];
      s.push("g " + m.name), s.push("usemtl " + (m.material || "mat_" + E));
      for (var T = m.start, L = T + m.length, o = T; o < L; o += 3)
        s.push("f " + (o + 1) + "/" + (o + 1) + "/" + (o + 1) + " " + (o + 2) + "/" + (o + 2) + "/" + (o + 2) + " " + (o + 3) + "/" + (o + 3) + "/" + (o + 3));
    }
  }
  return s.join(`
`);
};
Mesh$1.parsers.mesh = function(n, t) {
  for (var r = {}, s = n.split(`
`), a = 0; a < s.length; ++a) {
    var o = s[a], u = o[0], h = o.substr(1).split(","), l = h[0];
    if (u == "-") {
      for (var c = new Float32Array(Number(h[1])), d = 0; d < c.length; ++d)
        c[d] = Number(h[d + 2]);
      r[l] = c;
    } else if (u == "*") {
      for (var c = Number(h[1]) > 65536 ? new Uint32Array(Number(h[1])) : new Uint16Array(Number(h[1])), d = 0; d < c.length; ++d)
        c[d] = Number(h[d + 2]);
      r[l] = c;
    } else if (u == "@") {
      if (l == "bones") {
        for (var f = [], _ = Number(h[1]), d = 0; d < _; ++d) {
          var E = h.slice(3 + d * 17, 3 + (d + 1) * 17 - 1).map(Number);
          f.push([h[2 + d * 17], E]);
        }
        r.bones = f;
      } else if (l == "bind_matrix")
        r.bind_matrix = h.slice(1, 17).map(Number);
      else if (l == "groups") {
        r.info = { groups: [] };
        for (var m = Number(h[1]), d = 0; d < m; ++d) {
          var T = { name: h[2 + d * 4], material: h[2 + d * 4 + 1], start: Number(h[2 + d * 4 + 2]), length: Number(h[2 + d * 4 + 3]) };
          r.info.groups.push(T);
        }
      }
    } else
      console.warn("type unknown: " + h[0]);
  }
  if (t.only_data)
    return r;
  var L = null;
  return L = Mesh$1.load(r, null, t.mesh), L.updateBoundingBox(), L;
};
Mesh$1.encoders.mesh = function(n, t) {
  var r = [];
  for (var s in n.vertexBuffers) {
    var a = n.vertexBuffers[s], o = ["-" + s, a.data.length, a.data, Array.from(a.data)];
    r.push(o.join(","));
  }
  for (var s in n.indexBuffers) {
    var a = n.indexBuffers[s], o = ["*" + s, a.data.length, a.data, Array.from(a.data)];
    r.push(o.join(","));
  }
  if (n.bounding && r.push(["@bounding", Array.from(n.bounding.subarray(0, 6))].join(",")), n.info && n.info.groups) {
    for (var u = [], h = 0; h < n.info.groups.length; ++h) {
      var l = n.info.groups[h];
      u.push(l.name, l.material, l.start, l.length);
    }
    r.push(["@groups", n.info.groups.length].concat(u).join(","));
  }
  return n.bones && r.push(["@bones", n.bones.length, n.bones.flat()].join(",")), n.bind_matrix && r.push(["@bind_matrix", Array.from(n.bind_matrix)].join(",")), r.join(`
`);
};
global$1.WBin && (global$1.WBin.classes.Mesh = Mesh$1);
Mesh$1.binary_file_formats.wbin = !0;
Mesh$1.parsers.wbin = Mesh$1.fromBinary = function(n, t = {}) {
  if (!global$1.WBin)
    throw "To use binary meshes you need to install WBin.js from https://github.com/jagenjo/litescene.js/blob/master/src/utils/wbin.js ";
  var r = null;
  n.constructor == ArrayBuffer ? r = WBin.load(n, !0) : r = n, r.info || console.warn("This WBin doesn't seem to contain a mesh. Classname: ", r["@classname"]), r.format && GL$1.Mesh.decompress(r);
  var s = {};
  if (r.vertex_buffers)
    for (var a in r.vertex_buffers)
      s[r.vertex_buffers[a]] = r[r.vertex_buffers[a]];
  else
    r.vertices && (s.vertices = r.vertices), r.normals && (s.normals = r.normals), r.coords && (s.coords = r.coords), r.weights && (s.weights = r.weights), r.bone_indices && (s.bone_indices = r.bone_indices);
  var o = {};
  if (r.index_buffers)
    for (var a in r.index_buffers)
      o[r.index_buffers[a]] = r[r.index_buffers[a]];
  else
    r.triangles && (o.triangles = r.triangles), r.wireframe && (o.wireframe = r.wireframe);
  var u = {
    vertex_buffers: s,
    index_buffers: o,
    bounding: r.bounding,
    info: r.info
  };
  if (r.bones) {
    u.bones = r.bones;
    for (var a = 0; a < u.bones.length; ++a)
      u.bones[a][1] = mat4.clone(u.bones[a][1]);
    r.bind_matrix && (u.bind_matrix = mat4.clone(r.bind_matrix));
  }
  if (r.morph_targets && (u.morph_targets = r.morph_targets), t.only_data)
    return u;
  var h = t.mesh || new GL$1.Mesh();
  return h.configure(u), h;
};
Mesh$1.encoders.wbin = function(n, t) {
  return n.toBinary(t);
};
Mesh$1.prototype.toBinary = function(n) {
  if (!global$1.WBin)
    throw "to use Mesh.toBinary you need to have WBin included. Check the repository for wbin.js";
  this.info || (this.info = {});
  var t = {
    object_class: "Mesh",
    info: this.info,
    groups: this.groups
  };
  if (this.bones) {
    for (var r = [], s = 0; s < this.bones.length; ++s)
      r.push([this.bones[s][0], mat4.toArray(this.bones[s][1])]);
    t.bones = r, this.bind_matrix && (t.bind_matrix = this.bind_matrix);
  }
  this.bounding || this.updateBoundingBox(), t.bounding = this.bounding;
  var a = [], o = [];
  for (var s in this.vertexBuffers) {
    var u = this.vertexBuffers[s];
    t[u.name] = u.data, a.push(u.name), u.name == "vertices" && (t.info.num_vertices = u.data.length / 3);
  }
  for (var s in this.indexBuffers) {
    var u = this.indexBuffers[s];
    t[s] = u.data, o.push(s);
  }
  t.vertex_buffers = a, t.index_buffers = o, GL$1.Mesh.enable_wbin_compression && GL$1.Mesh.compress(t);
  var h = WBin.create(t, "Mesh");
  return h;
};
Mesh$1.compress = function(n, t) {
  t = t || "bounding_compressed", n.format = {
    type: t
  };
  var r = Mesh$1.compressors[t];
  if (!r)
    throw "compression format not supported:" + t;
  return r(n);
};
Mesh$1.decompress = function(n) {
  if (n.format) {
    var t = Mesh$1.decompressors[n.format.type];
    if (!t)
      throw "decompression format not supported:" + n.format.type;
    return t(n);
  }
};
Mesh$1.compressors.bounding_compressed = function(n) {
  if (!n.vertex_buffers)
    throw "buffers not found";
  for (var t = BBox.getMin(n.bounding), r = BBox.getMax(n.bounding), s = vec3.sub(vec3.create(), r, t), a = n.vertices, o = new Uint16Array(a.length), u = 0; u < a.length; u += 3)
    o[u] = (a[u] - t[0]) / s[0] * 65535, o[u + 1] = (a[u + 1] - t[1]) / s[1] * 65535, o[u + 2] = (a[u + 2] - t[2]) / s[2] * 65535;
  if (n.vertices = o, n.normals) {
    for (var h = n.normals, l = new Uint8Array(h.length), c = l.constructor == Uint8Array ? 255 : 65535, u = 0; u < h.length; u += 3)
      l[u] = (h[u] * 0.5 + 0.5) * c, l[u + 1] = (h[u + 1] * 0.5 + 0.5) * c, l[u + 2] = (h[u + 2] * 0.5 + 0.5) * c;
    n.normals = l;
  }
  if (n.coords) {
    for (var d = n.coords, f = [1e4, 1e4, -1e4, -1e4], u = 0; u < d.length; u += 2) {
      var _ = d[u];
      f[0] > _ ? f[0] = _ : f[2] < _ && (f[2] = _);
      var E = d[u + 1];
      f[1] > E ? f[1] = E : f[3] < E && (f[3] = E);
    }
    n.format.uvs_bounding = f;
    for (var m = new Uint16Array(d.length), s = [f[2] - f[0], f[3] - f[1]], u = 0; u < d.length; u += 2)
      m[u] = (d[u] - f[0]) / s[0] * 65535, m[u + 1] = (d[u + 1] - f[1]) / s[1] * 65535;
    n.coords = m;
  }
  if (n.weights) {
    for (var T = n.weights, L = new Uint16Array(T.length), G = L.constructor == Uint8Array ? 255 : 65535, u = 0; u < T.length; u += 4)
      L[u] = T[u] * G, L[u + 1] = T[u + 1] * G, L[u + 2] = T[u + 2] * G, L[u + 3] = T[u + 3] * G;
    n.weights = L;
  }
};
Mesh$1.decompressors.bounding_compressed = function(n) {
  var t = n.bounding;
  if (!t)
    throw "error in mesh decompressing data: bounding not found, cannot use the bounding decompression.";
  for (var r = BBox.getMin(t), s = BBox.getMax(t), a = vec3.sub(vec3.create(), s, r), o = n.format, u = 1 / 255, h = 1 / 65535, l = n.vertices, c = new Float32Array(l.length), d = 0, f = l.length; d < f; d += 3)
    c[d] = l[d] * h * a[0] + r[0], c[d + 1] = l[d + 1] * h * a[1] + r[1], c[d + 2] = l[d + 2] * h * a[2] + r[2];
  if (n.vertices = c, n.normals && n.normals.constructor != Float32Array) {
    for (var _ = n.normals, E = new Float32Array(_.length), m = _.constructor == Uint8Array ? u : h, d = 0, f = _.length; d < f; d += 3) {
      E[d] = _[d] * m * 2 - 1, E[d + 1] = _[d + 1] * m * 2 - 1, E[d + 2] = _[d + 2] * m * 2 - 1;
      var T = E.subarray(d, d + 3);
      vec3.normalize(T, T);
    }
    n.normals = E;
  }
  if (n.coords && o.uvs_bounding && n.coords.constructor != Float32Array) {
    for (var L = n.coords, G = o.uvs_bounding, a = [G[2] - G[0], G[3] - G[1]], O = new Float32Array(L.length), d = 0, f = L.length; d < f; d += 2)
      O[d] = L[d] * h * a[0] + G[0], O[d + 1] = L[d + 1] * h * a[1] + G[1];
    n.coords = O;
  }
  if (n.weights && n.weights.constructor != Float32Array) {
    for (var b = n.weights, I = new Float32Array(b.length), S = b.constructor == Uint8Array ? u : h, d = 0, f = b.length; d < f; d += 4)
      I[d] = b[d] * S, I[d + 1] = b[d + 1] * S, I[d + 2] = b[d + 2] * S, I[d + 3] = b[d + 3] * S;
    n.weights = I;
  }
};
const Jt = class Jt {
  constructor(t, r, s, a, o) {
    t = t || 1024, GL$1.debug && console.log("GL.Mesh created"), o !== null && (o = o || global$1.gl, this.gl = o), this._context_id = o.context_id, this.vertexBuffers = {}, this.indexBuffers = {}, this.info = {
      groups: []
    }, this._bounding = BBox.create(), this.resize(t);
  }
  resize(t) {
    var r = {};
    this._vertex_data = new Float32Array(t * 3), r.vertices = this._vertex_data, normals && (r.normals = this._normal_data = new Float32Array(t * 3)), coords && (r.coords = this._coord_data = new Float32Array(t * 2)), colors && (r.colors = this._color_data = new Float32Array(t * 4)), this.addBuffers(r), this.current_pos = 0, this.max_size = t, this._must_update = !0;
  }
  clear() {
    this.current_pos = 0;
  }
  addPoint(t, r, s, a) {
    if (o >= this.max_size)
      return console.warn("DynamicMesh: not enough space, reserve more"), !1;
    var o = this.current_pos++;
    return this._vertex_data.set(t, o * 3), this._normal_data && this._normal_data.set(r || Jt.DEFAULT_NORMAL, o * 3), this._coord_data && this._coord_data.set(s || Jt.DEFAULT_COORD, o * 2), this._color_data && this._color_data.set(a || Jt.DEFAULT_COLOR, o * 4), this._must_update = !0, !0;
  }
  update(t) {
    return !this._must_update && !t ? this.current_pos : (this._must_update = !1, this.getBuffer("vertices").upload(gl.STREAM_DRAW), this._normal_data && this.getBuffer("normal").upload(gl.STREAM_DRAW), this._coord_data && this.getBuffer("coord").upload(gl.STREAM_DRAW), this._color_data && this.getBuffer("color").upload(gl.STREAM_DRAW), this.current_pos);
  }
};
g(Jt, "DEFAULT_NORMAL", vec3.fromValues(0, 1, 0)), g(Jt, "DEFAULT_COORD", vec2.fromValues(0.5, 0.5)), g(Jt, "DEFAULT_COLOR", vec4.fromValues(1, 1, 1, 1));
let DynamicMesh = Jt;
GL$1.extendClass(DynamicMesh, Mesh$1);
const et = class et {
  constructor(t, r, s = {}, a) {
    if (a = a || global$1.gl, this.gl = a, this._context_id = a.context_id, t = parseInt(t), r = parseInt(r), GL$1.debug && console.log("GL.Texture created: ", t, r), this.handler = a.createTexture(), this.width = t, this.height = r, s.depth && (this.depth = s.depth), this.texture_type = s.texture_type || a.TEXTURE_2D, this.format = s.format || et.DEFAULT_FORMAT, this.internalFormat = s.internalFormat, this.type = s.type || et.DEFAULT_TYPE, this.magFilter = s.magFilter || s.filter || et.DEFAULT_MAG_FILTER, this.minFilter = s.minFilter || s.filter || et.DEFAULT_MIN_FILTER, this.wrapS = s.wrap || s.wrapS || et.DEFAULT_WRAP_S, this.wrapT = s.wrap || s.wrapT || et.DEFAULT_WRAP_T, this.data = null, et.MAX_TEXTURE_IMAGE_UNITS || (et.MAX_TEXTURE_IMAGE_UNITS = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)), this.has_mipmaps = !1, this.format == a.DEPTH_COMPONENT && a.webgl_version == 1 && !a.extensions.WEBGL_depth_texture)
      throw "Depth Texture not supported";
    if (this.type == a.FLOAT && !a.extensions.OES_texture_float && a.webgl_version == 1)
      throw "Float Texture not supported";
    if (this.type == a.HALF_FLOAT_OES) {
      if (!a.extensions.OES_texture_half_float && a.webgl_version == 1)
        throw "Half Float Texture extension not supported.";
      a.webgl_version > 1 && (console.warn("using HALF_FLOAT_OES in WebGL2 is deprecated, suing HALF_FLOAT instead"), this.type = this.format == a.RGB ? a.RGB16F : a.RGBA16F);
    }
    if ((!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) && //non power of two
    (this.minFilter != a.NEAREST && this.minFilter != a.LINEAR || //uses mipmaps
    this.wrapS != a.CLAMP_TO_EDGE || this.wrapT != a.CLAMP_TO_EDGE))
      if (s.ignore_pot)
        this.minFilter = this.magFilter = a.LINEAR, this.wrapS = this.wrapT = a.CLAMP_TO_EDGE;
      else
        throw "Cannot use texture-wrap or mipmaps in Non-Power-of-Two textures";
    if (!t || !r)
      return;
    this.internalFormat || this.computeInternalFormat(), a.activeTexture(a.TEXTURE0 + et.MAX_TEXTURE_IMAGE_UNITS - 1), a.bindTexture(this.texture_type, this.handler), a.texParameteri(this.texture_type, a.TEXTURE_MAG_FILTER, this.magFilter), a.texParameteri(this.texture_type, a.TEXTURE_MIN_FILTER, this.minFilter), a.texParameteri(this.texture_type, a.TEXTURE_WRAP_S, this.wrapS), a.texParameteri(this.texture_type, a.TEXTURE_WRAP_T, this.wrapT), s.anisotropic && a.extensions.EXT_texture_filter_anisotropic && a.texParameterf(GL$1.TEXTURE_2D, a.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.anisotropic);
    var o = this.type, u = s.pixel_data;
    if (u && !u.buffer) {
      if (this.texture_type == GL$1.TEXTURE_CUBE_MAP)
        if (u[0].constructor === Number)
          u = l(u), u = [u, u, u, u, u, u];
        else
          for (var h = 0; h < u.length; ++h)
            u[h] = l(u[h]);
      else
        u = l(u);
      this.data = u;
    }
    function l(c) {
      return c.constructor !== Array ? c : o == GL$1.FLOAT ? new Float32Array(c) : o == GL$1.HALF_FLOAT_OES ? new Uint16Array(c) : new Uint8Array(c);
    }
    if (this.texture_type == GL$1.TEXTURE_2D)
      a.texImage2D(GL$1.TEXTURE_2D, 0, this.internalFormat, t, r, 0, this.format, this.type, u || null), GL$1.isPowerOfTwo(t) && GL$1.isPowerOfTwo(r) && s.minFilter && s.minFilter != a.NEAREST && s.minFilter != a.LINEAR && (a.generateMipmap(this.texture_type), this.has_mipmaps = !0);
    else if (this.texture_type == GL$1.TEXTURE_CUBE_MAP)
      for (var h = 0; h < 6; ++h)
        a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, this.internalFormat, this.width, this.height, 0, this.format, this.type, u ? u[h] : null);
    else if (this.texture_type == GL$1.TEXTURE_3D) {
      if (this.gl.webgl_version == 1)
        throw "TEXTURE_3D not supported in WebGL 1. Enable WebGL 2 in the context by passing webgl2:true to the context";
      if (!s.depth)
        throw "3d texture depth must be set in the options.depth";
      a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1), a.texImage3D(GL$1.TEXTURE_3D, 0, this.internalFormat, t, r, s.depth, 0, this.format, this.type, u || null);
    }
    a.bindTexture(this.texture_type, null), a.activeTexture(a.TEXTURE0);
  }
  //should improve performance
  //because usually you dont want to specify the internalFormat, this tries to guess it from its format
  //check https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html for more info
  computeInternalFormat() {
    if (this.internalFormat = this.format, this.format == GL$1.DEPTH_COMPONENT) {
      if (this.minFilter = this.magFilter = GL$1.NEAREST, gl.webgl_version == 2)
        if (this.type == GL$1.UNSIGNED_SHORT)
          this.internalFormat = GL$1.DEPTH_COMPONENT16;
        else if (this.type == GL$1.UNSIGNED_INT)
          this.internalFormat = GL$1.DEPTH_COMPONENT24;
        else if (this.type == GL$1.FLOAT)
          this.internalFormat = GL$1.DEPTH_COMPONENT32F;
        else
          throw "unsupported type for a depth texture";
      else if (gl.webgl_version == 1) {
        if (this.type == GL$1.FLOAT)
          throw "WebGL 1.0 does not support float depth textures";
        this.internalFormat = GL$1.DEPTH_COMPONENT;
      }
    } else this.format == gl.RGBA && (gl.webgl_version == 2 ? this.type == GL$1.FLOAT ? this.internalFormat = GL$1.RGBA32F : this.type == GL$1.HALF_FLOAT ? this.internalFormat = GL$1.RGBA16F : this.type == GL$1.HALF_FLOAT_OES && (console.warn("webgl 2 does not use HALF_FLOAT_OES, converting to HALF_FLOAT"), this.type = GL$1.HALF_FLOAT, this.internalFormat = GL$1.RGBA16F) : gl.webgl_version == 1 && this.type == GL$1.HALF_FLOAT && (console.warn("webgl 1 does not use HALF_FLOAT, converting to HALF_FLOAT_OES"), this.type = GL$1.HALF_FLOAT_OES));
  }
  /**
  * Free the texture memory from the GPU, sets the texture handler to null
  * @method delete
  */
  delete() {
    gl.deleteTexture(this.handler), this.handler = null;
  }
  getProperties() {
    return {
      width: this.width,
      height: this.height,
      type: this.type,
      format: this.format,
      texture_type: this.texture_type,
      magFilter: this.magFilter,
      minFilter: this.minFilter,
      wrapS: this.wrapS,
      wrapT: this.wrapT
    };
  }
  hasSameProperties(t) {
    return t ? t.width == this.width && t.height == this.height && t.type == this.type && t.format == this.format && t.texture_type == this.texture_type : !1;
  }
  hasSameSize(t) {
    return t ? t.width == this.width && t.height == this.height : !1;
  }
  //textures cannot be stored in JSON
  toJSON() {
    return "";
  }
  /**
  * Returns if depth texture is supported by the GPU
  * @method isDepthSupported
  * @return {Boolean} true if supported
  */
  static isDepthSupported() {
    return gl.extensions.WEBGL_depth_texture != null;
  }
  /**
  * Binds the texture to one texture unit
  * @method bind
  * @param {number} unit texture unit
  * @return {number} returns the texture unit
  */
  bind(t) {
    t == null && (t = 0);
    var r = this.gl;
    return r.activeTexture(r.TEXTURE0 + t), r.bindTexture(this.texture_type, this.handler), t;
  }
  /**
  * Unbinds the texture 
  * @method unbind
  * @param {number} unit texture unit
  * @return {number} returns the texture unit
  */
  unbind(t) {
    t === void 0 && (t = 0);
    var r = this.gl;
    r.activeTexture(r.TEXTURE0 + t), r.bindTexture(this.texture_type, null);
  }
  setParameter(t, r) {
    switch (this.bind(0), this.gl.texParameteri(this.texture_type, t, r), t) {
      case this.gl.TEXTURE_MAG_FILTER:
        this.magFilter = r;
        break;
      case this.gl.TEXTURE_MIN_FILTER:
        this.minFilter = r;
        break;
      case this.gl.TEXTURE_WRAP_S:
        this.wrapS = r;
        break;
      case this.gl.TEXTURE_WRAP_T:
        this.wrapT = r;
        break;
    }
  }
  /**
  * Unbinds the texture 
  * @method Texture.setUploadOptions
  * @param {Object} options a list of options to upload the texture
  * - premultiply_alpha : multiply the color by the alpha value, default FALSE
  * - no_flip : do not flip in Y, default TRUE
  */
  static setUploadOptions(t, r) {
    r = r || global$1.gl, t ? (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!t.premultiply_alpha), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !t.no_flip)) : (r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !0)), r.pixelStorei(r.UNPACK_ALIGNMENT, 1);
  }
  /**
  * Given an Image/Canvas/Video it uploads it to the GPU
  * @method uploadImage
  * @param {Image} img
  * @param {Object} options [optional] upload options (premultiply_alpha, no_flip)
  */
  uploadImage(t, r) {
    this.bind();
    var s = this.gl;
    if (!t)
      throw "uploadImage parameter must be Image";
    et.setUploadOptions(r, s);
    try {
      s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, this.type, t), this.width = t.videoWidth || t.width, this.height = t.videoHeight || t.height, this.data = t;
    } catch {
      throw location.protocol == "file:" ? 'image not loaded for security reasons (serve this page over "http://" instead)' : "image not loaded for security reasons (image must originate from the same domain as this page or use Cross-Origin Resource Sharing)";
    }
    this.minFilter && this.minFilter != s.NEAREST && this.minFilter != s.LINEAR && (s.generateMipmap(this.texture_type), this.has_mipmaps = !0), s.bindTexture(this.texture_type, null);
  }
  /**
  * Uploads data to the GPU (data must have the appropiate size)
  * @method uploadData
  * @param {ArrayBuffer} data
  * @param {Object} options [optional] upload options (premultiply_alpha, no_flip, cubemap_face, mipmap_level)
  */
  uploadData(t, r = {}, s) {
    if (!t)
      throw "no data passed";
    var a = this.gl;
    this.bind(), et.setUploadOptions(r, a);
    var o = r.mipmap_level || 0, u = this.width, h = this.height;
    u = u >> o, h = h >> o;
    var l = this.internalFormat || this.format;
    if (this.type == GL$1.HALF_FLOAT_OES && t.constructor === Float32Array && console.warn("cannot uploadData to a HALF_FLOAT texture from a Float32Array, must be Uint16Array. To upload it we recomment to create a FLOAT texture, upload data there and copy to your HALF_FLOAT."), this.texture_type == GL$1.TEXTURE_2D)
      a.webgl_version == 1 ? t.buffer && t.buffer.constructor == ArrayBuffer ? a.texImage2D(this.texture_type, o, l, u, h, 0, this.format, this.type, t) : a.texImage2D(this.texture_type, o, l, this.format, this.type, t) : a.webgl_version == 2 && (t.buffer && t.buffer.constructor == ArrayBuffer ? a.texImage2D(this.texture_type, o, l, u, h, 0, this.format, this.type, t) : a.texImage2D(this.texture_type, o, l, u, h, 0, this.format, this.type, t));
    else if (this.texture_type == GL$1.TEXTURE_3D)
      a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1), a.texImage3D(this.texture_type, o, l, u, h, this.depth >> o, 0, this.format, this.type, t);
    else if (this.texture_type == GL$1.TEXTURE_CUBE_MAP)
      a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + (r.cubemap_face || 0), o, l, u, h, 0, this.format, this.type, t);
    else
      throw "cannot uploadData for this texture type";
    this.data = t, !s && this.minFilter && this.minFilter != a.NEAREST && this.minFilter != a.LINEAR && (a.generateMipmap(this.texture_type), this.has_mipmaps = !0), a.bindTexture(this.texture_type, null);
  }
  /**
  * Render to texture using FBO, just pass the callback to a rendering function and the content of the texture will be updated
  * If the texture is a cubemap, the callback will be called six times, once per face, the number of the face is passed as a second parameter
  * for further info about how to set up the propper cubemap camera, check the GL.Texture.cubemap_camera_parameters with the direction and up vector for every face.
  *
  * Keep in mind that it tries to reuse the last renderbuffer for the depth, and if it cannot (different size) it creates a new one (throwing the old)
  * @method drawTo
  * @param {Function} callback function that does all the rendering inside this texture
  */
  drawTo(t, r) {
    var s = this.gl, a = s.getViewport(), o = GL$1.getTime(), u = s.getParameter(s.FRAMEBUFFER_BINDING), h = s._framebuffer = s._framebuffer || s.createFramebuffer();
    s.bindFramebuffer(s.FRAMEBUFFER, h);
    var l = null;
    {
      s._renderbuffers_pool || (s._renderbuffers_pool = {});
      var c = this.width + ":" + this.height;
      s._renderbuffers_pool[c] ? (l = s._renderbuffers_pool[c], l.time = o, s.bindRenderbuffer(s.RENDERBUFFER, l)) : (s._renderbuffers_pool[c] = l = s.createRenderbuffer(), l.time = o, l.width = this.width, l.height = this.height, s.bindRenderbuffer(s.RENDERBUFFER, l), setTimeout(d.bind(l), 1e3 * 60));
    }
    this.format === s.DEPTH_COMPONENT ? s.renderbufferStorage(s.RENDERBUFFER, s.RGBA4, this.width, this.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_COMPONENT16, this.width, this.height);
    function d() {
      GL$1.getTime() - this.time >= 1e3 * 60 ? (s.deleteRenderbuffer(s._renderbuffers_pool[c]), delete s._renderbuffers_pool[c]) : setTimeout(d.bind(this), 1e3 * 60);
    }
    if (s.viewport(0, 0, this.width, this.height), s._current_texture_drawto = this, s._current_fbo_color = h, s._current_fbo_depth = l, this.texture_type == s.TEXTURE_2D)
      this.format !== s.DEPTH_COMPONENT ? (s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, this.handler, 0), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, l)) : (s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, l), s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, this.handler, 0)), t(this, r);
    else if (this.texture_type == s.TEXTURE_CUBE_MAP) {
      this.format !== s.DEPTH_COMPONENT ? s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, l) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, l);
      for (var f = 0; f < 6; f++)
        this.format !== s.DEPTH_COMPONENT ? s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + f, this.handler, 0) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_CUBE_MAP_POSITIVE_X + f, this.handler, 0), t(this, f, r);
    }
    return this.data = null, s._current_texture_drawto = null, s._current_fbo_color = null, s._current_fbo_depth = null, s.bindFramebuffer(s.FRAMEBUFFER, u), s.bindRenderbuffer(s.RENDERBUFFER, null), s.viewport(a[0], a[1], a[2], a[3]), this;
  }
  /**
  * Static version of drawTo meant to be used with several buffers
  * @method drawToColorAndDepth
  * @param {Texture} color_texture
  * @param {Texture} depth_texture
  * @param {Function} callback
  */
  static drawTo(t, r, s) {
    var a = -1, o = -1, u = null;
    if (!t && !s)
      throw "Textures missing in drawTo";
    if (t && t.length)
      for (var h = 0; h < t.length; h++) {
        var l = t[h];
        if (a == -1)
          a = l.width;
        else if (a != l.width)
          throw "Cannot use Texture.drawTo if textures have different dimensions";
        if (o == -1)
          o = l.height;
        else if (o != l.height)
          throw "Cannot use Texture.drawTo if textures have different dimensions";
        if (u == null)
          u = l.type;
        else if (u != l.type)
          throw "Cannot use Texture.drawTo if textures have different data type, all must have the same type";
      }
    else
      a = s.width, o = s.height;
    var c = gl.extensions.WEBGL_draw_buffers;
    if (!c && t && t.length > 1)
      throw "Rendering to several textures not supported";
    var d = gl.getViewport();
    gl._framebuffer = gl._framebuffer || gl.createFramebuffer(), gl.bindFramebuffer(gl.FRAMEBUFFER, gl._framebuffer), gl.viewport(0, 0, a, o);
    var f = null;
    if (s && s.format !== gl.DEPTH_COMPONENT || s.type != gl.UNSIGNED_INT)
      throw "Depth texture must be of format: gl.DEPTH_COMPONENT and type: gl.UNSIGNED_INT";
    if (s ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, s.handler, 0) : (f = gl._renderbuffer = gl._renderbuffer || gl.createRenderbuffer(), f.width = a, f.height = o, gl.bindRenderbuffer(gl.RENDERBUFFER, f), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, a, o), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f)), t) {
      for (var _ = [], h = 0; h < t.length; h++) {
        var l = t[h];
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + h, gl.TEXTURE_2D, l.handler, 0), _.push(gl.COLOR_ATTACHMENT0 + h);
      }
      t.length > 1 && c.drawBuffersWEBGL(_);
    } else {
      var E = this._color_renderbuffer = this._color_renderbuffer || gl.createRenderbuffer();
      E.width = a, E.height = o, gl.bindRenderbuffer(gl.RENDERBUFFER, E), gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, a, o), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, E);
    }
    var m = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (m !== gl.FRAMEBUFFER_COMPLETE)
      throw "FBO not complete: " + m;
    if (r(), t.length)
      for (var h = 0; h < t.length; ++h)
        t[h].data = null;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.viewport(d[0], d[1], d[2], d[3]);
  }
  /**
  * Similar to drawTo but it also stores the depth in a depth texture
  * @method drawToColorAndDepth
  * @param {Texture} color_texture
  * @param {Texture} depth_texture
  * @param {Function} callback
  */
  static drawToColorAndDepth(t, r, s) {
    var a = t.gl;
    if (r.width != t.width || r.height != t.height)
      throw "Different size between color texture and depth texture";
    var o = a.getViewport();
    a._framebuffer = a._framebuffer || a.createFramebuffer(), a.bindFramebuffer(a.FRAMEBUFFER, a._framebuffer), a.viewport(0, 0, t.width, t.height), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, t.handler, 0), a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, r.handler, 0), s(), t.data = null, r.data = null, a.bindFramebuffer(a.FRAMEBUFFER, null), a.viewport(o[0], o[1], o[2], o[3]);
  }
  /**
  * Copy content of one texture into another
  * TODO: check using copyTexImage2D
  * @method copyTo
  * @param {GL.Texture} target_texture
  * @param {GL.Shader} [shader=null] optional shader to apply while copying
  * @param {Object} [uniforms=null] optional uniforms for the shader
  */
  copyTo(t, r, s) {
    var a = this.gl;
    if (!t)
      throw "target_texture required";
    var o = a.getParameter(a.FRAMEBUFFER_BINDING), u = a.getViewport();
    r || (r = this.texture_type == a.TEXTURE_2D ? GL$1.Shader.getScreenShader() : GL$1.Shader.getCubemapCopyShader()), a.disable(a.BLEND), a.disable(a.DEPTH_TEST), r && s && r.uniforms(s);
    var h = a.__copy_fbo;
    if (h || (h = a.__copy_fbo = a.createFramebuffer()), a.bindFramebuffer(a.FRAMEBUFFER, h), a.viewport(0, 0, t.width, t.height), this.texture_type == a.TEXTURE_2D)
      if (this.format !== a.DEPTH_COMPONENT && this.format !== a.DEPTH_STENCIL)
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, t.handler, 0), this.toViewport(r);
      else {
        var l = a._color_renderbuffer = a._color_renderbuffer || a.createRenderbuffer(), c = l.width = t.width, d = l.height = t.height;
        a.bindRenderbuffer(a.RENDERBUFFER, l), a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c, d), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, l);
        var f = t.format == a.DEPTH_STENCIL ? a.DEPTH_STENCIL_ATTACHMENT : a.DEPTH_ATTACHMENT;
        a.framebufferTexture2D(a.FRAMEBUFFER, f, a.TEXTURE_2D, t.handler, 0);
        var _ = a.checkFramebufferStatus(a.FRAMEBUFFER);
        if (_ !== a.FRAMEBUFFER_COMPLETE)
          throw "FBO not complete: " + _;
        a.enable(a.DEPTH_TEST), a.depthFunc(a.ALWAYS), a.colorMask(!1, !1, !1, !1), r = GL$1.Shader.getCopyDepthShader(), this.toViewport(r), a.colorMask(!0, !0, !0, !0), a.disable(a.DEPTH_TEST), a.depthFunc(a.LEQUAL), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null), a.framebufferTexture2D(a.FRAMEBUFFER, f, a.TEXTURE_2D, null, 0);
      }
    else if (this.texture_type == a.TEXTURE_CUBE_MAP) {
      r.uniforms({ u_texture: 0 });
      for (var E = GL$1.temp_mat3, m = 0; m < 6; m++) {
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + m, t.handler, 0);
        var T = GL$1.Texture.cubemap_camera_parameters[m];
        mat3.identity(E), E.set(T.right, 0), E.set(T.up, 3), E.set(T.dir, 6), this.toViewport(r, { u_rotation: E });
      }
    }
    return a.setViewport(u), a.bindFramebuffer(a.FRAMEBUFFER, o), t.minFilter && t.minFilter != a.NEAREST && t.minFilter != a.LINEAR && (t.bind(), a.generateMipmap(t.texture_type), t.has_mipmaps = !0), t.data = null, a.bindTexture(t.texture_type, null), this;
  }
  /**
  * Render texture in a quad to full viewport size
  * @method toViewport
  * @param {Shader} shader to apply, otherwise a default textured shader is applied [optional]
  * @param {Object} uniforms for the shader if needed [optional]
  */
  toViewport(t, r) {
    t = t || Shader.getScreenShader();
    var s = Mesh$1.getScreenQuad();
    this.bind(0), r && t.uniforms(r), t.draw(s, gl.TRIANGLES);
  }
  /**
  * Fills the texture with a constant color (uses gl.clear)
  * @method fill
  * @param {vec4} color rgba
  * @param {boolean} skip_mipmaps if true the mipmaps wont be updated
  */
  fill(t, r) {
    var s = gl.getParameter(gl.COLOR_CLEAR_VALUE);
    gl.clearColor(t[0], t[1], t[2], t[3]), this.drawTo(function() {
      gl.clear(gl.COLOR_BUFFER_BIT);
    }), gl.clearColor(s[0], s[1], s[2], s[3]), !r && this.minFilter && this.minFilter != gl.NEAREST && this.minFilter != gl.LINEAR && (this.bind(), gl.generateMipmap(this.texture_type), this.has_mipmaps = !0);
  }
  /**
  * Applies a blur filter of 5x5 pixels to the texture (be careful using it, it is slow)
  * @method applyBlur
  * @param {Number} offsetx scalar that multiplies the offset when fetching pixels horizontally (default 1)
  * @param {Number} offsety scalar that multiplies the offset when fetching pixels vertically (default 1)
  * @param {Number} intensity scalar that multiplies the result (default 1)
  * @param {Texture} output_texture [optional] if not passed the output is the own texture
  * @param {Texture} temp_texture blur needs a temp texture, if not supplied it will use the temporary textures pool
  * @return {Texture} returns the temp_texture in case you want to reuse it
  */
  applyBlur(t, r, s, a, o) {
    var u = this.gl;
    t === void 0 && (t = 1), r === void 0 && (r = 1), u.disable(u.DEPTH_TEST), u.disable(u.BLEND), a = a || this;
    var h = !o;
    if (o === a)
      throw "cannot use applyBlur in a texture using as temporary itself";
    if (a && this.texture_type !== a.texture_type)
      throw "cannot use applyBlur with textures of different texture_type";
    var l = u.getParameter(u.FRAMEBUFFER_BINDING), c = u.getViewport(), d = u.__copy_fbo;
    if (d || (d = u.__copy_fbo = u.createFramebuffer()), u.bindFramebuffer(u.FRAMEBUFFER, d), u.viewport(0, 0, this.width, this.height), this.texture_type === u.TEXTURE_2D) {
      var f = GL$1.Shader.getBlurShader();
      o || (o = GL$1.Texture.getTemporary(this.width, this.height, this)), u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, o.handler, 0), this.toViewport(f, { u_texture: 0, u_intensity: s, u_offset: [0, r / this.height] }), u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, a.handler, 0), u.viewport(0, 0, a.width, a.height), o.toViewport(f, { u_intensity: s, u_offset: [t / o.width, 0] }), h && GL$1.Texture.releaseTemporary(o);
    } else if (this.texture_type === u.TEXTURE_CUBE_MAP) {
      var f = GL$1.Shader.getCubemapBlurShader();
      f.uniforms({ u_texture: 0, u_intensity: s, u_offset: [t / this.width, r / this.height] }), this.bind(0);
      var _ = Mesh$1.getScreenQuad();
      _.bindBuffers(f), f.bind();
      var E = null;
      !o && a == this ? E = o = GL$1.Texture.getTemporary(a.width, a.height, a) : E = a;
      for (var m = GL$1.temp_mat3, T = 0; T < 6; ++T) {
        u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_CUBE_MAP_POSITIVE_X + T, E.handler, 0);
        var L = GL$1.Texture.cubemap_camera_parameters[T];
        mat3.identity(m), m.set(L.right, 0), m.set(L.up, 3), m.set(L.dir, 6), f._setUniform("u_rotation", m), u.drawArrays(u.TRIANGLES, 0, 6);
      }
      _.unbindBuffers(f), o && o.copyTo(a), o && h && GL$1.Texture.releaseTemporary(o);
    }
    u.setViewport(c), u.bindFramebuffer(u.FRAMEBUFFER, l), a.data = null, a.minFilter && a.minFilter != u.NEAREST && a.minFilter != u.LINEAR && (a.bind(), u.generateMipmap(a.texture_type), a.has_mipmaps = !0), u.bindTexture(a.texture_type, null);
  }
  /**
  * Loads and uploads a texture from a url
  * @method Texture.fromURL
  * @param {String} url
  * @param {Object} options
  * @param {Function} on_complete
  * @return {Texture} the texture
  */
  static fromURL(t, r = {}, s, a) {
    a = a || global$1.gl, r = Object.create(r);
    var o = r.texture || new GL$1.Texture(1, 1, r, a);
    t.length < 64 && (o.url = t), o.bind();
    var u = r.temp_color || et.loading_color;
    a.pixelStorei(a.UNPACK_ALIGNMENT, 4);
    var h = r.type == a.FLOAT ? new Float32Array(u) : new Uint8Array(u);
    a.texImage2D(a.TEXTURE_2D, 0, o.format, o.width, o.height, 0, o.format, o.type, h), a.bindTexture(o.texture_type, null), o.ready = !1;
    var l = null;
    if (r.extension && (l = r.extension), !l && t.length < 512) {
      var c = t, d = t.indexOf("?");
      d != -1 && (c = t.substr(0, d)), d = c.lastIndexOf("."), d != -1 && (l = c.substr(d + 1).toLowerCase());
    }
    if (l == "dds") {
      var l = a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBGL_compressed_texture_s3tc"), f = new GL$1.Texture(0, 0, r, a);
      DDS.loadDDSTextureEx(a, l, t, f.handler, !0, function(m) {
        o.texture_type = m.texture_type, o.handler = m, delete o.ready, s && s(o, t);
      });
    } else if (l == "tga")
      HttpRequest(t, null, function(E) {
        var m = GL$1.Texture.parseTGA(E);
        m && (r.texture = o, m.format == "RGB" && (o.format = a.RGB), o = GL$1.Texture.fromMemory(m.width, m.height, m.pixels, r), delete o.ready, s && s(o, t));
      }, null, { binary: !0 });
    else {
      var _ = new Image();
      _.src = t, _.onload = function() {
        r.texture = o, GL$1.Texture.fromImage(this, r), delete o.ready, s && s(o, t);
      }, _.onerror = function() {
        s && s(null);
      };
    }
    return o;
  }
  static parseTGA(t) {
    if (!t || t.constructor !== ArrayBuffer)
      throw "TGA: data must be ArrayBuffer";
    t = new Uint8Array(t);
    for (var r = new Uint8Array([0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0]), s = t.subarray(0, 12), a = 0; a < s.length; a++)
      if (r[a] != s[a])
        return console.error("TGA header is not valid"), null;
    var o = t.subarray(12, 18), u = {};
    if (u.width = o[1] * 256 + o[0], u.height = o[3] * 256 + o[2], u.bpp = o[4], u.bytesPerPixel = u.bpp / 8, u.imageSize = u.width * u.height * u.bytesPerPixel, u.pixels = t.subarray(18, 18 + u.imageSize), u.pixels = new Uint8Array(u.pixels), (o[5] & 16) == 0) {
      for (var a = 0; a < u.imageSize; a += u.bytesPerPixel) {
        var h = u.pixels[a];
        u.pixels[a] = u.pixels[a + 2], u.pixels[a + 2] = h;
      }
      o[5] |= 16, u.format = u.bpp == 32 ? "RGBA" : "RGB";
    } else
      u.format = u.bpp == 32 ? "RGBA" : "RGB";
    return u.flipY = !0, u;
  }
  /**
  * Create a texture from an Image
  * @method Texture.fromImage
  * @param {Image} image
  * @param {Object} options
  * @return {Texture} the texture
  */
  static fromImage(t, r = {}) {
    var s = r.texture || new GL$1.Texture(t.width, t.height, r);
    return s.uploadImage(t, r), s.bind(), gl.texParameteri(s.texture_type, gl.TEXTURE_MAG_FILTER, s.magFilter), gl.texParameteri(s.texture_type, gl.TEXTURE_MIN_FILTER, s.minFilter), gl.texParameteri(s.texture_type, gl.TEXTURE_WRAP_S, s.wrapS), gl.texParameteri(s.texture_type, gl.TEXTURE_WRAP_T, s.wrapT), GL$1.isPowerOfTwo(s.width) && GL$1.isPowerOfTwo(s.height) ? r.minFilter && r.minFilter != gl.NEAREST && r.minFilter != gl.LINEAR && (s.bind(), gl.generateMipmap(s.texture_type), s.has_mipmaps = !0) : (gl.texParameteri(s.texture_type, gl.TEXTURE_MIN_FILTER, GL$1.LINEAR), gl.texParameteri(s.texture_type, gl.TEXTURE_WRAP_S, GL$1.CLAMP_TO_EDGE), gl.texParameteri(s.texture_type, gl.TEXTURE_WRAP_T, GL$1.CLAMP_TO_EDGE), s.has_mipmaps = !1), gl.bindTexture(s.texture_type, null), s.data = t, r.keep_image && (s.img = t), s;
  }
  /**
  * Create a texture from a Video
  * @method Texture.fromVideo
  * @param {Video} video
  * @param {Object} options
  * @return {Texture} the texture
  */
  static fromVideo(t, r = {}) {
    var s = r.texture || new GL$1.Texture(t.videoWidth, t.videoHeight, r);
    return s.bind(), s.uploadImage(t, r), r.minFilter && r.minFilter != gl.NEAREST && r.minFilter != gl.LINEAR && (s.bind(), gl.generateMipmap(s.texture_type), s.has_mipmaps = !0, s.data = t), gl.bindTexture(s.texture_type, null), s;
  }
  /**
  * Create a clone of a texture
  * @method Texture.fromTexture
  * @param {Texture} old_texture
  * @param {Object} options
  * @return {Texture} the texture
  */
  static fromTexture(t, r = {}) {
    var s = new GL$1.Texture(t.width, t.height, r);
    return t.copyTo(s), s;
  }
  clone(t) {
    var r = this.getProperties();
    if (t)
      for (var s in t)
        r[s] = t[s];
    return et.fromTexture(this, r);
  }
  /**
  * Create a texture from an ArrayBuffer containing the pixels
  * @method Texture.fromTexture
  * @param {number} width
  * @param {number} height
  * @param {ArrayBuffer} pixels
  * @param {Object} options
  * @return {Texture} the texture
  */
  static fromMemory(t, r, s, a = {}) {
    var o = a.texture || new GL$1.Texture(t, r, a);
    return et.setUploadOptions(a), o.bind(), s.constructor === Array && (a.type == gl.FLOAT ? s = new Float32Array(s) : a.type == GL$1.HALF_FLOAT || a.type == GL$1.HALF_FLOAT_OES ? s = new Uint16Array(s) : s = new Uint8Array(s)), gl.texImage2D(gl.TEXTURE_2D, 0, o.format, t, r, 0, o.format, o.type, s), o.width = t, o.height = r, o.data = s, a.minFilter && a.minFilter != gl.NEAREST && a.minFilter != gl.LINEAR && (gl.generateMipmap(gl.TEXTURE_2D), o.has_mipmaps = !0), gl.bindTexture(o.texture_type, null), o;
  }
  /**
  * Create a texture from an ArrayBuffer containing the pixels
  * @method Texture.fromDDSInMemory
  * @param {ArrayBuffer} DDS data
  * @param {Object} options
  * @return {Texture} the texture
  */
  static fromDDSInMemory(t, r = {}) {
    var s = r.texture || new GL$1.Texture(0, 0, r);
    GL$1.Texture.setUploadOptions(r), s.bind();
    var a = gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBGL_compressed_texture_s3tc");
    return DDS.loadDDSTextureFromMemoryEx(gl, a, t, s, !0), gl.bindTexture(s.texture_type, null), s;
  }
  /**
  * Create a generative texture from a shader ( must GL.Shader.getScreenShader as reference for the shader )
  * @method Texture.fromShader
  * @param {number} width
  * @param {number} height
  * @param {Shader} shader
  * @param {Object} options
  * @return {Texture} the texture
  */
  static fromShader(t, r, s, a = {}) {
    var o = new GL$1.Texture(t, r, a);
    return o.drawTo(function() {
      gl.disable(gl.BLEND), gl.disable(gl.DEPTH_TEST), gl.disable(gl.CULL_FACE);
      var u = Mesh$1.getScreenQuad();
      s.draw(u);
    }), o;
  }
  /**
  * Create a cubemap texture from a set of 6 images
  * @method Texture.cubemapFromImages
  * @param {Array} images
  * @param {Object} options
  * @return {Texture} the texture
  */
  static cubemapFromImages(t, r = {}) {
    if (t.length != 6)
      throw "missing images to create cubemap";
    var s = t[0].width, a = t[0].height;
    r.texture_type = gl.TEXTURE_CUBE_MAP;
    var o = null;
    r.texture ? (o = r.texture, o.width = s, o.height = a) : o = new GL$1.Texture(s, a, r), et.setUploadOptions(r), o.bind();
    try {
      for (var u = 0; u < 6; u++)
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + u, 0, o.format, o.format, o.type, t[u]);
      o.data = t;
    } catch {
      throw location.protocol == "file:" ? 'image not loaded for security reasons (serve this page over "http://" instead)' : "image not loaded for security reasons (image must originate from the same domain as this page or use Cross-Origin Resource Sharing)";
    }
    return r.minFilter && r.minFilter != gl.NEAREST && r.minFilter != gl.LINEAR && (gl.generateMipmap(gl.TEXTURE_CUBE_MAP), o.has_mipmaps = !0), o.unbind(), o;
  }
  /**
  * Create a cubemap texture from a single image that contains all six images 
  * If it is a cross, it must be horizontally aligned, and options.is_cross must be equal to the column where the top and bottom are located (usually 1 or 2)
  * otherwise it assumes the 6 images are arranged vertically, in the order of OpenGL: +X, -X, +Y, -Y, +Z, -Z
  * @method Texture.cubemapFromImage
  * @param {Image} image
  * @param {Object} options
  * @return {Texture} the texture
  */
  static cubemapFromImage(t, r = {}) {
    if (t.width != t.height / 6 && t.height % 6 != 0 && !r.faces && !r.is_polar)
      return console.error("Cubemap image not valid, only 1x6 (vertical) or 6x3 (cross) formats. Check size:", t.width, t.height), null;
    var s = t.width, a = t.height;
    if (r.is_polar) {
      var _ = r.size || GL$1.nearestPowerOfTwo(t.height), o = GL$1.Texture.fromImage(t, { ignore_pot: !0, wrap: gl.REPEAT, filter: gl.LINEAR }), u = new GL$1.Texture(_, _, { texture_type: gl.TEXTURE_CUBE_MAP, format: gl.RGBA });
      if (r.texture) {
        var h = r.texture;
        for (var l in u)
          h[l] = u[l];
        u = h;
      }
      var c = mat3.create(), d = { u_texture: 0, u_rotation: c };
      gl.disable(gl.DEPTH_TEST), gl.disable(gl.BLEND);
      var f = GL$1.Shader.getPolarToCubemapShader();
      return u.drawTo(function(O, b) {
        var I = GL$1.Texture.cubemap_camera_parameters[b];
        mat3.identity(c), c.set(I.right, 0), c.set(I.up, 3), c.set(I.dir, 6), o.toViewport(f, d);
      }), r.keep_image && (u.img = t), u;
    } else r.is_cross !== void 0 ? (r.faces = et.generateCubemapCrossFacesInfo(t.width, r.is_cross), s = a = t.width / 4) : r.faces ? (s = r.width || r.faces[0].width, a = r.height || r.faces[0].height) : a /= 6;
    if (s != a)
      return console.log("Texture not valid, width and height for every face must be square"), null;
    var _ = s;
    r.no_flip = !0;
    for (var E = [], l = 0; l < 6; l++) {
      var m = GL$1.createCanvas(_, _), T = m.getContext("2d");
      r.faces ? T.drawImage(t, r.faces[l].x, r.faces[l].y, r.faces[l].width || _, r.faces[l].height || _, 0, 0, _, _) : T.drawImage(t, 0, a * l, s, a, 0, 0, _, _), E.push(m);
    }
    var L = et.cubemapFromImages(E, r);
    return r.keep_image && (L.img = t), L;
  }
  /**
  * Given the width and the height of an image, and in which column is the top and bottom sides of the cubemap, it gets the info to pass to Texture.cubemapFromImage in options.faces
  * @method Texture.generateCubemapCrossFaces
  * @param {number} width of the CROSS image (not the side image)
  * @param {number} column the column where the top and the bottom is located
  * @return {Object} object to pass to Texture.cubemapFromImage in options.faces
  */
  static generateCubemapCrossFacesInfo(t, r) {
    r === void 0 && (r = 1);
    var s = t / 4;
    return [
      { x: 2 * s, y: s, width: s, height: s },
      //+x
      { x: 0, y: s, width: s, height: s },
      //-x
      { x: r * s, y: 0, width: s, height: s },
      //+y
      { x: r * s, y: 2 * s, width: s, height: s },
      //-y
      { x: s, y: s, width: s, height: s },
      //+z
      { x: 3 * s, y: s, width: s, height: s }
      //-z
    ];
  }
  /**
  * Create a cubemap texture from a single image url that contains the six images
  * if it is a cross, it must be horizontally aligned, and options.is_cross must be equal to the column where the top and bottom are located (usually 1 or 2)
  * otherwise it assumes the 6 images are arranged vertically.
  * @method Texture.cubemapFromURL
  * @param {Image} image
  * @param {Object} options
  * @param {Function} on_complete callback
  * @return {Texture} the texture
  */
  static cubemapFromURL(t, r = {}, s) {
    r = Object.create(r), r.texture_type = gl.TEXTURE_CUBE_MAP;
    var a = r.texture || new GL$1.Texture(1, 1, r);
    a.bind(), et.setUploadOptions(r);
    for (var o = r.temp_color || [0, 0, 0, 255], u = r.type == gl.FLOAT ? new Float32Array(o) : new Uint8Array(o), h = 0; h < 6; h++)
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, a.format, 1, 1, 0, a.format, a.type, u);
    gl.bindTexture(a.texture_type, null), a.ready = !1;
    var l = new Image();
    return l.src = t, l.onload = function() {
      r.texture = a, a = GL$1.Texture.cubemapFromImage(this, r), a && delete a.ready, s && s(a);
    }, a;
  }
  /**
  * returns an ArrayBuffer with the pixels in the texture, they are fliped in Y
  * Warn: If cubemap it only returns the pixels of the first face! use getCubemapPixels instead
  * @method getPixels
  * @param {number} cubemap_face [optional] the index of the cubemap face to read (ignore if texture_2D)
  * @param {number} mipmap level [optional, default is 0]
  * @return {ArrayBuffer} the data ( Uint8Array, Uint16Array or Float32Array )
  */
  getPixels(t, r) {
    r = r || 0;
    var s = this.gl, a = s.getViewport(), o = s.getParameter(s.FRAMEBUFFER_BINDING);
    if (this.format == s.DEPTH_COMPONENT)
      throw "cannot use getPixels in depth textures";
    s.disable(s.DEPTH_TEST);
    var u = s.__copy_fbo;
    u || (u = s.__copy_fbo = s.createFramebuffer()), s.bindFramebuffer(s.FRAMEBUFFER, u);
    var h = null, l = this.width >> r, c = this.height >> r;
    s.viewport(0, 0, l, c), this.texture_type == s.TEXTURE_2D ? s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, this.handler, r) : this.texture_type == s.TEXTURE_CUBE_MAP && s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + (t || 0), this.handler, r);
    var d = this.format == s.RGB ? 3 : 4;
    d = 4;
    var f = this.type;
    return f == s.UNSIGNED_BYTE ? h = new Uint8Array(l * c * d) : f == GL$1.HALF_FLOAT || f == GL$1.HALF_FLOAT_OES ? h = new Uint16Array(l * c * d) : h = new Float32Array(l * c * d), s.readPixels(0, 0, l, c, d == 3 ? s.RGB : s.RGBA, f, h), s.bindFramebuffer(s.FRAMEBUFFER, o), s.viewport(a[0], a[1], a[2], a[3]), h;
  }
  /**
  * uploads some pixels to the texture (see uploadData method for more options)
  * @method setPixels
  * @param {ArrayBuffer} data gl.UNSIGNED_BYTE or gl.FLOAT data
  * @param {Boolean} no_flip do not flip in Y 
  * @param {Boolean} skip_mipmaps do not update mipmaps when possible
  * @param {Number} cubemap_face if the texture is a cubemap, which face
  */
  setPixels(t, r, s, a) {
    var o = { no_flip: r };
    a && (o.cubemap_face = a), this.uploadData(t, o, s);
  }
  /**
  * returns an array with six arrays containing the pixels of every cubemap face
  * @method getCubemapPixels
  * @return {Array} the array that has 6 typed arrays containing the pixels 
  */
  getCubemapPixels() {
    if (this.texture_type !== gl.TEXTURE_CUBE_MAP)
      throw "this texture is not a cubemap";
    return [this.getPixels(0), this.getPixels(1), this.getPixels(2), this.getPixels(3), this.getPixels(4), this.getPixels(5)];
  }
  /**
  * fills a cubemap given an array with typed arrays containing the pixels of 6 faces
  * @method setCubemapPixels
  * @param {Array} data array that has 6 typed arrays containing the pixels 
  * @param {bool} noflip if pixels should not be flipped according to Y
  */
  setCubemapPixels(t, r) {
    if (this.texture_type !== gl.TEXTURE_CUBE_MAP)
      throw "this texture is not a cubemap, it should be created with { texture_type: gl.TEXTURE_CUBE_MAP }";
    for (var s = 0; s < 6; ++s)
      this.setPixels(t[s], r, s != 5, s);
  }
  /**
  * Copy texture content to a canvas
  * @method toCanvas
  * @param {Canvas} canvas must have the same size, if different the canvas will be resized
  * @param {boolean} flip_y optional, flip vertically
  * @param {Number} max_size optional, if it is supplied the canvas wont be bigger of max_size (the image will be scaled down)
  */
  toCanvas(t, r, s) {
    s = s || 8192;
    var a = this.gl, o = Math.min(this.width, s), u = Math.min(this.height, s);
    this.texture_type == a.TEXTURE_CUBE_MAP && (o = o * 4, u = u * 3), t = t || GL$1.createCanvas(o, u), t.width != o && (t.width = o), t.height != u && (t.height = u);
    var h = null;
    if (this.texture_type == a.TEXTURE_2D) {
      if (this.width != o || this.height != u || this.type != a.UNSIGNED_BYTE) {
        var l = new GL$1.Texture(o, u, { format: a.RGBA, filter: a.NEAREST });
        this.copyTo(l), h = l.getPixels();
      } else
        h = this.getPixels();
      var c = t.getContext("2d"), d = c.getImageData(0, 0, o, u);
      if (d.data.set(h), c.putImageData(d, 0, 0), r) {
        var l = GL$1.createCanvas(o, u), f = l.getContext("2d");
        f.translate(0, l.height), f.scale(1, -1), f.drawImage(t, 0, 0, l.width, l.height), c.clearRect(0, 0, c.canvas.width, c.canvas.height), c.drawImage(l, 0, 0);
      }
    } else if (this.texture_type == a.TEXTURE_CUBE_MAP) {
      var _ = GL$1.createCanvas(this.width, this.height), f = _.getContext("2d"), E = GL$1.Texture.generateCubemapCrossFacesInfo(t.width, 1), c = t.getContext("2d");
      c.fillStyle = "black", c.fillRect(0, 0, t.width, t.height);
      var m = this;
      this.type != a.UNSIGNED_BYTE && (m = new GL$1.Texture(this.width, this.height, { format: a.RGBA, texture_type: a.TEXTURE_CUBE_MAP, filter: a.NEAREST, type: a.UNSIGNED_BYTE }), this.copyTo(m));
      for (var T = 0; T < 6; T++) {
        var d = f.getImageData(0, 0, _.width, _.height);
        h = m.getPixels(T), d.data.set(h), f.putImageData(d, 0, 0), c.drawImage(_, E[T].x, E[T].y, _.width, _.height);
      }
    }
    return t;
  }
  toBinary(t, r) {
    for (var s = this.toCanvas(null, t), a = s.toDataURL(r), o = a.indexOf(","), u = a.substr(o + 1), h = atob(u), l = h.length, c = new Uint8Array(l), d = 0; d < l; ++d)
      c[d] = h.charCodeAt(d);
    return c;
  }
  /**
  * returns a Blob containing all the data from the texture
  * @method toBlob
  * @return {Blob} the blob containing the data
  */
  toBlob(t, r) {
    var s = this.toBinary(t), a = new Blob([s], { type: r || "image/png" });
    return a;
  }
  //faster depending on the browser
  toBlobAsync(t, r, s) {
    var a = this.toCanvas(null, t);
    if (a.toBlob) {
      a.toBlob(s, r);
      return;
    }
    var o = this.toBlob(t, r);
    s && s(o);
  }
  /**
  * returns a base64 String containing all the data from the texture
  * @method toBase64
  * @param {boolean} flip_y if you want to flip vertically the image, WebGL saves the images upside down
  * @return {String} the data in base64 format
  */
  toBase64(t) {
    var r = this.width, s = this.height, a = this.getPixels(), o = GL$1.createCanvas(r, s), u = o.getContext("2d"), h = u.getImageData(0, 0, r, s);
    if (h.data.set(a), u.putImageData(h, 0, 0), t) {
      var l = GL$1.createCanvas(r, s), c = l.getContext("2d");
      c.translate(0, s), c.scale(1, -1), c.drawImage(o, 0, 0), o = l;
    }
    var d = o.toDataURL("image/png");
    return d;
  }
  /**
  * generates some basic metadata about the image
  * @method generateMetadata
  * @return {Object}
  */
  generateMetadata() {
    var t = {};
    t.width = this.width, t.height = this.height, this.metadata = t;
  }
  static compareFormats(t, r) {
    return !t || !r ? !1 : t == r ? !0 : !(t.width != r.width || t.height != r.height || t.type != r.type || //gl.UNSIGNED_BYTE
    t.format != r.format || //gl.RGB
    t.texture_type != r.texture_type);
  }
  /**
  * blends texture A and B and stores the result in OUT
  * @method blend
  * @param {Texture} a
  * @param {Texture} b
  * @param {Texture} out [optional]
  * @return {Object}
  */
  static blend(t, r, s, a) {
    if (!t || !r)
      return !1;
    if (t == r)
      return a ? t.copyTo(a) : t.toViewport(), !0;
    gl.disable(gl.BLEND), gl.disable(gl.DEPTH_TEST), gl.disable(gl.CULL_FACE);
    var o = GL$1.Shader.getBlendShader(), u = GL$1.Mesh.getScreenQuad();
    return r.bind(1), o.uniforms({ u_texture: 0, u_texture2: 1, u_factor: s }), a ? (a.drawTo(function() {
      if (t == a || r == a)
        throw "Blend output cannot be the same as the input";
      t.bind(0), o.draw(u, gl.TRIANGLES);
    }), !0) : (t.bind(0), o.draw(u, gl.TRIANGLES), !0);
  }
  static cubemapToTexture2D(t, r, s, a, o) {
    if (!t || t.texture_type != gl.TEXTURE_CUBE_MAP)
      throw "No cubemap in convert";
    r = r || t.width;
    var u = a ? t.type : gl.UNSIGNED_BYTE;
    o = o || 0, s || (s = new GL$1.Texture(r * 2, r, { minFilter: gl.NEAREST, type: u }));
    var h = gl.shaders.cubemap_to_texture2D;
    return h || (h = gl.shaders.cubemap_to_texture2D = new GL$1.Shader(GL$1.Shader.SCREEN_VERTEX_SHADER, `			precision mediump float;
			#define PI 3.14159265358979323846264
			uniform samplerCube texture;			varying vec2 v_coord;			uniform float u_yaw;
			void main() {				float alpha = ((1.0 - v_coord.x) * 2.0) * PI + u_yaw;				float beta = (v_coord.y * 2.0 - 1.0) * PI * 0.5;				vec3 N = vec3( -cos(alpha) * cos(beta), sin(beta), sin(alpha) * cos(beta) );				gl_FragColor = textureCube(texture,N);			}`)), h.setUniform("u_yaw", o), s.drawTo(function() {
      gl.disable(gl.DEPTH_TEST), gl.disable(gl.CULL_FACE), gl.disable(gl.BLEND), t.toViewport(h);
    }), s;
  }
  /**
  * returns a white texture of 1x1 pixel 
  * @method Texture.getWhiteTexture
  * @return {Texture} the white texture
  */
  static getWhiteTexture(t) {
    t = t || global$1.gl;
    var r = t.textures[":white"];
    if (r)
      return r;
    var s = new Uint8Array([255, 255, 255, 255]);
    return t.textures[":white"] = new GL$1.Texture(1, 1, { pixel_data: s });
  }
  /**
  * returns a black texture of 1x1 pixel 
  * @method Texture.getBlackTexture
  * @return {Texture} the black texture
  */
  static getBlackTexture(t) {
    t = t || global$1.gl;
    var r = t.textures[":black"];
    if (r)
      return r;
    var s = new Uint8Array([0, 0, 0, 255]);
    return t.textures[":black"] = new GL$1.Texture(1, 1, { pixel_data: s });
  }
  /**
  * Returns a texture from the texture pool, if none matches the specifications it creates one
  * @method Texture.getTemporary
  * @param {Number} width the texture width
  * @param {Number} height the texture height
  * @param {Object|Texture} options to specifiy texture_type,type,format, it can be an object or another texture
  * @param {WebGLContext} gl [optional]
  * @return {Texture} the textures that matches this settings
  */
  static getTemporary(t, r, s, a) {
    a = a || global$1.gl, a._texture_pool || (a._texture_pool = []);
    var o = GL$1.TEXTURE_2D, u = et.DEFAULT_TYPE, h = et.DEFAULT_FORMAT;
    s && (s.texture_type && (o = s.texture_type), s.type && (u = s.type), s.format && (h = s.format));
    for (var l = o + ":" + u + ":" + t + "x" + r + ":" + h, c = a._texture_pool, d = 0; d < c.length; ++d) {
      var f = c[d];
      if (f._key == l)
        return c.splice(d, 1), f._pool = 0, f;
    }
    var f = new GL$1.Texture(t, r, { type: u, texture_type: o, format: h });
    return f._key = l, f._pool = 0, f;
  }
  /**
  * Given a texture it adds it to the texture pool so it can be reused in the future
  * @method Texture.releaseTemporary
  * @param {GL.Texture} tex
  * @param {WebGLContext} gl [optional]
  */
  static releaseTemporary(t, r) {
    r = r || global$1.gl, r._texture_pool || (r._texture_pool = []), t._pool > 0 && console.warn("this texture is already in the textures pool");
    var s = r._texture_pool;
    if (s || (s = r._texture_pool = []), t._pool = getTime(), s.push(t), s.length > 20) {
      s.sort(function(o, u) {
        return u._pool - o._pool;
      });
      var t = s.pop();
      t._pool = 0, t.delete();
    }
  }
  //returns the next power of two bigger than size
  static nextPOT(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.log(2)));
  }
};
g(et, "DEFAULT_TYPE", GL$1.UNSIGNED_BYTE), g(et, "DEFAULT_FORMAT", GL$1.RGBA), g(et, "DEFAULT_MAG_FILTER", GL$1.LINEAR), g(et, "DEFAULT_MIN_FILTER", GL$1.LINEAR), g(et, "DEFAULT_WRAP_S", GL$1.CLAMP_TO_EDGE), g(et, "DEFAULT_WRAP_T", GL$1.CLAMP_TO_EDGE), g(et, "EXTENSION", "png"), //used when saving it to file
//used for render to FBOs
g(et, "framebuffer", null), g(et, "renderbuffer", null), g(et, "loading_color", new Uint8Array([0, 0, 0, 0])), g(et, "use_renderbuffer_pool", !0), g(et, "cubemap_camera_parameters", [
  { type: "posX", dir: vec3.fromValues(1, 0, 0), up: vec3.fromValues(0, 1, 0), right: vec3.fromValues(0, 0, -1) },
  { type: "negX", dir: vec3.fromValues(-1, 0, 0), up: vec3.fromValues(0, 1, 0), right: vec3.fromValues(0, 0, 1) },
  { type: "posY", dir: vec3.fromValues(0, 1, 0), up: vec3.fromValues(0, 0, -1), right: vec3.fromValues(1, 0, 0) },
  { type: "negY", dir: vec3.fromValues(0, -1, 0), up: vec3.fromValues(0, 0, 1), right: vec3.fromValues(1, 0, 0) },
  { type: "posZ", dir: vec3.fromValues(0, 0, 1), up: vec3.fromValues(0, 1, 0), right: vec3.fromValues(1, 0, 0) },
  { type: "negZ", dir: vec3.fromValues(0, 0, -1), up: vec3.fromValues(0, 1, 0), right: vec3.fromValues(-1, 0, 0) }
]), /**
* returns the texture file in binary format 
* @method toBinary
* @param {Boolean} flip_y
* @return {ArrayBuffer} the arraybuffer of the file containing the image
*/
g(et, "binary_extension", "png");
let Texture = et;
Texture.prototype.blit = (function() {
  var n = new Float32Array(4);
  return function(t, r, s) {
    var a = this.gl;
    if (this.texture_type != a.TEXTURE_2D || this.format === a.DEPTH_COMPONENT || this.format === a.DEPTH_STENCIL)
      throw "blit only support TEXTURE_2D of RGB or RGBA. use copyTo instead";
    var o = a.getParameter(a.FRAMEBUFFER_BINDING);
    n.set(a.viewport_data), r = r || GL$1.Shader.getScreenShader(), r && s && r.uniforms(s);
    var u = a.__copy_fbo;
    return u || (u = a.__copy_fbo = a.createFramebuffer()), a.bindFramebuffer(a.FRAMEBUFFER, u), a.viewport(0, 0, t.width, t.height), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, t.handler, 0), this.bind(0), r.draw(GL$1.Mesh.getScreenQuad(), a.TRIANGLES), a.setViewport(n), a.bindFramebuffer(a.FRAMEBUFFER, o), t.data = null, a.bindTexture(t.texture_type, null), this;
  };
})();
Texture.prototype.renderQuad = (function() {
  var n = mat3.create(), t = vec2.create(), r = vec2.create(), s = vec4.fromValues(1, 1, 1, 1);
  return (function(a, o, u, h, l, c) {
    t[0] = a, t[1] = o, r[0] = u, r[1] = h, l = l || Shader.getQuadShader(this.gl);
    var d = Mesh$1.getScreenQuad(this.gl);
    this.bind(0), l.uniforms({ u_texture: 0, u_position: t, u_color: s, u_size: r, u_viewport: gl.viewport_data.subarray(2, 4), u_transform: n }), c && l.uniforms(c), l.draw(d, gl.TRIANGLES);
  });
})();
const Ot = class Ot {
  constructor(t, r, s, a) {
    if (a = a || global$1.gl, this.gl = a, this._context_id = a.context_id, t && t.constructor !== Array)
      throw "FBO textures must be an Array";
    this.handler = null, this.width = -1, this.height = -1, this.color_textures = [], this.depth_texture = null, this.stencil = !!s, this._stencil_enabled = !1, this._num_binded_textures = 0, (t && t.length || r) && this.setTextures(t, r), this._old_fbo_handler = null, this._old_viewport = new Float32Array(4), this.order = null;
  }
  /**
  * Changes the textures binded to this FBO
  * @method setTextures
  * @param {Array} color_textures an array containing the color textures, if not supplied a render buffer will be used
  * @param {GL.Texture} depth_texture the depth texture, if not supplied a render buffer will be used
  * @param {Boolean} skip_disable it doenst try to go back to the previous FBO enabled in case there was one
  */
  setTextures(t, r, s) {
    if (r && r.constructor === GL$1.Texture) {
      if (r.format !== GL$1.DEPTH_COMPONENT && r.format !== GL$1.DEPTH_STENCIL && r.format !== GL$1.DEPTH_COMPONENT16 && r.format !== GL$1.DEPTH_COMPONENT24 && r.format !== GL$1.DEPTH_COMPONENT32F)
        throw "FBO Depth texture must be of format: gl.DEPTH_COMPONENT, gl.DEPTH_STENCIL or gl.DEPTH_COMPONENT16/24/32F (only in webgl2)";
      if (r.type != GL$1.UNSIGNED_SHORT && r.type != GL$1.UNSIGNED_INT && r.type != GL$1.UNSIGNED_INT_24_8_WEBGL && r.type != GL$1.FLOAT)
        throw "FBO Depth texture must be of type: gl.UNSIGNED_SHORT, gl.UNSIGNED_INT, gl.UNSIGNED_INT_24_8_WEBGL";
    }
    var a = this.depth_texture == r;
    if (a && t) {
      if (t.constructor !== Array)
        throw "FBO: color_textures parameter must be an array containing all the textures to be binded in the color";
      if (t.length == this.color_textures.length) {
        for (var o = 0; o < t.length; ++o)
          if (t[o] != this.color_textures[o]) {
            a = !1;
            break;
          }
      } else
        a = !1;
    }
    if (this._stencil_enabled !== this.stencil && (a = !1), !a) {
      if (this.color_textures.length = t ? t.length : 0, t)
        for (var o = 0; o < t.length; ++o)
          this.color_textures[o] = t[o];
      this.depth_texture = r, this.update(s);
    }
  }
  /**
  * Updates the FBO with the new set of textures and buffers
  * @method update
  * @param {Boolean} skip_disable it doenst try to go back to the previous FBO enabled in case there was one
  */
  update(t) {
    this._old_fbo_handler = gl.getParameter(gl.FRAMEBUFFER_BINDING), this.handler || (this.handler = gl.createFramebuffer());
    var r = -1, s = -1, a = null, o = this.color_textures, u = this.depth_texture;
    if (o && o.length)
      for (var h = 0; h < o.length; h++) {
        var l = o[h];
        if (l.constructor !== GL$1.Texture)
          throw "FBO can only bind instances of GL.Texture";
        if (r == -1)
          r = l.width;
        else if (r != l.width)
          throw "Cannot bind textures with different dimensions";
        if (s == -1)
          s = l.height;
        else if (s != l.height)
          throw "Cannot bind textures with different dimensions";
        if (a == null)
          a = l.type;
        else if (a != l.type)
          throw "Cannot bind textures to a FBO with different pixel formats";
        if (l.texture_type != gl.TEXTURE_2D)
          throw "Cannot bind a Cubemap to a FBO";
      }
    else
      r = u.width, s = u.height;
    this.width = r, this.height = s, gl.bindFramebuffer(gl.FRAMEBUFFER, this.handler);
    var c = gl.extensions.WEBGL_draw_buffers;
    if (gl.webgl_version == 1 && !c && o && o.length > 1)
      throw "Rendering to several textures not supported by your browser";
    var d = gl.webgl_version == 1 ? gl.FRAMEBUFFER : gl.DRAW_FRAMEBUFFER;
    if (gl.framebufferRenderbuffer(d, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null), gl.framebufferRenderbuffer(d, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null), u && u.constructor === GL$1.Texture) {
      if (gl.webgl_version == 1 && !gl.extensions.WEBGL_depth_texture)
        throw "Rendering to depth texture not supported by your browser";
      this.stencil && u.format !== gl.DEPTH_STENCIL && console.warn("Stencil cannot be enabled if there is a depth texture with a DEPTH_STENCIL format"), u.format == gl.DEPTH_STENCIL ? gl.framebufferTexture2D(d, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, u.handler, 0) : gl.framebufferTexture2D(d, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, u.handler, 0);
    } else {
      var f = null;
      u && u.constructor === WebGLRenderbuffer && u.width == r && u.height == s ? f = this._depth_renderbuffer = u : (f = this._depth_renderbuffer = this._depth_renderbuffer || gl.createRenderbuffer(), f.width = r, f.height = s), gl.bindRenderbuffer(gl.RENDERBUFFER, f), this.stencil ? (gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, r, s), gl.framebufferRenderbuffer(d, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, f)) : (gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, r, s), gl.framebufferRenderbuffer(d, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f));
    }
    if (o && o.length) {
      this.order = [];
      for (var h = 0; h < o.length; h++) {
        var l = o[h];
        gl.framebufferTexture2D(d, gl.COLOR_ATTACHMENT0 + h, gl.TEXTURE_2D, l.handler, 0), this.order.push(gl.COLOR_ATTACHMENT0 + h);
      }
    } else {
      var _ = this._color_renderbuffer = this._color_renderbuffer || gl.createRenderbuffer();
      _.width = r, _.height = s, gl.bindRenderbuffer(gl.RENDERBUFFER, _), gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, r, s), gl.framebufferRenderbuffer(d, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, _);
    }
    for (var E = o ? o.length : 0, h = E; h < this._num_binded_textures; ++h)
      gl.framebufferTexture2D(d, gl.COLOR_ATTACHMENT0 + h, gl.TEXTURE_2D, null, 0);
    this._num_binded_textures = E, this._stencil_enabled = this.stencil, o && o.length > 1 && (c ? c.drawBuffersWEBGL(this.order) : gl.drawBuffers(this.order));
    var m = gl.checkFramebufferStatus(d);
    if (m !== gl.FRAMEBUFFER_COMPLETE)
      throw "FBO not complete: " + m;
    gl.bindTexture(gl.TEXTURE_2D, null), gl.bindRenderbuffer(gl.RENDERBUFFER, null), t || gl.bindFramebuffer(d, this._old_fbo_handler);
  }
  /**
  * Enables this FBO (from now on all the render will be stored in the textures attached to this FBO)
  * It stores the previous viewport to restore it afterwards, and changes it to full FBO size
  * @method bind
  * @param {boolean} keep_old keeps the previous FBO is one was attached to restore it afterwards
  */
  bind(t) {
    if (!this.color_textures.length && !this.depth_texture)
      throw "FBO: no textures attached to FBO";
    this._old_viewport.set(gl.viewport_data), t ? this._old_fbo_handler = gl.getParameter(gl.FRAMEBUFFER_BINDING) : this._old_fbo_handler = null, this._old_fbo_handler != this.handler && gl.bindFramebuffer(gl.FRAMEBUFFER, this.handler);
    for (var r = 0; r < this.color_textures.length; ++r)
      this.color_textures[r]._in_current_fbo = !0;
    this.depth_texture && (this.depth_texture._in_current_fbo = !0), gl.viewport(0, 0, this.width, this.height), Ot.current = this;
  }
  /**
  * Disables this FBO, if it was binded with keep_old then the old FBO is enabled, otherwise it will render to the screen
  * Restores viewport to previous
  * @method unbind
  */
  unbind() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._old_fbo_handler), this._old_fbo_handler = null, gl.setViewport(this._old_viewport);
    for (var t = 0; t < this.color_textures.length; ++t)
      this.color_textures[t]._in_current_fbo = !1;
    this.depth_texture && (this.depth_texture._in_current_fbo = !1), Ot.current = null;
  }
  //binds another FBO without switch back to previous (faster)
  switchTo(t) {
    t._old_fbo_handler = this._old_fbo_handler, t._old_viewport.set(this._old_viewport), gl.bindFramebuffer(gl.FRAMEBUFFER, t.handler), this._old_fbo_handler = null, gl.viewport(0, 0, this.width, this.height);
    for (var r = 0; r < this.color_textures.length; ++r)
      this.color_textures[r]._in_current_fbo = !1;
    this.depth_texture && (this.depth_texture._in_current_fbo = !1);
    for (var r = 0; r < t.color_textures.length; ++r)
      t.color_textures[r]._in_current_fbo = !0;
    t.depth_texture && (t.depth_texture._in_current_fbo = !0), Ot.current = t;
  }
  delete() {
    gl.deleteFramebuffer(this.handler), this.handler = null;
  }
  //type: gl.FLOAT, format: gl.RGBA
  static testSupport(t, r) {
    var s = t + ":" + r;
    if (Ot.supported[s] != null)
      return Ot.supported[s];
    var a = new GL$1.Texture(1, 1, { format: r, type: t });
    try {
      var o = new GL$1.FBO([a]);
    } catch {
      return console.warn("This browser WEBGL implementation doesn't support this FBO format: " + GL$1.reverse[t] + " " + GL$1.reverse[r]), Ot.supported[s] = !1;
    }
    return Ot.supported[s] = !0, !0;
  }
  toSingle() {
    if (!(this.color_textures.length < 2)) {
      var t = gl.extensions.WEBGL_draw_buffers;
      t ? t.drawBuffersWEBGL([this.order[0]]) : gl.drawBuffers([this.order[0]]);
    }
  }
  toMulti() {
    if (!(this.color_textures.length < 2)) {
      var t = gl.extensions.WEBGL_draw_buffers;
      t ? t.drawBuffersWEBGL(this.order) : gl.drawBuffers(this.order);
    }
  }
  //clears only the secondary buffers (not the main one)
  clearSecondary(t) {
    if (!(!this.order || this.order.length < 2)) {
      for (var r = gl.extensions.WEBGL_draw_buffers, s = [gl.NONE], a = 1; a < this.order.length; ++a)
        s.push(this.order[a]);
      r ? r.drawBuffersWEBGL(s) : gl.drawBuffers(s), gl.clearColor(t[0], t[1], t[2], t[3]), gl.clear(gl.COLOR_BUFFER_BIT), r ? r.drawBuffersWEBGL(this.order) : gl.drawBuffers(this.order);
    }
  }
};
//WebGL 1.0 support for certaing FBOs is not very clear and can crash sometimes
g(Ot, "supported", {});
let FBO = Ot;
GL$1.FBO = FBO;
const Y = class Y {
  constructor(t, r, s) {
    if (GL$1.debug && console.log("GL.Shader created"), !t || !r)
      throw "GL.Shader source code parameter missing";
    this._context_id = global$1.gl.context_id;
    var a = this.gl = global$1.gl, o = Y.expandMacros(s), u = t.constructor === String ? Y.injectCode(o, t, a) : t, h = r.constructor === String ? Y.injectCode(o, r, a) : r;
    this.program = a.createProgram();
    var l = t.constructor === String ? GL$1.Shader.compileSource(a.VERTEX_SHADER, u) : t, c = r.constructor === String ? GL$1.Shader.compileSource(a.FRAGMENT_SHADER, h) : r;
    if (a.attachShader(this.program, l, a), a.attachShader(this.program, c, a), a.linkProgram(this.program), !a.getProgramParameter(this.program, a.LINK_STATUS))
      throw "link error: " + a.getProgramInfoLog(this.program);
    this.vs_shader = l, this.fs_shader = c, this.attributes = {}, this.uniformInfo = {}, this.samplers = {}, this.extractShaderInfo();
  }
  static expandMacros(t) {
    var r = "";
    if (t)
      for (var s in t)
        r += "#define " + s + " " + (t[s] ? t[s] : "") + `
`;
    return r;
  }
  //this is done to avoid problems with the #version which must be in the first line
  injectCode(t, r, s) {
    var a = r.indexOf(`
`), o = s ? "#define WEBGL" + s.webgl_version + `
` : "", u = r.substr(0, a).trim();
    return u.indexOf("#version") == -1 ? o + t + r : u + `
` + o + t + r.substr(a);
  }
  /**
  * Compiles one single shader source (could be gl.VERTEX_SHADER or gl.FRAGMENT_SHADER) and returns the webgl shader handler 
  * Used internaly to compile the vertex and fragment shader.
  * It throws an exception if there is any error in the code
  * @method Shader.compileSource
  * @param {Number} type could be gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
  * @param {String} source the source file to compile
  * @return {WebGLShader} the handler from webgl
  */
  compileSource(t, r, s, a) {
    if (s = s || global$1.gl, a = a || s.createShader(t), s.shaderSource(a, r), s.compileShader(a), !s.getShaderParameter(a, s.COMPILE_STATUS))
      throw (t == s.VERTEX_SHADER ? "Vertex" : "Fragment") + " shader compile error: " + s.getShaderInfoLog(a);
    return a;
  }
  static parseError(t, r, s) {
    if (!t)
      return null;
    var a = t.split(" "), o = a[5].split(":");
    return {
      type: a[0],
      line_number: parseInt(o[1]),
      line_pos: parseInt(o[0]),
      line_code: (a[0] == "Fragment" ? s : r).split(`
`)[parseInt(o[1])],
      err: t
    };
  }
  /**
  * It updates the code inside one shader
  * @method updateShader
  * @param {String} vertexSource 
  * @param {String} fragmentSource 
  * @param {Object} macros [optional]
  */
  updateShader(t, r, s) {
    var a = this.gl || global$1.gl, o = Y.expandMacros(s);
    this.program ? (a.detachShader(this.program, this.vs_shader), a.detachShader(this.program, this.fs_shader)) : this.program = a.createProgram();
    var o = Y.expandMacros(s), u = t.constructor === String ? Y.injectCode(o, t, a) : t, h = r.constructor === String ? Y.injectCode(o, r, a) : r, l = t.constructor === String ? GL$1.Shader.compileSource(a.VERTEX_SHADER, u) : t, c = r.constructor === String ? GL$1.Shader.compileSource(a.FRAGMENT_SHADER, h) : r;
    if (a.attachShader(this.program, l, a), a.attachShader(this.program, c, a), a.linkProgram(this.program), !a.getProgramParameter(this.program, a.LINK_STATUS))
      throw "link error: " + a.getProgramInfoLog(this.program);
    this.vs_shader = l, this.fs_shader = c, this.attributes = {}, this.uniformInfo = {}, this.samplers = {}, this.extractShaderInfo();
  }
  /**
  * It extract all the info about the compiled shader program, all the info about uniforms and attributes.
  * This info is stored so it works faster during rendering.
  * @method extractShaderInfo
  */
  extractShaderInfo() {
    for (var t = this.gl, r = t.getProgramParameter(this.program, t.ACTIVE_UNIFORMS), s = 0; s < r; ++s) {
      var a = t.getActiveUniform(this.program, s);
      if (!a) break;
      var o = a.name, u = o.indexOf("[");
      if (u != -1) {
        var h = o.indexOf("].");
        h == -1 && (o = o.substr(0, u));
      }
      (a.type == t.SAMPLER_2D || a.type == t.SAMPLER_CUBE || a.type == GL$1.SAMPLER_3D) && (this.samplers[o] = a.type);
      var l = Y.getUniformFunc(a), c = !1;
      (a.type == t.FLOAT_MAT2 || a.type == t.FLOAT_MAT3 || a.type == t.FLOAT_MAT4) && (c = !0);
      var d = GL$1.TYPE_LENGTH[a.type] || 1;
      this.uniformInfo[o] = {
        type: a.type,
        func: l,
        size: a.size,
        type_length: d,
        is_matrix: c,
        loc: t.getUniformLocation(this.program, o),
        data: new Float32Array(d * a.size)
        //prealloc space to assign uniforms that are not typed
      };
    }
    for (var s = 0, r = t.getProgramParameter(this.program, t.ACTIVE_ATTRIBUTES); s < r; ++s) {
      var a = t.getActiveAttrib(this.program, s);
      if (!a)
        break;
      var l = Y.getUniformFunc(a), d = GL$1.TYPE_LENGTH[a.type] || 1;
      this.uniformInfo[a.name] = {
        type: a.type,
        func: l,
        type_length: d,
        size: a.size,
        loc: null
      }, this.attributes[a.name] = t.getAttribLocation(this.program, a.name);
    }
  }
  /**
  * Returns if this shader has a uniform with the given name
  * @method hasUniform
  * @param {String} name name of the uniform
  * @return {Boolean}
  */
  hasUniform(t) {
    return this.uniformInfo[t];
  }
  /**
  * Returns if this shader has an attribute with the given name
  * @method hasAttribute
  * @param {String} name name of the attribute
  * @return {Boolean}
  */
  hasAttribute(t) {
    return this.attributes[t];
  }
  /**
  * Tells you which function to call when uploading a uniform according to the data type in the shader
  * Used internally from extractShaderInfo to optimize calls 
  * @method Shader.getUniformFunc
  * @param {Object} data info about the uniform
  * @return {Function}
  */
  static getUniformFunc(t) {
    var r = null;
    switch (t.type) {
      case GL$1.FLOAT:
        t.size == 1 ? r = gl.uniform1f : r = gl.uniform1fv;
        break;
      case GL$1.FLOAT_MAT2:
        r = gl.uniformMatrix2fv;
        break;
      case GL$1.FLOAT_MAT3:
        r = gl.uniformMatrix3fv;
        break;
      case GL$1.FLOAT_MAT4:
        r = gl.uniformMatrix4fv;
        break;
      case GL$1.FLOAT_VEC2:
        r = gl.uniform2fv;
        break;
      case GL$1.FLOAT_VEC3:
        r = gl.uniform3fv;
        break;
      case GL$1.FLOAT_VEC4:
        r = gl.uniform4fv;
        break;
      case GL$1.UNSIGNED_INT:
      case GL$1.INT:
        t.size == 1 ? r = gl.uniform1i : r = gl.uniform1iv;
        break;
      case GL$1.INT_VEC2:
        r = gl.uniform2iv;
        break;
      case GL$1.INT_VEC3:
        r = gl.uniform3iv;
        break;
      case GL$1.INT_VEC4:
        r = gl.uniform4iv;
        break;
      case GL$1.SAMPLER_2D:
      case GL$1.SAMPLER_3D:
      case GL$1.SAMPLER_CUBE:
        r = gl.uniform1i;
        break;
      default:
        r = gl.uniform1f;
        break;
    }
    return r;
  }
  /**
  * Create a shader from two urls. While the system is fetching the two urls, the shader contains a dummy shader that renders black.
  * @method Shader.fromURL
  * @param {String} vs_path the url to the vertex shader
  * @param {String} fs_path the url to the fragment shader
  * @param {Function} on_complete [Optional] a callback to call once the shader is ready.
  * @return {Shader}
  */
  static fromURL(t, r, s) {
    var a = `
				precision highp float;
				attribute vec3 a_vertex;
				attribute mat4 u_mvp;
				void main() { 
					gl_Position = u_mvp * vec4(a_vertex,1.0); 
				}
			`, o = `
				precision highp float;
				void main() {
					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
				}
				`, u = new GL$1.Shader(a, o);
    u.ready = !1;
    var h = null, l = null;
    HttpRequest(t, null, function(d) {
      h = d, l && c();
    }), HttpRequest(r, null, function(d) {
      l = d, h && c();
    });
    function c() {
      var d = new GL$1.Shader(h, l);
      for (var f in d)
        u[f] = d[f];
      u.ready = !0;
    }
    return u;
  }
  /**
  * enables the shader (calls useProgram)
  * @method bind
  */
  bind() {
    var t = this.gl;
    t.useProgram(this.program), t._current_shader = this;
  }
  /**
  * Returns the location of a uniform or attribute
  * @method getLocation
  * @param {String} name
  * @return {WebGLUniformLocation} location
  */
  getLocation(t) {
    var r = this.uniformInfo[t];
    return r ? this.uniformInfo[t].loc : null;
  }
  uniforms(t) {
    var r = this.gl;
    r.useProgram(this.program), r._current_shader = this;
    for (var s in t) {
      var a = this.uniformInfo[s];
      a && this._setUniform(s, t[s]);
    }
    return this;
  }
  uniformsArray(t) {
    var r = this.gl;
    r.useProgram(this.program), r._current_shader = this;
    for (var s = 0, a = t.length; s < a; ++s) {
      var o = t[s];
      for (var u in o)
        this._setUniform(u, o[u]);
    }
    return this;
  }
  /**
  * Uploads a uniform to the Shader. You dont need to specify types, they are infered from the shader info. Shader must be binded!
  * @method setUniform
  * @param {string} name
  * @param {*} value
  */
  setUniform(t, r) {
    this.gl._current_shader != this && this.bind();
    var s = this.uniformInfo[t];
    s && s.loc !== null && r != null && (r.constructor === Array && (s.data.set(r), r = s.data), s.is_matrix ? s.func.call(this.gl, s.loc, !1, r) : s.func.call(this.gl, s.loc, r));
  }
  //skips enabling shader
  _setUniform(t, r) {
    var s = this.uniformInfo[t];
    s && s.loc !== null && r != null && (r.constructor === Array && (s.data.set(r), r = s.data), s.is_matrix ? s.func.call(this.gl, s.loc, !1, r) : s.func.call(this.gl, s.loc, r));
  }
  /**
  * Renders a mesh using this shader, remember to use the function uniforms before to enable the shader
  * @method draw
  * @param {Mesh} mesh
  * @param {number} mode could be gl.LINES, gl.POINTS, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN
  * @param {String} index_buffer_name the name of the index buffer, if not provided triangles will be assumed
  */
  draw(t, r, s) {
    s = s === void 0 ? r == gl.LINES ? "lines" : "triangles" : s, this.drawBuffers(
      t.vertexBuffers,
      s ? t.indexBuffers[s] : null,
      arguments.length < 2 ? gl.TRIANGLES : r
    );
  }
  /**
  * Renders a range of a mesh using this shader
  * @method drawRange
  * @param {Mesh} mesh
  * @param {number} mode could be gl.LINES, gl.POINTS, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN
  * @param {number} start first primitive to render
  * @param {number} length number of primitives to render
  * @param {String} index_buffer_name the name of the index buffer, if not provided triangles will be assumed
  */
  drawRange(t, r, s, a, o) {
    o = o === void 0 ? r == gl.LINES ? "lines" : "triangles" : o, this.drawBuffers(
      t.vertexBuffers,
      o ? t.indexBuffers[o] : null,
      r,
      s,
      a
    );
  }
  /**
  * render several buffers with a given index buffer
  * @method drawBuffers
  * @param {Object} vertexBuffers an object containing all the buffers
  * @param {IndexBuffer} indexBuffer
  * @param {number} mode could be gl.LINES, gl.POINTS, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN
  * @param {number} range_start first primitive to render
  * @param {number} range_length number of primitives to render
  */
  drawBuffers(t, r, s, a, o) {
    if (o != 0) {
      var u = this.gl;
      u.useProgram(this.program);
      var h = 0, l = temp_attribs_array;
      l.set(temp_attribs_array_zero);
      for (var c in t) {
        var d = t[c], f = d.attribute || c, _ = this.attributes[f];
        _ == null || !d.buffer || (l[_] = 1, u.bindBuffer(u.ARRAY_BUFFER, d.buffer), u.enableVertexAttribArray(_), u.vertexAttribPointer(_, d.buffer.spacing, d.buffer.gl_type, !1, 0, 0), h = d.buffer.length / d.buffer.spacing);
      }
      var E = 0;
      a > 0 && (E = a), r && (h = r.buffer.length - E), o > 0 && o < h && (h = o);
      var m = r && r.data ? r.data.constructor.BYTES_PER_ELEMENT : 1;
      E *= m;
      for (var f in this.attributes) {
        var _ = this.attributes[f];
        l[_] || u.disableVertexAttribArray(this.attributes[f]);
      }
      return h && (!r || r.buffer) && (r ? (u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, r.buffer), u.drawElements(s, h, r.buffer.gl_type, E), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, null)) : u.drawArrays(s, E, h)), this;
    }
  }
  drawInstanced(t, r, s, a, o, u, h) {
    if (u !== 0) {
      var l = this.gl;
      if (l.webgl_version == 1 && !l.extensions.ANGLE_instanced_arrays)
        throw "instancing not supported";
      l.useProgram(this.program);
      var c = 0, d = temp_attribs_array;
      d.set(temp_attribs_array_zero);
      var f = t.vertexBuffers;
      for (var _ in f) {
        var E = f[_], m = E.attribute || _, T = this.attributes[m];
        T == null || !E.buffer || (d[T] = 1, l.bindBuffer(l.ARRAY_BUFFER, E.buffer), l.enableVertexAttribArray(T), l.vertexAttribPointer(T, E.buffer.spacing, E.buffer.gl_type, !1, 0, 0), c = E.buffer.length / E.buffer.spacing);
      }
      var L = null;
      s && (s.constructor === GL$1.Buffer ? L = s : L = t.getIndexBuffer(s));
      var G = 0;
      o > 0 && (G = o), L && (c = L.buffer.length - G), u > 0 && u < c && (c = u);
      var O = L && L.data ? L.data.constructor.BYTES_PER_ELEMENT : 1;
      G *= O;
      for (var m in this.attributes) {
        var T = this.attributes[m];
        d[T] || l.disableVertexAttribArray(this.attributes[m]);
      }
      var b = l.extensions.ANGLE_instanced_arrays, I = 0, S = 0;
      for (var N in a) {
        var C = a[N];
        I = C.length;
        var D = this.attributes[N];
        if (D == null)
          return;
        var M = 0, P = 0;
        C.constructor === Array ? (M = C[0].constructor === Number ? 1 : C[0].length, P = M * C.length) : (M = this.uniformInfo[N].type_length, P = C.length, I = P / M);
        var A = Y._instancing_arrays[S];
        if ((!A || A.data.length < P) && (A = Y._instancing_arrays[S] = { data: new Float32Array(P), buffer: l.createBuffer() }), A.uniform = N, A.element_size = M, C.constructor === Array)
          for (var R = 0; R < C.length; ++R)
            A.data.set(C[R], R * M);
        else
          A.data.set(C);
        if (l.bindBuffer(l.ARRAY_BUFFER, A.buffer), l.bufferData(l.ARRAY_BUFFER, A.data, l.STREAM_DRAW), M == 16)
          for (var B = 0; B < 4; ++B)
            l.enableVertexAttribArray(D + B), l.vertexAttribPointer(D + B, 4, l.FLOAT, !1, 64, B * 4 * 4), b ? b.vertexAttribDivisorANGLE(D + B, 1) : l.vertexAttribDivisor(D + B, 1);
        else
          l.enableVertexAttribArray(D), l.vertexAttribPointer(D, M, l.FLOAT, !1, M * 4, 0), b ? b.vertexAttribDivisorANGLE(D, 1) : l.vertexAttribDivisor(D, 1);
        S += 1;
      }
      h && (I = h), b ? L ? (l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, L.buffer), b.drawElementsInstancedANGLE(r, c, L.buffer.gl_type, G, I), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, null)) : b.drawArraysInstancedANGLE(r, G, c, I) : L ? (l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, L.buffer), l.drawElementsInstanced(r, c, L.buffer.gl_type, G, I), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, null)) : l.drawArraysInstanced(r, G, c, I);
      for (var X = 0; X < S; ++X) {
        var F = Y._instancing_arrays[X], D = this.attributes[F.uniform], M = F.element_size;
        if (M == 16)
          for (var B = 0; B < 4; ++B)
            l.disableVertexAttribArray(D + B), b ? b.vertexAttribDivisorANGLE(D + B, 0) : l.vertexAttribDivisor(D + B, 0);
        else
          l.enableVertexAttribArray(D), b ? b.vertexAttribDivisorANGLE(D, 0) : l.vertexAttribDivisor(D, 0);
      }
      return this;
    }
  }
  /**
  * Given a source code with the directive #import it expands it inserting the code using Shader.files to fetch for import files.
  * Warning: Imports are evaluated only the first inclusion, the rest are ignored to avoid double inclusion of functions
  *          Also, imports cannot have other imports inside.
  * @method Shader.expandImports
  * @param {String} code the source code
  * @param {Object} files [Optional] object with files to import from (otherwise Shader.files is used)
  * @return {String} the code with the lines #import removed and replaced by the code
  */
  static expandImports(t, r) {
    r = r || Y.files;
    var s = {};
    if (!r)
      throw "Shader.files not initialized, assign files there";
    var a = function(o) {
      var u = o.split('"'), h = u[1];
      if (s[h])
        return "//already imported: " + h + `
`;
      var l = r[h];
      return s[h] = !0, l ? l + `
` : "//import code not found: " + h + `
`;
    };
    return t.replace(/#import\s+\"([a-zA-Z0-9_\.]+)\"\s*\n/g, a);
  }
  static dumpErrorToConsole(t, r, s) {
    console.error(t), t.msg;
    var a = null;
    t.indexOf("Fragment") != -1 ? a = s : a = r;
    var o = a.split(`
`);
    for (var u in o)
      o[u] = u + "| " + o[u];
    console.groupCollapsed("Shader code"), console.log(o.join(`
`)), console.groupEnd();
  }
  // @TODO: Excise
  static convertTo100(t, r) {
  }
  // @TODO: Excise
  static convertTo300(t, r) {
  }
  //helps to check if a variable value is valid to an specific uniform in a shader
  static validateValue(t, r) {
    if (t == null)
      return !1;
    switch (r.type) {
      //used to validate shaders
      case GL$1.INT:
      case GL$1.FLOAT:
      case GL$1.SAMPLER_2D:
      case GL$1.SAMPLER_CUBE:
        return isNumber(t);
      case GL$1.INT_VEC2:
      case GL$1.FLOAT_VEC2:
        return t.length === 2;
      case GL$1.INT_VEC3:
      case GL$1.FLOAT_VEC3:
        return t.length === 3;
      case GL$1.INT_VEC4:
      case GL$1.FLOAT_VEC4:
      case GL$1.FLOAT_MAT2:
        return t.length === 4;
      case GL$1.FLOAT_MAT3:
        return t.length === 8;
      case GL$1.FLOAT_MAT4:
        return t.length === 16;
    }
    return !0;
  }
  //legacy
  /**
  * Allows to create a simple shader meant to be used to process a texture, instead of having to define the generic Vertex & Fragment Shader code
  * @method Shader.createFX
  * @param {string} code string containg code, like "color = color * 2.0;"
  * @param {string} [uniforms=null] string containg extra uniforms, like "uniform vec3 u_pos;"
  */
  static createFX(t, r, s) {
    t = GL$1.Shader.removeComments(t, !0);
    var a = {
      FX_CODE: t,
      FX_UNIFORMS: r || ""
    };
    return s ? (s.updateShader(GL$1.Shader.SCREEN_VERTEX_SHADER, GL$1.Shader.SCREEN_FRAGMENT_FX, a), s) : new GL$1.Shader(GL$1.Shader.SCREEN_VERTEX_SHADER, GL$1.Shader.SCREEN_FRAGMENT_FX, a);
  }
  /**
  * Given a shader code with some vars inside (like {{varname}}) and an object with the variable values, it will replace them.
  * @method Shader.replaceCodeUsingContext
  * @param {string} code string containg code and vars in {{varname}} format
  * @param {object} context object containing all var values
  */
  static replaceCodeUsingContext(t, r) {
    return t.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function(s) {
      return s = s.replace(/[\{\}]/g, ""), r[s] || "";
    });
  }
  static removeComments(a, r) {
    if (!a)
      return "";
    for (var s = /(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(\/\/.*)/g, a = a.replace(s, ""), o = a.split(`
`), u = [], h = 0; h < o.length; ++h) {
      var l = o[h], c = l.indexOf("//");
      c != -1 && (l = o[h].substr(0, c)), l = l.trim(), l.length && u.push(l);
    }
    return u.join(r ? "" : `
`);
  }
  /**
  * Renders a fullscreen quad with this shader applied
  * @method toViewport
  * @param {object} uniforms
  */
  toViewport(t) {
    var r = GL$1.Mesh.getScreenQuad();
    t && this.uniforms(t), this.draw(r);
  }
  //Now some common shaders everybody needs
  /**
  * Returns a shader ready to render a textured quad in fullscreen, use with Mesh.getScreenQuad() mesh
  * shader params: sampler2D u_texture
  * @method Shader.getScreenShader
  */
  static getScreenShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":screen"];
    return r || (r = t.shaders[":screen"] = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, Y.SCREEN_FRAGMENT_SHADER), r.uniforms({ u_texture: 0 }));
  }
  /**
  * Returns a shader ready to render a flat color quad in fullscreen, use with Mesh.getScreenQuad() mesh
  * shader params: vec4 u_color
  * @method Shader.getFlatScreenShader
  */
  static getFlatScreenShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":flat_screen"];
    return r || (r = t.shaders[":flat_screen"] = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, Y.FLAT_FRAGMENT_SHADER), r.uniforms({ u_color: [1, 1, 1, 1] }));
  }
  /**
  * Returns a shader ready to render a colored textured quad in fullscreen, use with Mesh.getScreenQuad() mesh
  * shader params vec4 u_color and sampler2D u_texture
  * @method Shader.getColoredScreenShader
  */
  static getColoredScreenShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":colored_screen"];
    return r || (r = t.shaders[":colored_screen"] = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, Y.SCREEN_COLORED_FRAGMENT_SHADER), r.uniforms({ u_texture: 0, u_color: vec4.fromValues(1, 1, 1, 1) }));
  }
  /**
  * Returns a shader ready to render a quad with transform, use with Mesh.getScreenQuad() mesh
  * shader must have: u_position, u_size, u_viewport, u_transform (mat3)
  * @method Shader.getQuadShader
  */
  static getQuadShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":quad"];
    return r || (t.shaders[":quad"] = new GL$1.Shader(Y.QUAD_VERTEX_SHADER, Y.QUAD_FRAGMENT_SHADER));
  }
  /**
  * Returns a shader ready to render part of a texture into the viewport
  * shader must have: u_position, u_size, u_viewport, u_transform, u_texture_area (vec4)
  * @method Shader.getPartialQuadShader
  */
  static getPartialQuadShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":quad2"];
    return r || (t.shaders[":quad2"] = new GL$1.Shader(Y.QUAD_VERTEX_SHADER, Y.QUAD2_FRAGMENT_SHADER));
  }
  /**
  * Returns a shader that blends two textures
  * shader must have: u_factor, u_texture, u_texture2
  * @method Shader.getBlendShader
  */
  getBlendShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":blend"];
    return r || (t.shaders[":blend"] = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, Y.BLEND_FRAGMENT_SHADER));
  }
  /**
  * Returns a shader used to apply gaussian blur to one texture in one axis (you should use it twice to get a gaussian blur)
  * shader params are: vec2 u_offset, float u_intensity
  * @method Shader.getBlurShader
  */
  getBlurShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":blur"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, `
				precision highp float;
				varying vec2 v_coord;
				uniform sampler2D u_texture;
				uniform vec2 u_offset;
				uniform float u_intensity;
				void main() {
				vec4 sum = vec4(0.0);
				sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;
				sum += texture2D(u_texture, v_coord) * 0.16/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;
				sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;
				gl_FragColor = u_intensity * sum;
				}
				`);
    return t.shaders[":blur"] = r;
  }
  //shader to copy a depth texture into another one
  static getCopyDepthShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":copy_depth"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, `
				#extension GL_EXT_frag_depth : enable
				precision highp float;
				varying vec2 v_coord;
				uniform sampler2D u_texture;
				void main() {
				gl_FragDepthEXT = texture2D( u_texture, v_coord ).x;
				gl_FragColor = vec4(1.0);
				}
				`);
    return t.shaders[":copy_depth"] = r;
  }
  getCubemapShowShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":show_cubemap"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.DEFAULT_VERTEX_SHADER, `
				precision highp float;
				varying vec3 v_normal;
				uniform samplerCube u_texture;
				void main() {
				gl_FragColor = textureCube( u_texture, v_normal );
				}
				`);
    return r.uniforms({ u_texture: 0 }), t.shaders[":show_cubemap"] = r;
  }
  //shader to copy a cubemap into another 
  static getPolarToCubemapShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":polar_to_cubemap"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, `
				precision highp float;
				varying vec2 v_coord;
				uniform sampler2D u_texture;
				uniform mat3 u_rotation;
				void main() {
					vec2 uv = vec2( v_coord.x, 1.0 - v_coord.y );
					vec3 dir = normalize( vec3( uv - vec2(0.5), 0.5 ));
					dir = u_rotation * dir;
					float u = atan(dir.x,dir.z) / 6.28318531;
					float v = (asin(dir.y) / 1.57079633) * 0.5 + 0.5;
					u = mod(u,1.0);
					v = mod(v,1.0);
				gl_FragColor = texture2D( u_texture, vec2(u,v) );
				}
				`);
    return t.shaders[":polar_to_cubemap"] = r;
  }
  //shader to copy a cubemap into another 
  getCubemapCopyShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":copy_cubemap"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, `
				precision highp float;
				varying vec2 v_coord;
				uniform samplerCube u_texture;
				uniform mat3 u_rotation;
				void main() {
					vec2 uv = vec2( v_coord.x, 1.0 - v_coord.y );
					vec3 dir = vec3( uv - vec2(0.5), 0.5 );
					dir = u_rotation * dir;
				gl_FragColor = textureCube( u_texture, dir );
				}
				`);
    return t.shaders[":copy_cubemap"] = r;
  }
  //shader to blur a cubemap
  static getCubemapBlurShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":blur_cubemap"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, `
				#ifndef NUM_SAMPLES
					#define NUM_SAMPLES 4
				#endif
				
				precision highp float;
				varying vec2 v_coord;
				uniform samplerCube u_texture;
				uniform mat3 u_rotation;
				uniform vec2 u_offset;
				uniform float u_intensity;
				void main() {
					vec4 sum = vec4(0.0);
					vec2 uv = vec2( v_coord.x, 1.0 - v_coord.y ) - vec2(0.5);
					vec3 dir = vec3(0.0);
					vec4 color = vec4(0.0);
					for( int x = -2; x <= 2; x++ )
					{
						for( int y = -2; y <= 2; y++ )
						{
							dir.xy = uv + vec2( u_offset.x * float(x), u_offset.y * float(y)) * 0.5;
							dir.z = 0.5;
							dir = u_rotation * dir;
							color = textureCube( u_texture, dir );
							color.xyz = color.xyz * color.xyz;/*linearize*/
							sum += color;
						}
					}
					sum /= 25.0;
				gl_FragColor = vec4( sqrt( sum.xyz ), sum.w ) ;
				}
				`);
    return t.shaders[":blur_cubemap"] = r;
  }
  /**
  * Returns a shader to apply FXAA antialiasing
  * params are vec2 u_viewportSize, vec2 u_iViewportSize or you can call shader.setup()
  * @method Shader.getFXAAShader
  */
  static getFXAAShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":fxaa"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.SCREEN_VERTEX_SHADER, `
				precision highp float;
				varying vec2 v_coord;
				uniform sampler2D u_texture;
				` + Y.FXAA_FUNC + `
				
				void main() {
				gl_FragColor = applyFXAA( u_texture, v_coord * u_viewportSize) ;
				}
				`), s = vec2.fromValues(t.viewport_data[2], t.viewport_data[3]), a = vec2.fromValues(1 / t.viewport_data[2], 1 / t.viewport_data[3]);
    return r.setup = function() {
      s[0] = t.viewport_data[2], s[1] = t.viewport_data[3], a[0] = 1 / t.viewport_data[2], a[1] = 1 / t.viewport_data[3], this.uniforms({ u_viewportSize: s, u_iViewportSize: a });
    }, t.shaders[":fxaa"] = r;
  }
  /**
  * Returns a flat shader (useful to render lines)
  * @method Shader.getFlatShader
  */
  getFlatShader(t) {
    t = t || global$1.gl;
    var r = t.shaders[":flat"];
    if (r)
      return r;
    var r = new GL$1.Shader(Y.FLAT_VERTEX_SHADER, Y.FLAT_FRAGMENT_SHADER);
    return r.uniforms({ u_color: [1, 1, 1, 1] }), t.shaders[":flat"] = r;
  }
};
/**
* Uploads a set of uniforms to the Shader. You dont need to specify types, they are infered from the shader info.
* @method uniforms
* @param {Object} uniforms
*/
g(Y, "_temp_uniform", new Float32Array(16)), g(Y, "_instancing_arrays", []), g(Y, "DEFAULT_VERTEX_SHADER", `
				precision highp float;
				attribute vec3 a_vertex;
				attribute vec3 a_normal;
				attribute vec2 a_coord;
				varying vec3 v_position;
				varying vec3 v_normal;
				varying vec2 v_coord;
				uniform mat4 u_model;
				uniform mat4 u_mvp;
				void main() {
					v_position = (u_model * vec4(a_vertex,1.0)).xyz;
					v_normal = (u_model * vec4(a_normal,0.0)).xyz;
					v_coord = a_coord;
					gl_Position = u_mvp * vec4(a_vertex,1.0);
				}
				`), g(Y, "SCREEN_VERTEX_SHADER", `
				precision highp float;
				attribute vec3 a_vertex;
				attribute vec2 a_coord;
				varying vec2 v_coord;
				void main() { 
					v_coord = a_coord; 
					gl_Position = vec4(a_coord * 2.0 - 1.0, 0.0, 1.0); 
				}
				`), g(Y, "SCREEN_FRAGMENT_SHADER", `
				precision highp float;
				uniform sampler2D u_texture;
				varying vec2 v_coord;
				void main() {
					gl_FragColor = texture2D(u_texture, v_coord);
				}
				`), //used in createFX
g(Y, "SCREEN_FRAGMENT_FX", `
				precision highp float;
				uniform sampler2D u_texture;
				varying vec2 v_coord;
				#ifdef FX_UNIFORMS
					FX_UNIFORMS
				#endif
				void main() {
					vec2 uv = v_coord;
					vec4 color = texture2D(u_texture, uv);
					#ifdef FX_CODE
						FX_CODE ;
					#endif
					gl_FragColor = color;
				}
				`), g(Y, "SCREEN_COLORED_FRAGMENT_SHADER", `
				precision highp float;
				uniform sampler2D u_texture;
				uniform vec4 u_color;
				varying vec2 v_coord;
				void main() {
					gl_FragColor = u_color * texture2D(u_texture, v_coord);
				}
				`), g(Y, "BLEND_FRAGMENT_SHADER", `
				precision highp float;
				uniform sampler2D u_texture;
				uniform sampler2D u_texture2;
				uniform float u_factor;
				varying vec2 v_coord;
				void main() {
					gl_FragColor = mix( texture2D(u_texture, v_coord), texture2D(u_texture2, v_coord), u_factor);
				}
				`), //used to paint quads
g(Y, "QUAD_VERTEX_SHADER", `
				precision highp float;
				attribute vec3 a_vertex;
				attribute vec2 a_coord;
				varying vec2 v_coord;
				uniform vec2 u_position;
				uniform vec2 u_size;
				uniform vec2 u_viewport;
				uniform mat3 u_transform;
				void main() { 
					vec3 pos = vec3(u_position + vec2(a_coord.x,1.0 - a_coord.y)  * u_size, 1.0);
					v_coord = a_coord; 
					pos = u_transform * pos;
					pos.z = 0.0;
					//normalize
					pos.x = (2.0 * pos.x / u_viewport.x) - 1.0;
					pos.y = -((2.0 * pos.y / u_viewport.y) - 1.0);
					gl_Position = vec4(pos, 1.0); 
				}
				`), g(Y, "QUAD_FRAGMENT_SHADER", `
				precision highp float;
				uniform sampler2D u_texture;
				uniform vec4 u_color;
				varying vec2 v_coord;
				void main() {
					gl_FragColor = u_color * texture2D(u_texture, v_coord);
				}
				`), //used to render partially a texture
g(Y, "QUAD2_FRAGMENT_SHADER", `
				precision highp float;
				uniform sampler2D u_texture;
				uniform vec4 u_color;
				uniform vec4 u_texture_area;
				varying vec2 v_coord;
				void main() {
					vec2 uv = vec2( mix(u_texture_area.x, u_texture_area.z, v_coord.x), 1.0 - mix(u_texture_area.w, u_texture_area.y, v_coord.y) );
					gl_FragColor = u_color * texture2D(u_texture, uv);
				}
				`), g(Y, "PRIMITIVE2D_VERTEX_SHADER", `
				precision highp float;
				attribute vec3 a_vertex;
				uniform vec2 u_viewport;
				uniform mat3 u_transform;
				void main() { 
					vec3 pos = a_vertex;
					pos = u_transform * pos;
					pos.z = 0.0;
					//normalize
					pos.x = (2.0 * pos.x / u_viewport.x) - 1.0;
					pos.y = -((2.0 * pos.y / u_viewport.y) - 1.0);
					gl_Position = vec4(pos, 1.0); 
				}
				`), g(Y, "FLAT_VERTEX_SHADER", `
				precision highp float;
				attribute vec3 a_vertex;
				uniform mat4 u_mvp;
				void main() { 
					gl_Position = u_mvp * vec4(a_vertex,1.0); 
				}
				`), g(Y, "FLAT_FRAGMENT_SHADER", `
				precision highp float;
				uniform vec4 u_color;
				void main() {
					gl_FragColor = u_color;
				}
				`), g(Y, "SCREEN_FLAT_FRAGMENT_SHADER", Y.FLAT_FRAGMENT_SHADER), //shader to do FXAA (antialiasing)
g(Y, "FXAA_FUNC", `
		uniform vec2 u_viewportSize;
		uniform vec2 u_iViewportSize;
		#define FXAA_REDUCE_MIN   (1.0/ 128.0)
		#define FXAA_REDUCE_MUL   (1.0 / 8.0)
		#define FXAA_SPAN_MAX     8.0
		
		/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */
		vec4 applyFXAA(sampler2D tex, vec2 fragCoord)
		{
			vec4 color = vec4(0.0);
			/*vec2 u_iViewportSize = vec2(1.0 / u_viewportSize.x, 1.0 / u_viewportSize.y);*/
			vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * u_iViewportSize).xyz;
			vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * u_iViewportSize).xyz;
			vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * u_iViewportSize).xyz;
			vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * u_iViewportSize).xyz;
			vec3 rgbM  = texture2D(tex, fragCoord  * u_iViewportSize).xyz;
			vec3 luma = vec3(0.299, 0.587, 0.114);
			float lumaNW = dot(rgbNW, luma);
			float lumaNE = dot(rgbNE, luma);
			float lumaSW = dot(rgbSW, luma);
			float lumaSE = dot(rgbSE, luma);
			float lumaM  = dot(rgbM,  luma);
			float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
			float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
			
			vec2 dir;
			dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
			dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
			
			float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
			
			float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
			dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * u_iViewportSize;
			
			vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * u_iViewportSize + dir * (1.0 / 3.0 - 0.5)).xyz + 
				texture2D(tex, fragCoord * u_iViewportSize + dir * (2.0 / 3.0 - 0.5)).xyz);
			vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * u_iViewportSize + dir * -0.5).xyz + 
				texture2D(tex, fragCoord * u_iViewportSize + dir * 0.5).xyz);
			
			return vec4(rgbA,1.0);
			float lumaB = dot(rgbB, luma);
			if ((lumaB < lumaMin) || (lumaB > lumaMax))
				color = vec4(rgbA, 1.0);
			else
				color = vec4(rgbB, 1.0);
			return color;
		}
	`);
let Shader = Y;
GL$1.Shader = Shader;
var temp_attribs_array = new Uint8Array(16), temp_attribs_array_zero = new Uint8Array(16), LEvent = global$1.LEvent = GL$1.LEvent = {
  /**
  * Binds an event to an instance
  * @method LEvent.bind
  * @param {Object} instance where to attach the event
  * @param {String} event_name string defining the event name
  * @param {function} callback function to call when the event is triggered
  * @param {Object} target_instance [Optional] instance to call the function (use this instead of .bind method to help removing events)
  **/
  bind: function(n, t, r, s) {
    if (!n)
      throw "cannot bind event to null";
    if (!r)
      throw "cannot bind to null callback";
    if (n.constructor === String)
      throw "cannot bind event to a string";
    var a = n.__levents;
    a || (Object.defineProperty(n, "__levents", { value: {}, enumerable: !1 }), a = n.__levents), a.hasOwnProperty(t) ? a[t].push([r, s]) : a[t] = [[r, s]], n.onLEventBinded && n.onLEventBinded(t, r, s);
  },
  /**
  * Unbinds an event from an instance
  * @method LEvent.unbind
  * @param {Object} instance where the event is binded
  * @param {String} event_name string defining the event name
  * @param {function} callback function that was binded
  * @param {Object} target_instance [Optional] target_instance that was binded
  **/
  unbind: function(n, t, r, s) {
    if (!n)
      throw "cannot unbind event to null";
    if (!r)
      throw "cannot unbind from null callback";
    if (n.constructor === String)
      throw "cannot bind event to a string";
    var a = n.__levents;
    if (a && a.hasOwnProperty(t)) {
      for (var o = 0, u = a[t].length; o < u; ++o) {
        var h = a[t][o];
        if (h[0] === r && h[1] === s) {
          a[t].splice(o, 1);
          break;
        }
      }
      a[t].length == 0 && delete a[t], n.onLEventUnbinded && n.onLEventUnbinded(t, r, s);
    }
  },
  /**
  * Unbinds all events from an instance (or the ones that match certain target_instance)
  * @method LEvent.unbindAll
  * @param {Object} instance where the events are binded
  * @param {Object} target_instance [Optional] target_instance of the events to remove
  **/
  unbindAll: function(n, t, r) {
    if (!n)
      throw "cannot unbind events in null";
    var s = n.__levents;
    if (s) {
      if (n.onLEventUnbindAll && n.onLEventUnbindAll(t, r), !t) {
        delete n.__levents;
        return;
      }
      for (var a in s)
        for (var o = s[a], u = o.length - 1; u >= 0; --u)
          o[u][1] != t || r && r !== o[u][0] || o.splice(u, 1);
    }
  },
  /**
  * Unbinds all callbacks associated to one specific event from this instance
  * @method LEvent.unbindAll
  * @param {Object} instance where the events are binded
  * @param {String} event name of the event you want to remove all binds
  **/
  unbindAllEvent: function(n, t) {
    if (!n)
      throw "cannot unbind events in null";
    var r = n.__levents;
    r && (delete r[t], n.onLEventUnbindAll && n.onLEventUnbindAll(t, target_instance, callback));
  },
  /**
  * Tells if there is a binded callback that matches the criteria
  * @method LEvent.isBind
  * @param {Object} instance where the are the events binded
  * @param {String} event_name string defining the event name
  * @param {function} callback the callback
  * @param {Object} target_instance [Optional] instance binded to callback
  **/
  isBind: function(n, t, r, s) {
    if (!n)
      throw "LEvent cannot have null as instance";
    var a = n.__levents;
    if (a) {
      if (!a.hasOwnProperty(t))
        return !1;
      for (var o = 0, u = a[t].length; o < u; ++o) {
        var h = a[t][o];
        if (h[0] === r && h[1] === s)
          return !0;
      }
      return !1;
    }
  },
  /**
  * Tells if there is any callback binded to this event
  * @method LEvent.hasBind
  * @param {Object} instance where the are the events binded
  * @param {String} event_name string defining the event name
  * @return {boolean} true is there is at least one
  **/
  hasBind: function(n, t) {
    if (!n)
      throw "LEvent cannot have null as instance";
    var r = n.__levents;
    return !(!r || !r.hasOwnProperty(t) || !r[t].length);
  },
  /**
  * Tells if there is any callback binded to this object pointing to a method in the target object
  * @method LEvent.hasBindTo
  * @param {Object} instance where there are the events binded
  * @param {Object} target instance to check to
  * @return {boolean} true is there is at least one
  **/
  hasBindTo: function(n, t) {
    if (!n)
      throw "LEvent cannot have null as instance";
    var r = n.__levents;
    if (!r)
      return !1;
    for (var s in r)
      for (var a = r[s], o = 0; o < a.length; ++o)
        if (a[o][1] === t)
          return !0;
    return !1;
  },
  /**
  * Triggers and event in an instance
  * If the callback returns true then it will stop the propagation and return true
  * @method LEvent.trigger
  * @param {Object} instance that triggers the event
  * @param {String} event_name string defining the event name
  * @param {*} parameters that will be received by the binded function
  * @param {bool} reverse_order trigger in reverse order (binded last get called first)
  * @param {bool} expand_parameters parameters are passed not as one single parameter, but as many
  * return {bool} true if the event passed was blocked by any binded callback
  **/
  trigger: function(n, t, r, s, a) {
    if (!n)
      throw "cannot trigger event from null";
    if (n.constructor === String)
      throw "cannot bind event to a string";
    var o = n.__levents;
    if (!o || !o.hasOwnProperty(t))
      return !1;
    var u = o[t];
    if (s)
      for (var h = u.length - 1; h >= 0; --h) {
        var l = u[h];
        if (a) {
          if (l && l[0].apply(l[1], r) === !0)
            return !0;
        } else if (l && l[0].call(l[1], t, r) === !0)
          return !0;
      }
    else
      for (var h = 0, c = u.length; h < c; ++h) {
        var l = u[h];
        if (a) {
          if (l && l[0].apply(l[1], r) === !0)
            return !0;
        } else if (l && l[0].call(l[1], t, r) === !0)
          return !0;
      }
    return !1;
  },
  /**
  * Triggers and event to every element in an array.
  * If the event returns true, it must be intercepted
  * @method LEvent.triggerArray
  * @param {Array} array contains all instances to triggers the event
  * @param {String} event_name string defining the event name
  * @param {*} parameters that will be received by the binded function
  * @param {bool} reverse_order trigger in reverse order (binded last get called first)
  * @param {bool} expand_parameters parameters are passed not as one single parameter, but as many
  * return {bool} false 
  **/
  triggerArray: function(n, t, r, s, a) {
    for (var o = !1, u = 0, h = n.length; u < h; ++u) {
      var l = n[u];
      if (!l)
        throw "cannot trigger event from null";
      if (l.constructor === String)
        throw "cannot bind event to a string";
      var c = l.__levents;
      if (!(!c || !c.hasOwnProperty(t)))
        if (s)
          for (var d = c[t].length - 1; d >= 0; --d) {
            var f = c[t][d];
            if (a) {
              if (f[0].apply(f[1], r) === !0) {
                o = !0;
                break;
              }
            } else if (f[0].call(f[1], t, r) === !0) {
              o = !0;
              break;
            }
          }
        else
          for (var d = 0, _ = c[t].length; d < _; ++d) {
            var f = c[t][d];
            if (a) {
              if (f[0].apply(f[1], r) === !0) {
                o = !0;
                break;
              }
            } else if (f[0].call(f[1], t, r) === !0) {
              o = !0;
              break;
            }
          }
    }
    return o;
  },
  extendObject: function(n) {
    n.bind = function(t, r, s) {
      return LEvent.bind(this, t, r, s);
    }, n.trigger = function(t, r) {
      return LEvent.trigger(this, t, r);
    }, n.unbind = function(t, r, s) {
      return LEvent.unbind(this, t, r, instance);
    }, n.unbindAll = function(t, r) {
      return LEvent.unbindAll(this, t, r);
    };
  },
  /**
  * Adds the methods to bind, trigger and unbind to this class prototype
  * @method LEvent.extendClass
  * @param {Object} constructor
  **/
  extendClass: function(n) {
    this.extendObject(n.prototype);
  }
};
global$1.CLIP_INSIDE = GL$1.CLIP_INSIDE = 0;
global$1.CLIP_OUTSIDE = GL$1.CLIP_OUTSIDE = 1;
global$1.CLIP_OVERLAP = GL$1.CLIP_OVERLAP = 2;
global$1.geo = {
  /**
  * Returns a float4 containing the info about a plane with normal N and that passes through point P
  * @method createPlane
  * @param {vec3} P
  * @param {vec3} N
  * @return {vec4} plane values
  */
  createPlane: function(n, t) {
    return new Float32Array([t[0], t[1], t[2], -vec3.dot(n, t)]);
  },
  /**
  * Computes the distance between the point and the plane
  * @method distancePointToPlane
  * @param {vec3} point
  * @param {vec4} plane
  * @return {Number} distance
  */
  distancePointToPlane: function(n, t) {
    return (vec3.dot(n, t) + t[3]) / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  },
  /**
  * Computes the square distance between the point and the plane
  * @method distance2PointToPlane
  * @param {vec3} point
  * @param {vec4} plane
  * @return {Number} distance*distance
  */
  distance2PointToPlane: function(n, t) {
    return (vec3.dot(n, t) + t[3]) / (t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  },
  /**
  * Projects a 3D point on a 3D line
  * @method projectPointOnLine
  * @param {vec3} P
  * @param {vec3} A line start
  * @param {vec3} B line end
  * @param {vec3} result to store result (optional)
  * @return {vec3} projectec point
  */
  projectPointOnLine: function(n, t, r, s) {
    s = s || vec3.create();
    var a = vec3.fromValues(n[0] - t[0], n[1] - t[1], n[2] - t[2]), o = vec3.fromValues(r[0] - t[0], r[1] - t[1], r[2] - t[2]), u = vec3.dot(a, o) / vec3.dot(o, o);
    return s[0] = t[0] + u[0] * o[0], s[1] = t[1] + u[1] * o[1], s[2] = t[2] + u[2] * o[2], s;
  },
  /**
  * Projects a 2D point on a 2D line
  * @method project2DPointOnLine
  * @param {vec2} P
  * @param {vec2} A line start
  * @param {vec2} B line end
  * @param {vec2} result to store result (optional)
  * @return {vec2} projectec point
  */
  project2DPointOnLine: function(n, t, r, s) {
    s = s || vec2.create();
    var a = vec2.fromValues(n[0] - t[0], n[1] - t[1]), o = vec2.fromValues(r[0] - t[0], r[1] - t[1]), u = vec2.dot(a, o) / vec2.dot(o, o);
    return s[0] = t[0] + u[0] * o[0], s[1] = t[1] + u[1] * o[1], s;
  },
  /**
  * Projects point on plane
  * @method projectPointOnPlane
  * @param {vec3} point
  * @param {vec3} P plane point
  * @param {vec3} N plane normal
  * @param {vec3} result to store result (optional)
  * @return {vec3} projectec point
  */
  projectPointOnPlane: function(n, t, r, s) {
    s = s || vec3.create();
    var a = vec3.subtract(vec3.create(), n, t), o = vec3.dot(a, r);
    return vec3.subtract(s, n, vec3.scale(vec3.create(), r, o));
  },
  /**
  * Finds the reflected point over a plane (useful for reflecting camera position when rendering reflections)
  * @method reflectPointInPlane
  * @param {vec3} point point to reflect
  * @param {vec3} P point where the plane passes
  * @param {vec3} N normal of the plane
  * @return {vec3} reflected point
  */
  reflectPointInPlane: function(n, t, r) {
    var s = -1 * (t[0] * r[0] + t[1] * r[1] + t[2] * r[2]), a = -(s + r[0] * n[0] + r[1] * n[1] + r[2] * n[2]) / (r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
    return vec3.fromValues(n[0] + a * r[0] * 2, n[1] + a * r[1] * 2, n[2] + a * r[2] * 2);
  },
  /**
  * test a ray plane collision and retrieves the collision point
  * @method testRayPlane
  * @param {vec3} start ray start
  * @param {vec3} direction ray direction
  * @param {vec3} P point where the plane passes	
  * @param {vec3} N normal of the plane
  * @param {vec3} result collision position
  * @return {boolean} returns if the ray collides the plane or the ray is parallel to the plane
  */
  testRayPlane: function(n, t, r, s, a) {
    var o = vec3.dot(r, s), u = o - vec3.dot(s, n), h = vec3.dot(s, t);
    if (Math.abs(h) < EPSILON) return !1;
    var l = u / h;
    return l < 0 ? !1 : (a && vec3.add(a, n, vec3.scale(a, t, l)), !0);
  },
  /**
  * test collision between segment and plane and retrieves the collision point
  * @method testSegmentPlane
  * @param {vec3} start segment start
  * @param {vec3} end segment end
  * @param {vec3} P point where the plane passes	
  * @param {vec3} N normal of the plane
  * @param {vec3} result collision position
  * @return {boolean} returns if the segment collides the plane or it is parallel to the plane
  */
  testSegmentPlane: (function() {
    var n = vec3.create();
    return function(t, r, s, a, o) {
      var u = vec3.dot(s, a), h = u - vec3.dot(a, t), l = vec3.sub(n, r, t), c = vec3.dot(a, l);
      if (Math.abs(c) < EPSILON)
        return !1;
      var d = h / c;
      return d < 0 || d > 1 ? !1 : (o && vec3.add(o, t, vec3.scale(o, l, d)), !0);
    };
  })(),
  /**
  * test a ray sphere collision and retrieves the collision point
  * @method testRaySphere
  * @param {vec3} start ray start
  * @param {vec3} direction ray direction (normalized)
  * @param {vec3} center center of the sphere
  * @param {number} radius radius of the sphere
  * @param {vec3} result [optional] collision position
  * @param {number} max_dist not fully tested
  * @return {boolean} returns if the ray collides the sphere
  */
  testRaySphere: (function() {
    var n = vec3.create();
    return function(t, r, s, a, o, u) {
      var h = vec3.subtract(n, t, s), l = r[0] * r[0] + r[1] * r[1] + r[2] * r[2], c = 2 * h[0] * r[0] + 2 * h[1] * r[1] + 2 * h[2] * r[2], d = h[0] * h[0] + h[1] * h[1] + h[2] * h[2] - a * a, f = c * c - 4 * l * d;
      if (f < 0)
        return !1;
      if (o) {
        var _ = Math.sqrt(f), E = 1 / (2 * l), m = (-c + _) * E, T = (-c - _) * E, L = m < T ? m : T;
        if (u !== void 0 && L > u)
          return !1;
        vec3.add(o, t, vec3.scale(o, r, L));
      }
      return !0;
    };
  })(),
  /**
  * test a ray cylinder collision (only vertical cylinders) and retrieves the collision point [not fully tested]
  * @method testRayCylinder
  * @param {vec3} start ray start
  * @param {vec3} direction ray direction
  * @param {vec3} p center of the cylinder
  * @param {number} q height of the cylinder
  * @param {number} r radius of the cylinder
  * @param {vec3} result collision position
  * @return {boolean} returns if the ray collides the cylinder
  */
  testRayCylinder: function(n, t, r, s, a, o) {
    var u = vec3.clone(n), h = vec3.add(vec3.create(), n, vec3.scale(vec3.create(), t, 1e5)), l = 0, c = vec3.subtract(vec3.create(), s, r), d = vec3.subtract(vec3.create(), u, r), f = vec3.subtract(vec3.create(), h, u), _ = vec3.dot(d, c), E = vec3.dot(f, c), m = vec3.dot(c, c);
    if (_ < 0 && _ + E < 0 || _ > m && _ + E > m) return !1;
    var T = vec3.dot(f, f), L = vec3.dot(d, f), G = m * T - E * E, O = vec3.dot(d, d) - a * a, b = m * O - _ * _;
    if (Math.abs(G) < EPSILON)
      return b > 0 ? !1 : (_ < 0 ? l = -L / T : _ > m ? l = (E - L) / T : l = 0, o && vec3.add(o, u, vec3.scale(o, f, l)), !0);
    var I = m * L - E * _, S = I * I - G * b;
    return S < 0 || (l = (-I - Math.sqrt(S)) / G, l < 0 || l > 1) ? !1 : _ + l * E < 0 ? E <= 0 ? !1 : (l = -_ / E, o && vec3.add(o, u, vec3.scale(o, f, l)), O + 2 * l * (L + l * T) <= 0) : _ + l * E > m ? E >= 0 ? !1 : (l = (m - _) / E, o && vec3.add(o, u, vec3.scale(o, f, l)), O + m - 2 * _ + l * (2 * (L - E) + l * T) <= 0) : (o && vec3.add(o, u, vec3.scale(o, f, l)), !0);
  },
  /**
  * test a ray bounding-box collision and retrieves the collision point, the BB must be Axis Aligned
  * @method testRayBox
  * @param {vec3} start ray start
  * @param {vec3} direction ray direction
  * @param {vec3} minB minimum position of the bounding box
  * @param {vec3} maxB maximim position of the bounding box
  * @param {vec3} result collision position
  * @return {boolean} returns if the ray collides the box
  */
  testRayBox: (function() {
    var n = new Float32Array(3), t = new Float32Array(3), r = new Float32Array(3);
    return function(s, a, o, u, h, l) {
      l = l || Number.MAX_VALUE;
      var c = !0, d = 0, f;
      for (n.fill(0), r.fill(0), t.fill(0), d = 0; d < 3; ++d)
        s[d] < o[d] ? (n[d] = 1, t[d] = o[d], c = !1) : s[d] > u[d] ? (n[d] = 0, t[d] = u[d], c = !1) : n[d] = 2;
      if (c)
        return h && vec3.copy(h, s), !0;
      for (d = 0; d < 3; ++d)
        n[d] != 2 && a[d] != 0 ? r[d] = (t[d] - s[d]) / a[d] : r[d] = -1;
      for (f = 0, d = 1; d < 3; d++)
        r[f] < r[d] && (f = d);
      if (r[f] < 0 || r[f] > l) return !1;
      for (d = 0; d < 3; ++d)
        if (f != d) {
          var _ = s[d] + r[f] * a[d];
          if (_ < o[d] || _ > u[d])
            return !1;
          h && (h[d] = _);
        } else
          h && (h[d] = t[d]);
      return !0;
    };
  })(),
  /**
  * test a ray bounding-box collision, it uses the  BBox class and allows to use non-axis aligned bbox
  * @method testRayBBox
  * @param {vec3} origin ray origin
  * @param {vec3} direction ray direction
  * @param {BBox} box in BBox format
  * @param {mat4} model transformation of the BBox [optional]
  * @param {vec3} result collision position in world space unless in_local is true
  * @return {boolean} returns if the ray collides the box
  */
  testRayBBox: (function() {
    var n = mat4.create(), t = vec3.create(), r = vec3.create();
    return function(s, a, o, u, h, l, c) {
      if (!s || !a || !o)
        throw "parameters missing";
      u && (mat4.invert(n, u), vec3.add(t, s, a), s = vec3.transformMat4(r, s, n), vec3.transformMat4(t, t, n), vec3.sub(t, t, s), a = vec3.normalize(t, t));
      var d = this.testRayBox(s, a, o.subarray(6, 9), o.subarray(9, 12), h, l);
      return !c && u && h && vec3.transformMat4(h, h, u), d;
    };
  })(),
  /**
  * test if a 3d point is inside a BBox
  * @method testPointBBox
  * @param {vec3} point
  * @param {BBox} bbox
  * @return {boolean} true if it is inside
  */
  testPointBBox: function(n, t) {
    return !(n[0] < t[6] || n[0] > t[9] || n[1] < t[7] || n[0] > t[10] || n[2] < t[8] || n[0] > t[11]);
  },
  /**
  * test if a BBox overlaps another BBox
  * @method testBBoxBBox
  * @param {BBox} a
  * @param {BBox} b
  * @return {boolean} true if it overlaps
  */
  testBBoxBBox: function(n, t) {
    var r = Math.abs(t[0] - n[0]);
    if (r > n[3] + t[3])
      return !1;
    var s = Math.abs(t[1] - n[1]);
    if (s > n[4] + t[4])
      return !1;
    var a = Math.abs(t[2] - n[2]);
    if (a > n[5] + t[5])
      return !1;
    var o = BBox.getMin(t);
    if (geo.testPointBBox(o, n)) {
      var u = BBox.getMax(t);
      if (geo.testPointBBox(u, n))
        return !0;
    }
    return !0;
  },
  /**
  * test if a sphere overlaps a BBox
  * @method testSphereBBox
  * @param {vec3} point
  * @param {float} radius
  * @param {BBox} bounding_box
  * @return {boolean} true if it overlaps
  */
  testSphereBBox: function(n, t, r) {
    for (var s, a = 0, o = BBox.getMin(r), u = BBox.getMax(r), h = 0; h < 3; ++h)
      n[h] < o[h] ? (s = n[h] - o[h], a += s * s) : n[h] > u[h] && (s = n[h] - u[h], a += s * s);
    var l = t * t;
    return a <= l;
  },
  closestPointBetweenLines: function(n, t, r, s, a, o) {
    var u = vec3.subtract(vec3.create(), t, n), h = vec3.subtract(vec3.create(), s, r), l = vec3.subtract(vec3.create(), n, r), c = vec3.dot(u, u), d = vec3.dot(u, h), f = vec3.dot(h, h), _ = vec3.dot(u, l), E = vec3.dot(h, l), m = c * f - d * d, T, L;
    m < EPSILON ? (T = 0, L = d > f ? _ / d : E / f) : (T = (d * E - f * _) / m, L = (c * E - d * _) / m), a && vec3.add(a, n, vec3.scale(vec3.create(), u, T)), o && vec3.add(o, r, vec3.scale(vec3.create(), h, L));
    var G = vec3.add(vec3.create(), l, vec3.subtract(vec3.create(), vec3.scale(vec3.create(), u, T), vec3.scale(vec3.create(), h, L)));
    return vec3.length(G);
  },
  /**
  * extract frustum planes given a view-projection matrix
  * @method extractPlanes
  * @param {mat4} viewprojection matrix
  * @return {Float32Array} returns all 6 planes in a float32array[24]
  */
  extractPlanes: function(n, r) {
    var r = r || new Float32Array(24);
    return r.set([n[3] - n[0], n[7] - n[4], n[11] - n[8], n[15] - n[12]], 0), s(0), r.set([n[3] + n[0], n[7] + n[4], n[11] + n[8], n[15] + n[12]], 4), s(4), r.set([n[3] + n[1], n[7] + n[5], n[11] + n[9], n[15] + n[13]], 8), s(8), r.set([n[3] - n[1], n[7] - n[5], n[11] - n[9], n[15] - n[13]], 12), s(12), r.set([n[3] - n[2], n[7] - n[6], n[11] - n[10], n[15] - n[14]], 16), s(16), r.set([n[3] + n[2], n[7] + n[6], n[11] + n[10], n[15] + n[14]], 20), s(20), r;
    function s(a) {
      var o = r.subarray(a, a + 3), u = vec3.length(o);
      u !== 0 && (u = 1 / u, r[a] *= u, r[a + 1] *= u, r[a + 2] *= u, r[a + 3] *= u);
    }
  },
  /**
  * test a BBox against the frustum
  * @method frustumTestBox
  * @param {Float32Array} planes frustum planes
  * @param {BBox} boundindbox in BBox format
  * @return {enum} CLIP_INSIDE, CLIP_OVERLAP, CLIP_OUTSIDE
  */
  frustumTestBox: function(n, t) {
    var r = 0, s = 0;
    return r = planeBoxOverlap(n.subarray(0, 4), t), r == CLIP_OUTSIDE || (s += r, r = planeBoxOverlap(n.subarray(4, 8), t), r == CLIP_OUTSIDE) || (s += r, r = planeBoxOverlap(n.subarray(8, 12), t), r == CLIP_OUTSIDE) || (s += r, r = planeBoxOverlap(n.subarray(12, 16), t), r == CLIP_OUTSIDE) || (s += r, r = planeBoxOverlap(n.subarray(16, 20), t), r == CLIP_OUTSIDE) || (s += r, r = planeBoxOverlap(n.subarray(20, 24), t), r == CLIP_OUTSIDE) ? CLIP_OUTSIDE : (s += r, s == 0 ? CLIP_INSIDE : CLIP_OVERLAP);
  },
  /**
  * test a Sphere against the frustum
  * @method frustumTestSphere
  * @param {vec3} center sphere center
  * @param {number} radius sphere radius
  * @return {enum} CLIP_INSIDE, CLIP_OVERLAP, CLIP_OUTSIDE
  */
  frustumTestSphere: function(n, t, r) {
    var s, a = !1;
    return s = distanceToPlane(n.subarray(0, 4), t), s < -r || (s >= -r && s <= r && (a = !0), s = distanceToPlane(n.subarray(4, 8), t), s < -r) || (s >= -r && s <= r && (a = !0), s = distanceToPlane(n.subarray(8, 12), t), s < -r) || (s >= -r && s <= r && (a = !0), s = distanceToPlane(n.subarray(12, 16), t), s < -r) || (s >= -r && s <= r && (a = !0), s = distanceToPlane(n.subarray(16, 20), t), s < -r) || (s >= -r && s <= r && (a = !0), s = distanceToPlane(n.subarray(20, 24), t), s < -r) ? CLIP_OUTSIDE : (s >= -r && s <= r && (a = !0), a ? CLIP_OVERLAP : CLIP_INSIDE);
  },
  /**
  * test if a 2d point is inside a 2d polygon
  * @method testPoint2DInPolygon
  * @param {Array} poly array of 2d points
  * @param {vec2} point
  * @return {boolean} true if it is inside
  */
  testPoint2DInPolygon: function(n, t) {
    for (var r = !1, s = -1, a = n.length, o = a - 1; ++s < a; o = s)
      (n[s][1] <= t[1] && t[1] < n[o][1] || n[o][1] <= t[1] && t[1] < n[s][1]) && t[0] < (n[o][0] - n[s][0]) * (t[1] - n[s][1]) / (n[o][1] - n[s][1]) + n[s][0] && (r = !r);
    return r;
  }
};
global$1.BBox = GL$1.BBox = {
  center: 0,
  halfsize: 3,
  min: 6,
  max: 9,
  radius: 12,
  data_length: 13,
  //corners: new Float32Array([1,1,1,  1,1,-1,  1,-1,1,  1,-1,-1,  -1,1,1,  -1,1,-1,  -1,-1,1,  -1,-1,-1 ]),
  corners: [vec3.fromValues(1, 1, 1), vec3.fromValues(1, 1, -1), vec3.fromValues(1, -1, 1), vec3.fromValues(1, -1, -1), vec3.fromValues(-1, 1, 1), vec3.fromValues(-1, 1, -1), vec3.fromValues(-1, -1, 1), vec3.fromValues(-1, -1, -1)],
  /**
  * create an empty bbox
  * @method create
  * @return {BBox} returns a float32array with the bbox
  */
  create: function() {
    return new Float32Array(13);
  },
  /**
  * create an bbox copy from another one
  * @method clone
  * @return {BBox} returns a float32array with the bbox
  */
  clone: function(n) {
    return new Float32Array(n);
  },
  /**
  * copy one bbox into another
  * @method copy
  * @param {BBox} out where to store the result
  * @param {BBox} where to read the bbox
  * @return {BBox} returns out
  */
  copy: function(n, t) {
    return n.set(t), n;
  },
  /**
  * create a bbox from one point
  * @method fromPoint
  * @param {vec3} point
  * @return {BBox} returns a float32array with the bbox
  */
  fromPoint: function(n) {
    var t = this.create();
    return t.set(n, 0), t.set(n, 6), t.set(n, 9), t;
  },
  /**
  * create a bbox from min and max points
  * @method fromMinMax
  * @param {vec3} min
  * @param {vec3} max
  * @return {BBox} returns a float32array with the bbox
  */
  fromMinMax: function(n, t) {
    var r = this.create();
    return this.setMinMax(r, n, t), r;
  },
  /**
  * create a bbox from center and halfsize
  * @method fromCenterHalfsize
  * @param {vec3} center
  * @param {vec3} halfsize
  * @return {BBox} returns a float32array with the bbox
  */
  fromCenterHalfsize: function(n, t) {
    var r = this.create();
    return this.setCenterHalfsize(r, n, t), r;
  },
  /**
  * create a bbox from a typed-array containing points
  * @method fromPoints
  * @param {Float32Array} points
  * @return {BBox} returns a float32array with the bbox
  */
  fromPoints: function(n) {
    var t = this.create();
    return this.setFromPoints(t, n), t;
  },
  /**
  * set the values to a BB from a set of points
  * @method setFromPoints
  * @param {BBox} out where to store the result
  * @param {Float32Array} points
  * @return {BBox} returns a float32array with the bbox
  */
  setFromPoints: function(n, t) {
    var r = n.subarray(6, 9), s = n.subarray(9, 12);
    r[0] = t[0], r[1] = t[1], r[2] = t[2], s.set(r);
    for (var a = 3, o = t.length; a < o; a += 3) {
      var u = t[a], h = t[a + 1], l = t[a + 2];
      u < r[0] ? r[0] = u : u > s[0] && (s[0] = u), h < r[1] ? r[1] = h : h > s[1] && (s[1] = h), l < r[2] ? r[2] = l : l > s[2] && (s[2] = l);
    }
    return n[0] = (r[0] + s[0]) * 0.5, n[1] = (r[1] + s[1]) * 0.5, n[2] = (r[2] + s[2]) * 0.5, n[3] = s[0] - n[0], n[4] = s[1] - n[1], n[5] = s[2] - n[2], n[12] = Math.sqrt(n[3] * n[3] + n[4] * n[4] + n[5] * n[5]), n;
  },
  /**
  * set the values to a BB from min and max
  * @method setMinMax
  * @param {BBox} out where to store the result
  * @param {vec3} min
  * @param {vec3} max
  * @return {BBox} returns out
  */
  setMinMax: function(n, t, r) {
    n[6] = t[0], n[7] = t[1], n[8] = t[2], n[9] = r[0], n[10] = r[1], n[11] = r[2];
    var s = n.subarray(3, 6);
    return vec3.sub(s, r, t), vec3.scale(s, s, 0.5), n[0] = r[0] - s[0], n[1] = r[1] - s[1], n[2] = r[2] - s[2], n[12] = vec3.length(n.subarray(3, 6)), n;
  },
  /**
  * set the values to a BB from center and halfsize
  * @method setCenterHalfsize
  * @param {BBox} out where to store the result
  * @param {vec3} min
  * @param {vec3} max
  * @param {number} radius [optional] (the minimum distance from the center to the further point)
  * @return {BBox} returns out
  */
  setCenterHalfsize: function(n, t, r, s) {
    return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = r[0], n[4] = r[1], n[5] = r[2], n[6] = n[0] - n[3], n[7] = n[1] - n[4], n[8] = n[2] - n[5], n[9] = n[0] + n[3], n[10] = n[1] + n[4], n[11] = n[2] + n[5], s ? n[12] = s : n[12] = vec3.length(r), n;
  },
  /**
  * Apply a matrix transformation to the BBox (applies to every corner and recomputes the BB)
  * @method transformMat4
  * @param {BBox} out where to store the result
  * @param {BBox} bb bbox you want to transform
  * @param {mat4} mat transformation
  * @return {BBox} returns out
  */
  transformMat4: (function() {
    for (var n = 0, t = 0, r = 0, s = new Float32Array(24), a = [], o = 0; o < 24; o += 3)
      a.push(s.subarray(o, o + 3));
    return function(u, h, l) {
      var c = h[0], d = h[1], f = h[2];
      n = h[3], t = h[4], r = h[5];
      for (var _ = this.corners, E = 0; E < 8; ++E) {
        var m = _[E], T = a[E];
        T[0] = n * m[0] + c, T[1] = t * m[1] + d, T[2] = r * m[2] + f, mat4.multiplyVec3(T, l, T);
      }
      return this.setFromPoints(u, s);
    };
  })(),
  /**
  * Computes the eight corners of the BBox and returns it
  * @method getCorners
  * @param {BBox} bb the bounding box
  * @param {Float32Array} result optional, should be 8 * 3
  * @return {Float32Array} returns the 8 corners
  */
  getCorners: function(n, t) {
    var r = n, s = n.subarray(3, 6), a = null;
    t ? (t.set(this.corners), a = t) : a = new Float32Array(this.corners);
    for (var o = 0; o < 8; ++o) {
      var u = a.subarray(o * 3, o * 3 + 3);
      vec3.multiply(u, s, u), vec3.add(u, u, r);
    }
    return a;
  },
  merge: function(n, t, r) {
    var s = n.subarray(6, 9), a = n.subarray(9, 12);
    return vec3.min(s, t.subarray(6, 9), r.subarray(6, 9)), vec3.max(a, t.subarray(9, 12), r.subarray(9, 12)), BBox.setMinMax(n, s, a);
  },
  extendToPoint: function(n, t) {
    t[0] < n[6] ? n[6] = t[0] : t[0] > n[9] && (n[9] = t[0]), t[1] < n[7] ? n[7] = t[1] : t[1] > n[10] && (n[10] = t[1]), t[2] < n[8] ? n[8] = t[2] : t[2] > n[11] && (n[11] = t[2]);
    var r = n.subarray(6, 9), s = n.subarray(9, 12), a = vec3.add(n.subarray(0, 3), r, s);
    return vec3.scale(a, a, 0.5), vec3.subtract(n.subarray(3, 6), s, a), n[12] = vec3.length(n.subarray(3, 6)), n;
  },
  clampPoint: function(n, t, r) {
    n[0] = Math.clamp(r[0], t[0] - t[3], t[0] + t[3]), n[1] = Math.clamp(r[1], t[1] - t[4], t[1] + t[4]), n[2] = Math.clamp(r[2], t[2] - t[5], t[2] + t[5]);
  },
  isPointInside: function(n, t) {
    return !(n[0] - n[3] > t[0] || n[1] - n[4] > t[1] || n[2] - n[5] > t[2] || n[0] + n[3] < t[0] || n[1] + n[4] < t[1] || n[2] + n[5] < t[2]);
  },
  getCenter: function(n) {
    return n.subarray(0, 3);
  },
  getHalfsize: function(n) {
    return n.subarray(3, 6);
  },
  getMin: function(n) {
    return n.subarray(6, 9);
  },
  getMax: function(n) {
    return n.subarray(9, 12);
  },
  getRadius: function(n) {
    return n[12];
  }
  //setCenter,setHalfsize not coded, too much work to update all
};
global$1.distanceToPlane = GL$1.distanceToPlane = function n(t, r) {
  return vec3.dot(t, r) + t[3];
};
global$1.planeBoxOverlap = GL$1.planeBoxOverlap = function n(t, r) {
  var s = t, a = t[3], o = r, u = r, h = Math.abs(u[3] * s[0]) + Math.abs(u[4] * s[1]) + Math.abs(u[5] * s[2]), l = vec3.dot(s, o) + a;
  return l <= -h ? CLIP_OUTSIDE : l <= h ? CLIP_OVERLAP : CLIP_INSIDE;
};
const nt = class nt {
  constructor(t) {
    this.root = null, this.total_depth = 0, this.total_nodes = 0, t && (this.buildFromMesh(t), this.total_nodes = this.trim()), this.octree_pos_ref = [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]];
  }
  buildFromMesh(t) {
    this.total_depth = 0, this.total_nodes = 0;
    var r = t.getBuffer("vertices").data, s = t.getIndexBuffer("triangles");
    s && (s = s.data);
    var a = this.computeAABB(r);
    this.root = a, this.total_nodes = 1, this.total_triangles = s ? s.length / 3 : r.length / 9, this.max_node_triangles = this.total_triangles * nt.MAX_NODE_TRIANGLES_RATIO;
    var o = vec3.create();
    if (vec3.scale(o, a.size, nt.OCTREE_MARGIN_RATIO), o[0] < nt.OCTREE_MIN_MARGIN && (o[0] = nt.OCTREE_MIN_MARGIN), o[1] < nt.OCTREE_MIN_MARGIN && (o[1] = nt.OCTREE_MIN_MARGIN), o[2] < nt.OCTREE_MIN_MARGIN && (o[2] = nt.OCTREE_MIN_MARGIN), vec3.sub(a.min, a.min, o), vec3.add(a.max, a.max, o), a.faces = [], a.inside = 0, s)
      for (var u = 0; u < s.length; u += 3) {
        var h = new Float32Array([
          r[s[u] * 3],
          r[s[u] * 3 + 1],
          r[s[u] * 3 + 2],
          r[s[u + 1] * 3],
          r[s[u + 1] * 3 + 1],
          r[s[u + 1] * 3 + 2],
          r[s[u + 2] * 3],
          r[s[u + 2] * 3 + 1],
          r[s[u + 2] * 3 + 2],
          u / 3
        ]);
        this.addToNode(h, a, 0);
      }
    else
      for (var u = 0; u < r.length; u += 9) {
        var h = new Float32Array(10);
        h.set(r.subarray(u, u + 9)), h[9] = u / 9, this.addToNode(h, a, 0);
      }
    return a;
  }
  addToNode(t, r, s) {
    if (r.inside += 1, r.c) {
      var a = this.computeAABB(t), o = !1;
      for (var u in r.c) {
        var h = r.c[u];
        if (nt.isInsideAABB(a, h)) {
          this.addToNode(t, h, s + 1), o = !0;
          break;
        }
      }
      o || (r.faces == null && (r.faces = []), r.faces.push(t));
    } else if (r.faces == null && (r.faces = []), r.faces.push(t), r.faces.length > this.max_node_triangles && s < nt.MAX_OCTREE_DEPTH) {
      this.splitNode(r), this.total_depth < s + 1 && (this.total_depth = s + 1);
      var l = r.faces.concat();
      r.faces = null;
      for (var u in l) {
        var t = l[u], a = this.computeAABB(t), o = !1;
        for (var c in r.c) {
          var h = r.c[c];
          if (nt.isInsideAABB(a, h)) {
            this.addToNode(t, h, s + 1), o = !0;
            break;
          }
        }
        o || (r.faces == null && (r.faces = []), r.faces.push(t));
      }
    }
  }
  splitNode(t) {
    t.c = [];
    var r = [(t.max[0] - t.min[0]) * 0.5, (t.max[1] - t.min[1]) * 0.5, (t.max[2] - t.min[2]) * 0.5];
    for (var s in this.octree_pos_ref) {
      var a = this.octree_pos_ref[s], o = {};
      this.total_nodes += 1, o.min = [t.min[0] + r[0] * a[0], t.min[1] + r[1] * a[1], t.min[2] + r[2] * a[2]], o.max = [o.min[0] + r[0], o.min[1] + r[1], o.min[2] + r[2]], o.faces = null, o.inside = 0, t.c.push(o);
    }
  }
  computeAABB(t) {
    for (var r = new Float32Array([t[0], t[1], t[2]]), s = new Float32Array([t[0], t[1], t[2]]), a = 0; a < t.length; a += 3)
      for (var o = 0; o < 3; o++)
        r[o] > t[a + o] && (r[o] = t[a + o]), s[o] < t[a + o] && (s[o] = t[a + o]);
    return { min: r, max: s, size: vec3.sub(vec3.create(), s, r) };
  }
  //remove empty nodes
  trim(t) {
    if (t = t || this.root, !t.c)
      return 1;
    for (var r = 1, s = [], a = t.c, o = 0; o < a.length; ++o)
      a[o].inside && (s.push(a[o]), r += this.trim(a[o]));
    return t.c = s, r;
  }
  /**
  * test collision between sphere and the triangles in the octree (only test if there is any vertex inside the sphere)
  * @method testSphere
  * @param {vec3} origin sphere center
  * @param {number} radius
  * @return {Boolean} true if the sphere collided with the mesh
  */
  testSphere(t, r) {
    if (t = vec3.clone(t), !this.root)
      throw "Error: octree not build";
    var s = r * r;
    return nt.testSphereBox(t, s, vec3.clone(this.root.min), vec3.clone(this.root.max)) ? nt.testSphereInNode(this.root, t, s) : !1;
  }
  //test if one bounding is inside or overlapping another bounding
  static isInsideAABB(t, r) {
    return !(t.min[0] < r.min[0] || t.min[1] < r.min[1] || t.min[2] < r.min[2] || t.max[0] > r.max[0] || t.max[1] > r.max[1] || t.max[2] > r.max[2]);
  }
};
g(nt, "MAX_NODE_TRIANGLES_RATIO", 0.1), g(nt, "MAX_OCTREE_DEPTH", 8), g(nt, "OCTREE_MARGIN_RATIO", 0.01), g(nt, "OCTREE_MIN_MARGIN", 0.1);
let Octree = nt;
Octree.testRayInNode = function(n, t, r, s) {
  var a = null, o = null;
  if (n.faces)
    for (var u = 0, h = n.faces.length; u < h; ++u) {
      var l = n.faces[u];
      a = Octree.hitTestTriangle(t, r, l.subarray(0, 3), l.subarray(3, 6), l.subarray(6, 9), s), a != null && (a.face = l, o ? o.mergeWith(a) : o = a);
    }
  var c = vec3.create(), d = vec3.create(), f;
  if (n.c)
    for (var u = 0; u < n.c.length; ++u)
      f = n.c[u], c.set(f.min), d.set(f.max), a = Octree.hitTestBox(t, r, c, d), a != null && (o && a.t > o.t || (a = Octree.testRayInNode(f, t, r, s), a != null && (o ? o.mergeWith(a) : o = a)));
  return o;
};
Octree.testSphereInNode = function(n, t, r) {
  if (n.faces)
    for (var s = 0, a = n.faces.length; s < a; ++s) {
      var o = n.faces[s];
      if (Octree.testSphereTriangle(t, r, o.subarray(0, 3), o.subarray(3, 6), o.subarray(6, 9)))
        return !0;
    }
  var u = vec3.create(), h = vec3.create(), l;
  if (n.c) {
    for (var s = 0; s < n.c.length; ++s)
      if (l = n.c[s], u.set(l.min), h.set(l.max), !!Octree.testSphereBox(t, r, u, h) && Octree.testSphereInNode(l, t, r))
        return !0;
  }
  return !1;
};
Octree.hitTestBox = (function() {
  var n = vec3.create(), t = vec3.create(), r = vec3.create(), s = vec3.create(), a = vec3.create(), o = vec3.create(), u = 1e-6, h = vec3.fromValues(u, u, u);
  return function(l, c, d, f) {
    if (vec3.subtract(n, d, l), vec3.subtract(t, f, l), vec3.maxValue(n) < 0 && vec3.minValue(t) > 0)
      return new HitTest(0, l, c);
    r[0] = 1 / c[0], r[1] = 1 / c[1], r[2] = 1 / c[2], vec3.multiply(n, n, r), vec3.multiply(t, t, r), vec3.min(s, n, t), vec3.max(a, n, t);
    var _ = vec3.maxValue(s), E = vec3.minValue(a);
    if (_ > 0 && _ < E) {
      var m = vec3.add(vec3.create(), vec3.scale(o, c, _), l);
      return vec3.add(d, d, h), vec3.subtract(d, d, h), new HitTest(_, m, vec3.fromValues(
        (m[0] > f[0]) - (m[0] < d[0]),
        (m[1] > f[1]) - (m[1] < d[1]),
        (m[2] > f[2]) - (m[2] < d[2])
      ));
    }
    return null;
  };
})();
Octree.hitTestTriangle = (function() {
  var n = vec3.create(), t = vec3.create(), r = vec3.create(), s = vec3.create();
  return function(a, o, u, h, l, c) {
    vec3.subtract(n, h, u), vec3.subtract(t, l, u);
    var d = vec3.cross(vec3.create(), n, t);
    if (vec3.normalize(d, d), !c && vec3.dot(d, o) > 0)
      return null;
    var f = vec3.dot(d, vec3.subtract(s, u, a)) / vec3.dot(d, o);
    if (f > 0) {
      var _ = vec3.scale(vec3.create(), o, f);
      vec3.add(_, _, a), vec3.subtract(r, _, u);
      var E = vec3.dot(t, t), m = vec3.dot(t, n), T = vec3.dot(t, r), L = vec3.dot(n, n), G = vec3.dot(n, r), O = E * L - m * m, b = (L * T - m * G) / O, I = (E * G - m * T) / O;
      if (b >= 0 && I >= 0 && b + I <= 1)
        return new HitTest(f, _, d);
    }
    return null;
  };
})();
Octree.testSphereTriangle = (function() {
  var n = vec3.create(), t = vec3.create(), r = vec3.create(), s = vec3.create(), a = vec3.create(), o = vec3.create(), u = vec3.create(), h = vec3.create();
  return function(l, c, d, f, _) {
    vec3.sub(n, d, l), vec3.sub(t, f, l), vec3.sub(r, _, l), vec3.sub(s, t, n), vec3.sub(a, r, n), vec3.cross(h, s, a);
    var E = vec3.dot(n, h), m = vec3.dot(h, h), T = E * E > c * m, L = vec3.dot(n, n), G = vec3.dot(n, t), O = vec3.dot(n, r), b = vec3.dot(t, t), I = vec3.dot(t, r), S = vec3.dot(r, r), N = L > c & G > L & O > L, C = b > c & G > b & I > b, D = S > c & O > S & I > S, M = G - L, P = I - b, A = O - S;
    vec3.sub(o, r, t), vec3.sub(u, n, r);
    var R = vec3.dot(s, s), B = vec3.dot(o, o), X = vec3.dot(u, u), F = vec3.scale(vec3.create(), n, R);
    vec3.sub(F, F, vec3.scale(vec3.create(), s, M));
    var V = vec3.scale(vec3.create(), t, B);
    vec3.sub(V, V, vec3.scale(vec3.create(), o, P));
    var $ = vec3.scale(vec3.create(), r, X);
    vec3.sub($, $, vec3.scale(vec3.create(), u, A));
    var U = vec3.scale(vec3.create(), r, R);
    U = vec3.sub(U, U, F);
    var H = vec3.scale(vec3.create(), n, B);
    H = vec3.sub(H, H, V);
    var z = vec3.scale(vec3.create(), t, X);
    z = vec3.sub(z, z, $);
    var K = vec3.dot(F, F) > c * R * R & vec3.dot(F, U) > 0, tt = vec3.dot(V, V) > c * B * B & vec3.dot(V, H) > 0, W = vec3.dot($, $) > c * X * X & vec3.dot($, z) > 0, Q = T | N | C | D | K | tt | W;
    return !Q;
  };
})();
Octree.testSphereBox = function(n, t, r, s) {
  for (var a, o = 0, u = 0; u < 3; ++u)
    n[u] < r[u] ? (a = n[u] - r[u], o += a * a) : n[u] > s[u] && (a = n[u] - s[u], o += a * a);
  return o <= t;
};
Octree.prototype.testRay = (function() {
  var n = vec3.create(), t = vec3.create(), r = vec3.create(), s = vec3.create();
  return function(a, o, u, h, l) {
    if (!this.root)
      throw "Error: octree not build";
    n.set(a), t.set(o), r.set(this.root.min), s.set(this.root.max);
    var c = Octree.hitTestBox(n, t, r, s);
    if (!c)
      return null;
    var c = Octree.testRayInNode(this.root, n, t, l);
    if (c != null) {
      var d = vec3.scale(vec3.create(), o, c.t);
      return vec3.add(d, d, a), c.pos = d, c;
    }
    return null;
  };
})();
GL$1.Octree = Octree;
class HitTest {
  constructor(t, r, s) {
    this.t = arguments.length ? t : Number.MAX_VALUE, this.hit = r, this.normal = s, this.face = null;
  }
  // ### .mergeWith(other)
  // Changes this object to be the closer of the two hit test results.
  mergeWidth(t) {
    t.t > 0 && t.t < this.t && (this.t = t.t, this.hit = t.hit, this.normal = t.normal, this.face = t.face);
  }
}
GL$1.HitTest = HitTest;
class Ray {
  constructor(t, r) {
    this.origin = vec3.create(), this.direction = vec3.create(), this.collision_point = vec3.create(), t && this.origin.set(t), r && this.direction.set(r);
  }
  testPlane(t, r) {
    return geo.testRayPlane(this.origin, this.direction, t, r, this.collision_point);
  }
  testSphere(t, r, s) {
    return geo.testRaySphere(this.origin, this.direction, t, r, this.collision_point, s);
  }
}
GL$1.Ray = Ray;
class Raytracer {
  constructor(t, r) {
    this.viewport = vec4.create(), this.ray00 = vec3.create(), this.ray10 = vec3.create(), this.ray01 = vec3.create(), this.ray11 = vec3.create(), this.eye = vec3.create(), this.setup(t, r);
  }
  setup(t, r) {
    r = r || gl.viewport_data, this.viewport.set(r);
    var s = r[0], a = s + r[2], o = r[1], u = o + r[3];
    vec3.set(this.ray00, s, o, 1), vec3.set(this.ray10, a, o, 1), vec3.set(this.ray01, s, u, 1), vec3.set(this.ray11, a, u, 1), vec3.unproject(this.ray00, this.ray00, t, r), vec3.unproject(this.ray10, this.ray10, t, r), vec3.unproject(this.ray01, this.ray01, t, r), vec3.unproject(this.ray11, this.ray11, t, r);
    var h = this.eye;
    vec3.unproject(h, h, t, r), vec3.subtract(this.ray00, this.ray00, h), vec3.subtract(this.ray10, this.ray10, h), vec3.subtract(this.ray01, this.ray01, h), vec3.subtract(this.ray11, this.ray11, h);
  }
  // ### GL.Raytracer.hitTestBox(origin, ray, min, max)
  // 
  // Traces the ray starting from `origin` along `ray` against the axis-aligned box
  // whose coordinates extend from `min` to `max`. Returns a `HitTest` with the
  // information or `null` for no intersection.
  // 
  // This implementation uses the [slab intersection method](http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm).
  static hitTestBox(t, r, s, a, o) {
    var u = new Float32Array(30);
    if (o) {
      var h = mat4.invert(_hittest_inv, o);
      t = mat4.multiplyVec3(u.subarray(3, 6), h, t), r = mat4.rotateVec3(u.subarray(6, 9), h, r);
    }
    var l = vec3.subtract(u.subarray(9, 12), s, t);
    vec3.divide(l, l, r);
    var c = vec3.subtract(u.subarray(12, 15), a, t);
    vec3.divide(c, c, r);
    var d = vec3.min(u.subarray(15, 18), l, c), f = vec3.max(u.subarray(18, 21), l, c), _ = vec3.maxValue(d), E = vec3.minValue(f);
    if (_ > 0 && _ <= E) {
      var m = 1e-6, T = vec3.scale(u.subarray(21, 24), r, _);
      return vec3.add(T, t, T), vec3.addValue(u.subarray(24, 27), s, m), vec3.subValue(u.subarray(27, 30), a, m), new HitTest(_, T, vec3.fromValues(
        (T[0] > a[0]) - (T[0] < s[0]),
        (T[1] > a[1]) - (T[1] < s[1]),
        (T[2] > a[2]) - (T[2] < s[2])
      ));
    }
    return null;
  }
  // ### GL.Raytracer.hitTestSphere(origin, ray, center, radius)
  // 
  // Traces the ray starting from `origin` along `ray` against the sphere defined
  // by `center` and `radius`. Returns a `HitTest` with the information or `null`
  // for no intersection.
  static hitTestSphere(t, r, s, a) {
    var o = vec3.subtract(vec3.create(), t, s), u = vec3.dot(r, r), h = 2 * vec3.dot(r, o), l = vec3.dot(o, o) - a * a, c = h * h - 4 * u * l;
    if (c > 0) {
      var d = (-h - Math.sqrt(c)) / (2 * u), f = vec3.add(vec3.create(), t, vec3.scale(vec3.create(), r, d));
      return new HitTest(d, f, vec3.scale(vec3.create(), vec3.subtract(vec3.create(), f, s), 1 / a));
    }
    return null;
  }
  // ### GL.Raytracer.hitTestTriangle(origin, ray, a, b, c)
  // 
  // Traces the ray starting from `origin` along `ray` against the triangle defined
  // by the points `a`, `b`, and `c`. Returns a `HitTest` with the information or
  // `null` for no intersection.
  static hitTestTriangle(t, r, s, a, o) {
    var u = vec3.subtract(vec3.create(), a, s), h = vec3.subtract(vec3.create(), o, s), l = vec3.cross(vec3.create(), u, h);
    vec3.normalize(l, l);
    var c = vec3.dot(l, vec3.subtract(vec3.create(), s, t)) / vec3.dot(l, r);
    if (c > 0) {
      var d = vec3.add(vec3.create(), t, vec3.scale(vec3.create(), r, c)), f = vec3.subtract(vec3.create(), d, s), _ = vec3.dot(h, h), E = vec3.dot(h, u), m = vec3.dot(h, f), T = vec3.dot(u, u), L = vec3.dot(u, f), G = _ * T - E * E, O = (T * m - E * L) / G, b = (_ * L - E * m) / G;
      if (O >= 0 && b >= 0 && O + b <= 1) return new HitTest(c, d, l);
    }
    return null;
  }
}
GL$1.Raytracer = Raytracer;
var _hittest_inv = mat4.create();
Raytracer.prototype.getRayForPixel = (function() {
  var n = vec3.create(), t = vec3.create();
  return function(r, s, a) {
    return a = a || vec3.create(), r = (r - this.viewport[0]) / this.viewport[2], s = 1 - (s - this.viewport[1]) / this.viewport[3], vec3.lerp(n, this.ray00, this.ray10, r), vec3.lerp(t, this.ray01, this.ray11, r), vec3.lerp(a, n, t, s), vec3.normalize(a, a);
  };
})();
LiteGraph.LGraphCanvas.link_type_colors.Texture = "#987";
const DEG2RAD = 0.0174532925, it = class it {
  constructor() {
    this.addOutput("tex", "Texture"), this.addOutput("name", "string"), this.properties = {
      name: "",
      filter: !0
    }, this.size = [
      it.image_preview_size,
      it.image_preview_size
    ];
  }
  // returns the container where all the loaded textures are stored (overwrite if you have a Resources Manager)
  static getTexturesContainer() {
    return gl$1.textures;
  }
  // process the loading of a texture (overwrite it if you have a Resources Manager)
  static loadTexture(t, r) {
    r = r || {};
    var s = t;
    s.substr(0, 7) == "http://" && LiteGraph.proxy && (s = LiteGraph.proxy + s.substr(7));
    var a = it.getTexturesContainer(), o = a[t] = GL$1.Texture.fromURL(s, r);
    return o;
  }
  static getTexture(t) {
    var r = this.getTexturesContainer();
    if (!r)
      throw new Error("Cannot load texture, container of textures not found");
    var s = r[t];
    return !s && t && t[0] != ":" ? this.loadTexture(t) : s;
  }
  // used to compute the appropiate output texture
  static getTargetTexture(t, r, s) {
    if (!t)
      throw new Error("LGraphTexture.getTargetTexture expects a reference texture");
    var a = null;
    switch (s) {
      case it.LOW:
        a = gl$1.UNSIGNED_BYTE;
        break;
      case it.HIGH:
        a = gl$1.HIGH_PRECISION_FORMAT;
        break;
      case it.REUSE:
        return t;
      default:
        a = t ? t.type : gl$1.UNSIGNED_BYTE;
        break;
    }
    return (!r || r.width != t.width || r.height != t.height || r.type != a || r.format != t.format) && (r = new GL$1.Texture(t.width, t.height, {
      type: a,
      format: t.format,
      filter: gl$1.LINEAR
    })), r;
  }
  static getTextureType(t, r) {
    var s = r ? r.type : gl$1.UNSIGNED_BYTE;
    switch (t) {
      case it.HIGH:
        s = gl$1.HIGH_PRECISION_FORMAT;
        break;
      case it.LOW:
        s = gl$1.UNSIGNED_BYTE;
        break;
    }
    return s;
  }
  static getWhiteTexture() {
    if (this._white_texture)
      return this._white_texture;
    var t = this._white_texture = GL$1.Texture.fromMemory(
      1,
      1,
      [255, 255, 255, 255],
      { format: gl$1.RGBA, wrap: gl$1.REPEAT, filter: gl$1.NEAREST }
    );
    return t;
  }
  static getNoiseTexture() {
    if (this._noise_texture)
      return this._noise_texture;
    for (var t = new Uint8Array(512 * 512 * 4), r = 0; r < 512 * 512 * 4; ++r)
      t[r] = Math.random() * 255;
    var s = GL$1.Texture.fromMemory(512, 512, t, {
      format: gl$1.RGBA,
      wrap: gl$1.REPEAT,
      filter: gl$1.NEAREST
    });
    return this._noise_texture = s, s;
  }
  onDropFile(t, r, s) {
    if (!t)
      this._drop_texture = null, this.properties.name = "";
    else {
      var a = null;
      if (typeof t == "string")
        a = GL$1.Texture.fromURL(t);
      else if (r.toLowerCase().indexOf(".dds") != -1)
        a = GL$1.Texture.fromDDSInMemory(t);
      else {
        var o = new Blob([s]), u = URL.createObjectURL(o);
        a = GL$1.Texture.fromURL(u);
      }
      this._drop_texture = a, this.properties.name = r;
    }
  }
  getExtraMenuOptions() {
    var t = this;
    if (this._drop_texture)
      return [
        {
          content: "Clear",
          callback: function() {
            t._drop_texture = null, t.properties.name = "";
          }
        }
      ];
  }
  onExecute() {
    var t = null;
    if (this.isOutputConnected(1) && (t = this.getInputData(0)), !t && this._drop_texture && (t = this._drop_texture), !t && this.properties.name && (t = it.getTexture(this.properties.name)), !t) {
      this.setOutputData(0, null), this.setOutputData(1, "");
      return;
    }
    this._last_tex = t, this.properties.filter === !1 ? t.setParameter(gl$1.TEXTURE_MAG_FILTER, gl$1.NEAREST) : t.setParameter(gl$1.TEXTURE_MAG_FILTER, gl$1.LINEAR), this.setOutputData(0, t), this.setOutputData(1, t.fullpath || t.filename);
    for (var r = 2; r < this.outputs.length; r++) {
      var s = this.outputs[r];
      if (s) {
        var a = null;
        s.name == "width" ? a = t.width : s.name == "height" ? a = t.height : s.name == "aspect" && (a = t.width / t.height), this.setOutputData(r, a);
      }
    }
  }
  onResourceRenamed(t, r) {
    this.properties.name == t && (this.properties.name = r);
  }
  onDrawBackground(t) {
    if (!(this.flags.collapsed || this.size[1] <= 20)) {
      if (this._drop_texture && t.webgl) {
        t.drawImage(this._drop_texture, 0, 0, this.size[0], this.size[1]);
        return;
      }
      if (this._last_preview_tex != this._last_tex)
        if (t.webgl)
          this._canvas = this._last_tex;
        else {
          var r = it.generateLowResTexturePreview(this._last_tex);
          if (!r)
            return;
          this._last_preview_tex = this._last_tex, this._canvas = GL$1.cloneCanvas(r);
        }
      this._canvas && (t.save(), t.webgl || (t.translate(0, this.size[1]), t.scale(1, -1)), t.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]), t.restore());
    }
  }
  // very slow, used at your own risk
  static generateLowResTexturePreview(t) {
    if (!t)
      return null;
    var r = it.image_preview_size, s = t;
    if (t.format == gl$1.DEPTH_COMPONENT)
      return null;
    (t.width > r || t.height > r) && (s = this._preview_temp_tex, this._preview_temp_tex || (s = new GL$1.Texture(r, r, { minFilter: gl$1.NEAREST }), this._preview_temp_tex = s), t.copyTo(s), t = s);
    var a = this._preview_canvas;
    return a || (a = GL$1.createCanvas(r, r), this._preview_canvas = a), s && s.toCanvas(a), a;
  }
  getResources(t) {
    return this.properties.name && (t[this.properties.name] = GL$1.Texture), t;
  }
  onGetInputs() {
    return [["in", "Texture"]];
  }
  onGetOutputs() {
    return [
      ["width", "number"],
      ["height", "number"],
      ["aspect", "number"]
    ];
  }
  // used to replace shader code
  static replaceCode(t, r) {
    return t.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function(s) {
      return s = s.replace(/[\{\}]/g, ""), r[s] || "";
    });
  }
};
g(it, "title", "Texture"), g(it, "desc", "Texture"), g(it, "widgets_info", {
  name: { widget: "texture" },
  filter: { widget: "checkbox" }
}), // REPLACE THIS TO INTEGRATE WITH YOUR FRAMEWORK
g(it, "loadTextureCallback", null), // function in charge of loading textures when not present in the container
g(it, "image_preview_size", 256), // flags to choose output texture type
g(it, "UNDEFINED", 0), // not specified
g(it, "PASS_THROUGH", 1), // do not apply FX (like disable but passing the in to the out)
g(it, "COPY", 2), // create new texture with the same properties as the origin texture
g(it, "LOW", 3), // create new texture with low precision (byte)
g(it, "HIGH", 4), // create new texture with high precision (half-float)
g(it, "REUSE", 5), // reuse input texture
g(it, "DEFAULT", 2), // use the default
g(it, "MODE_VALUES", {
  undefined: it.UNDEFINED,
  "pass through": it.PASS_THROUGH,
  copy: it.COPY,
  low: it.LOW,
  high: it.HIGH,
  reuse: it.REUSE,
  default: it.DEFAULT
});
let LGraphTexture = it;
LiteGraph.registerNodeType("texture/texture", LGraphTexture);
const ye = class ye {
  constructor() {
    this.addInput("Texture", "Texture"), this.properties = { flipY: !1 }, this.size = [
      LGraphTexture.image_preview_size,
      LGraphTexture.image_preview_size
    ];
  }
  onDrawBackground(t) {
    if (!this.flags.collapsed && !(!t.webgl && !ye.allow_preview)) {
      var r = this.getInputData(0);
      if (r) {
        var s = null;
        !r.handle && t.webgl ? s = r : s = LGraphTexture.generateLowResTexturePreview(r), t.save(), this.properties.flipY && (t.translate(0, this.size[1]), t.scale(1, -1)), t.drawImage(s, 0, 0, this.size[0], this.size[1]), t.restore();
      }
    }
  }
};
g(ye, "title", "Preview"), g(ye, "desc", "Show a texture in the graph canvas"), g(ye, "allow_preview", !1);
let LGraphTexturePreview = ye;
LiteGraph.registerNodeType("texture/preview", LGraphTexturePreview);
class LGraphTextureSave {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("tex", "Texture"), this.addOutput("name", "string"), this.properties = { name: "", generate_mipmaps: !1 };
  }
  getPreviewTexture() {
    return this._texture;
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      if (this.properties.generate_mipmaps && (t.bind(0), t.setParameter(gl$1.TEXTURE_MIN_FILTER, gl$1.LINEAR_MIPMAP_LINEAR), gl$1.generateMipmap(t.texture_type), t.unbind(0)), this.properties.name)
        if (LGraphTexture.storeTexture)
          LGraphTexture.storeTexture(this.properties.name, t);
        else {
          var r = LGraphTexture.getTexturesContainer();
          r[this.properties.name] = t;
        }
      this._texture = t, this.setOutputData(0, t), this.setOutputData(1, this.properties.name);
    }
  }
}
g(LGraphTextureSave, "title", "Save"), g(LGraphTextureSave, "desc", "Save a texture in the repository");
LiteGraph.registerNodeType("texture/save", LGraphTextureSave);
const Gt = class Gt {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("TextureB", "Texture"), this.addInput("value", "number"), this.addOutput("Texture", "Texture"), this.help = "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>        <p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>", this.properties = {
      value: 1,
      pixelcode: "color + colorB * value",
      uvcode: "",
      precision: LGraphTexture.DEFAULT
    }, this.has_error = !1;
  }
  getExtraMenuOptions() {
    var t = this, r = t.properties.show ? "Hide Texture" : "Show Texture";
    return [
      {
        content: r,
        callback: function() {
          t.properties.show = !t.properties.show;
        }
      }
    ];
  }
  onPropertyChanged() {
    this.has_error = !1;
  }
  onDrawBackground(t) {
    this.flags.collapsed || this.size[1] <= 20 || !this.properties.show || this._tex && this._tex.gl == t && (t.save(), t.drawImage(this._tex, 0, 0, this.size[0], this.size[1]), t.restore());
  }
  onExecute() {
    var t = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      var r = this.getInputData(1);
      if (!(!this.properties.uvcode && !this.properties.pixelcode)) {
        var s = 512, a = 512;
        t ? (s = t.width, a = t.height) : r && (s = r.width, a = r.height), r || (r = GL$1.Texture.getWhiteTexture());
        var o = LGraphTexture.getTextureType(this.properties.precision, t);
        !t && !this._tex ? this._tex = new GL$1.Texture(s, a, {
          type: o,
          format: gl$1.RGBA,
          filter: gl$1.LINEAR
        }) : this._tex = LGraphTexture.getTargetTexture(
          t || this._tex,
          this._tex,
          this.properties.precision
        );
        var u = "";
        this.properties.uvcode && (u = "uv = " + this.properties.uvcode, this.properties.uvcode.indexOf(";") != -1 && (u = this.properties.uvcode));
        var h = "";
        this.properties.pixelcode && (h = "result = " + this.properties.pixelcode, this.properties.pixelcode.indexOf(";") != -1 && (h = this.properties.pixelcode));
        var l = this._shader;
        if (!this.has_error && (!l || this._shader_code != u + "|" + h)) {
          var c = LGraphTexture.replaceCode(
            Gt.pixel_shader,
            { UV_CODE: u, PIXEL_CODE: h }
          );
          try {
            l = new GL$1.Shader(
              Shader.SCREEN_VERTEX_SHADER,
              c
            ), this.boxcolor = "#00FF00";
          } catch (_) {
            GL$1.Shader.dumpErrorToConsole(
              _,
              Shader.SCREEN_VERTEX_SHADER,
              c
            ), this.boxcolor = "#FF0000", this.has_error = !0;
            return;
          }
          this._shader = l, this._shader_code = u + "|" + h;
        }
        if (this._shader) {
          var d = this.getInputData(2);
          d != null ? this.properties.value = d : d = parseFloat(this.properties.value);
          var f = this.graph.getTime();
          this._tex.drawTo(function() {
            gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.CULL_FACE), gl$1.disable(gl$1.BLEND), t && t.bind(0), r && r.bind(1);
            var _ = Mesh.getScreenQuad();
            l.uniforms({
              u_texture: 0,
              u_textureB: 1,
              value: d,
              texSize: [s, a, 1 / s, 1 / a],
              time: f
            }).draw(_);
          }), this.setOutputData(0, this._tex);
        }
      }
    }
  }
  static registerPreset(t, r) {
    Gt.presets[t] = r;
  }
  // webglstudio stuff...
  onInspect(t) {
    var r = this;
    t.addCombo("Presets", "", {
      values: Object.keys(Gt.presets),
      callback: function(s) {
        var a = Gt.presets[s];
        a && (r.setProperty("pixelcode", a), r.title = s, t.refresh());
      }
    });
  }
};
g(Gt, "widgets_info", {
  uvcode: { widget: "code" },
  pixelcode: { widget: "code" },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(Gt, "title", "Operation"), g(Gt, "desc", "Texture shader operation"), g(Gt, "presets", {}), g(Gt, "pixel_shader", `
        precision highp float;
    
        uniform sampler2D u_texture;
        uniform sampler2D u_textureB;
        varying vec2 v_coord;
        uniform vec4 texSize;
        uniform float time;
        uniform float value;
    
        void main() {
            vec2 uv = v_coord;
            {{UV_CODE}};
            vec4 color4 = texture2D(u_texture, uv);
            vec3 color = color4.rgb;
            vec4 color4B = texture2D(u_textureB, uv);
            vec3 colorB = color4B.rgb;
            vec3 result = color;
            float alpha = 1.0;
            {{PIXEL_CODE}};
            gl_FragColor = vec4(result, alpha);
        }
    `);
let LGraphTextureOperation = Gt;
LGraphTextureOperation.registerPreset("", "");
LGraphTextureOperation.registerPreset("bypass", "color");
LGraphTextureOperation.registerPreset("add", "color + colorB * value");
LGraphTextureOperation.registerPreset(
  "substract",
  "(color - colorB) * value"
);
LGraphTextureOperation.registerPreset(
  "mate",
  "mix( color, colorB, color4B.a * value)"
);
LGraphTextureOperation.registerPreset("invert", "vec3(1.0) - color");
LGraphTextureOperation.registerPreset("multiply", "color * colorB * value");
LGraphTextureOperation.registerPreset("divide", "(color / colorB) / value");
LGraphTextureOperation.registerPreset(
  "difference",
  "abs(color - colorB) * value"
);
LGraphTextureOperation.registerPreset("max", "max(color, colorB) * value");
LGraphTextureOperation.registerPreset("min", "min(color, colorB) * value");
LGraphTextureOperation.registerPreset(
  "displace",
  "texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz"
);
LGraphTextureOperation.registerPreset(
  "grayscale",
  "vec3(color.x + color.y + color.z) * value / 3.0"
);
LGraphTextureOperation.registerPreset(
  "saturation",
  "mix( vec3(color.x + color.y + color.z) / 3.0, color, value )"
);
LGraphTextureOperation.registerPreset(
  "normalmap",
  `
    float z0 = texture2D(u_texture, uv + vec2(-texSize.z, -texSize.w) ).x;
    float z1 = texture2D(u_texture, uv + vec2(0.0, -texSize.w) ).x;
    float z2 = texture2D(u_texture, uv + vec2(texSize.z, -texSize.w) ).x;
    float z3 = texture2D(u_texture, uv + vec2(-texSize.z, 0.0) ).x;
    float z4 = color.x;
    float z5 = texture2D(u_texture, uv + vec2(texSize.z, 0.0) ).x;
    float z6 = texture2D(u_texture, uv + vec2(-texSize.z, texSize.w) ).x;
    float z7 = texture2D(u_texture, uv + vec2(0.0, texSize.w) ).x;
    float z8 = texture2D(u_texture, uv + vec2(texSize.z, texSize.w) ).x;
    vec3 normal = vec3( z2 + 2.0*z4 + z7 - z0 - 2.0*z3 - z5, z5 + 2.0*z6 + z7 -z0 - 2.0*z1 - z2, 1.0 );
    normal.xy *= value;
    result.xyz = normalize(normal) * 0.5 + vec3(0.5);
`
);
LGraphTextureOperation.registerPreset(
  "threshold",
  "vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)"
);
LiteGraph.registerNodeType("texture/operation", LGraphTextureOperation);
const he = class he {
  constructor() {
    this.addOutput("out", "Texture"), this.properties = {
      code: "",
      u_value: 1,
      u_color: [1, 1, 1, 1],
      width: 512,
      height: 512,
      precision: LGraphTexture.DEFAULT
    }, this.properties.code = he.pixel_shader, this._uniforms = {
      u_value: 1,
      u_color: vec4.create(),
      in_texture: 0,
      texSize: vec4.create(),
      time: 0
    };
  }
  onPropertyChanged(t, r) {
    if (t == "code") {
      var s = this.getShader();
      if (s) {
        var a = s.uniformInfo;
        if (this.inputs) {
          var o = {};
          for (let c = 0; c < this.inputs.length; ++c) {
            let d = this.getInputInfo(c);
            if (d) {
              if (a[d.name] && !o[d.name]) {
                o[d.name] = !0;
                continue;
              }
              this.removeInput(c), c--;
            }
          }
        }
        for (let c in a) {
          let d = s.uniformInfo[c];
          if (d.loc !== null && c != "time") {
            var u = "number";
            if (this._shader.samplers[c])
              u = "texture";
            else
              switch (d.size) {
                case 1:
                  u = "number";
                  break;
                case 2:
                  u = "vec2";
                  break;
                case 3:
                  u = "vec3";
                  break;
                case 4:
                  u = "vec4";
                  break;
                case 9:
                  u = "mat3";
                  break;
                case 16:
                  u = "mat4";
                  break;
                default:
                  continue;
              }
            var h = this.findInputSlot(c);
            if (h == -1) {
              this.addInput(c, u);
              continue;
            }
            var l = this.getInputInfo(h);
            if (!l)
              this.addInput(c, u);
            else {
              if (l.type == u)
                continue;
              this.removeInput(h, u), this.addInput(c, u);
            }
          }
        }
      }
    }
  }
  getShader() {
    if (this._shader && this._shader_code == this.properties.code)
      return this._shader;
    if (this._shader_code = this.properties.code, this._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      this.properties.code
    ), this._shader)
      this.boxcolor = "green";
    else
      return this.boxcolor = "red", null;
    return this._shader;
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getShader();
      if (t) {
        var r = 0, s = null;
        if (this.inputs)
          for (var a = 0; a < this.inputs.length; ++a) {
            var o = this.getInputInfo(a), u = this.getInputData(a);
            u != null && (u.constructor === GL$1.Texture && (u.bind(r), s || (s = u), u = r, r++), t.setUniform(o.name, u));
          }
        var h = this._uniforms, l = LGraphTexture.getTextureType(
          this.properties.precision,
          s
        ), c = this.properties.width | 0, d = this.properties.height | 0;
        c == 0 && (c = s ? s.width : gl$1.canvas.width), d == 0 && (d = s ? s.height : gl$1.canvas.height), h.texSize[0] = c, h.texSize[1] = d, h.texSize[2] = 1 / c, h.texSize[3] = 1 / d, h.time = this.graph.getTime(), h.u_value = this.properties.u_value, h.u_color.set(this.properties.u_color), (!this._tex || this._tex.type != l || this._tex.width != c || this._tex.height != d) && (this._tex = new GL$1.Texture(c, d, {
          type: l,
          format: gl$1.RGBA,
          filter: gl$1.LINEAR
        }));
        var f = this._tex;
        f.drawTo(function() {
          t.uniforms(h).draw(GL$1.Mesh.getScreenQuad());
        }), this.setOutputData(0, this._tex);
      }
    }
  }
};
g(he, "title", "Shader"), g(he, "desc", "Texture shader"), g(he, "widgets_info", {
  code: { type: "code", lang: "glsl" },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(he, "pixel_shader", `
        precision highp float;
    
        varying vec2 v_coord;
        uniform float time; // time in seconds
        uniform vec4 texSize; // tex resolution
        uniform float u_value;
        uniform vec4 u_color;
    
        void main() {
            vec2 uv = v_coord;
            vec3 color = vec3(0.0);
            // Your custom code here
            color.xy = uv;
    
            gl_FragColor = vec4(color, 1.0);
        }
    `);
let LGraphTextureShader = he;
LiteGraph.registerNodeType("texture/shader", LGraphTextureShader);
const le = class le {
  constructor() {
    this.addInput("in", "Texture"), this.addInput("scale", "vec2"), this.addInput("offset", "vec2"), this.addOutput("out", "Texture"), this.properties = {
      offset: vec2.fromValues(0, 0),
      scale: vec2.fromValues(1, 1),
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!(!this.isOutputConnected(0) || !t)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      var r = t.width, s = t.height, a = this.precision === LGraphTexture.LOW ? gl$1.UNSIGNED_BYTE : gl$1.HIGH_PRECISION_FORMAT;
      this.precision === LGraphTexture.DEFAULT && (a = t.type), (!this._tex || this._tex.width != r || this._tex.height != s || this._tex.type != a) && (this._tex = new GL$1.Texture(r, s, {
        type: a,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var o = this._shader;
      o || (o = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        le.pixel_shader
      ));
      var u = this.getInputData(1);
      u ? (this.properties.scale[0] = u[0], this.properties.scale[1] = u[1]) : u = this.properties.scale;
      var h = this.getInputData(2);
      h ? (this.properties.offset[0] = h[0], this.properties.offset[1] = h[1]) : h = this.properties.offset, this._tex.drawTo(function() {
        gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.CULL_FACE), gl$1.disable(gl$1.BLEND), t.bind(0);
        var l = Mesh.getScreenQuad();
        o.uniforms({
          u_texture: 0,
          u_scale: u,
          u_offset: h
        }).draw(l);
      }), this.setOutputData(0, this._tex);
    }
  }
};
g(le, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(le, "title", "Scale/Offset"), g(le, "desc", "Applies an scaling and offseting"), g(le, "pixel_shader", `
        precision highp float;
    
        uniform sampler2D u_texture;
        uniform sampler2D u_textureB;
        varying vec2 v_coord;
        uniform vec2 u_scale;
        uniform vec2 u_offset;
    
        void main() {
            vec2 uv = v_coord;
            uv = uv / u_scale - u_offset;
            gl_FragColor = texture2D(u_texture, uv);
        }
    `);
let LGraphTextureScaleOffset = le;
LiteGraph.registerNodeType("texture/scaleOffset", LGraphTextureScaleOffset);
const be = class be {
  constructor() {
    g(this, "pixel_shader", `
        precision highp float;
    
        uniform sampler2D u_texture;
        uniform sampler2D u_textureB;
        varying vec2 v_coord;
        uniform float u_factor;
        uniform vec2 u_scale;
        uniform vec2 u_offset;
    
        void main() {
            vec2 uv = v_coord;
            uv += (texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;
            gl_FragColor = texture2D(u_texture, uv);
        }
    `);
    this.addInput("in", "Texture"), this.addInput("warp", "Texture"), this.addInput("factor", "number"), this.addOutput("out", "Texture"), this.properties = {
      factor: 0.01,
      scale: [1, 1],
      offset: [0, 0],
      precision: LGraphTexture.DEFAULT
    }, this._uniforms = {
      u_texture: 0,
      u_textureB: 1,
      u_factor: 1,
      u_scale: vec2.create(),
      u_offset: vec2.create()
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      var r = this.getInputData(1), s = 512, a = 512;
      t ? (s = t.width, a = t.height) : r && (s = r.width, a = r.height), !t && !this._tex ? this._tex = new GL$1.Texture(s, a, {
        type: this.precision === LGraphTexture.LOW ? gl$1.UNSIGNED_BYTE : gl$1.HIGH_PRECISION_FORMAT,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }) : this._tex = LGraphTexture.getTargetTexture(
        t || this._tex,
        this._tex,
        this.properties.precision
      );
      var o = this._shader;
      o || (o = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        be.pixel_shader
      ));
      var u = this.getInputData(2);
      u != null ? this.properties.factor = u : u = parseFloat(this.properties.factor);
      var h = this._uniforms;
      h.u_factor = u, h.u_scale.set(this.properties.scale), h.u_offset.set(this.properties.offset), this._tex.drawTo(function() {
        gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.CULL_FACE), gl$1.disable(gl$1.BLEND), t && t.bind(0), r && r.bind(1);
        var l = Mesh.getScreenQuad();
        o.uniforms(h).draw(l);
      }), this.setOutputData(0, this._tex);
    }
  }
};
g(be, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(be, "title", "Warp"), g(be, "desc", "Texture warp operation");
let LGraphTextureWarp = be;
LiteGraph.registerNodeType("texture/warp", LGraphTextureWarp);
const ut = class ut {
  constructor() {
    this.addInput("Texture", "Texture"), this.properties = {
      additive: !1,
      antialiasing: !1,
      filter: !0,
      disable_alpha: !1,
      gamma: 1,
      viewport: [0, 0, 1, 1]
    }, this.size[0] = 130;
  }
  onDrawBackground(t) {
    if (!(this.flags.collapsed || this.size[1] <= 40)) {
      var r = this.getInputData(0);
      r && t.drawImage(
        t == gl$1 ? r : gl$1.canvas,
        10,
        30,
        this.size[0] - 20,
        this.size[1] - 40
      );
    }
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      this.properties.disable_alpha ? gl$1.disable(gl$1.BLEND) : (gl$1.enable(gl$1.BLEND), this.properties.additive ? gl$1.blendFunc(gl$1.SRC_ALPHA, gl$1.ONE) : gl$1.blendFunc(gl$1.SRC_ALPHA, gl$1.ONE_MINUS_SRC_ALPHA)), gl$1.disable(gl$1.DEPTH_TEST);
      var r = this.properties.gamma || 1;
      this.isInputConnected(1) && (r = this.getInputData(1)), t.setParameter(
        gl$1.TEXTURE_MAG_FILTER,
        this.properties.filter ? gl$1.LINEAR : gl$1.NEAREST
      );
      var s = ut._prev_viewport;
      s.set(gl$1.viewport_data);
      var a = this.properties.viewport;
      if (gl$1.viewport(
        s[0] + s[2] * a[0],
        s[1] + s[3] * a[1],
        s[2] * a[2],
        s[3] * a[3]
      ), this.properties.antialiasing) {
        ut._shader || (ut._shader = new GL$1.Shader(
          GL$1.Shader.SCREEN_VERTEX_SHADER,
          ut.aa_pixel_shader
        ));
        var o = Mesh.getScreenQuad();
        t.bind(0), ut._shader.uniforms({
          u_texture: 0,
          uViewportSize: [t.width, t.height],
          u_igamma: 1 / r,
          inverseVP: [1 / t.width, 1 / t.height]
        }).draw(o);
      } else
        r != 1 ? (ut._gamma_shader || (ut._gamma_shader = new GL$1.Shader(
          Shader.SCREEN_VERTEX_SHADER,
          ut.gamma_pixel_shader
        )), t.toViewport(ut._gamma_shader, {
          u_texture: 0,
          u_igamma: 1 / r
        })) : t.toViewport();
      gl$1.viewport(
        s[0],
        s[1],
        s[2],
        s[3]
      );
    }
  }
  onGetInputs() {
    return [["gamma", "number"]];
  }
};
g(ut, "title", "to Viewport"), g(ut, "desc", "Texture to viewport"), g(ut, "_prev_viewport", new Float32Array(4)), g(ut, "aa_pixel_shader", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 uViewportSize;
        uniform vec2 inverseVP;
        uniform float u_igamma;
        #define FXAA_REDUCE_MIN   (1.0/128.0)
        #define FXAA_REDUCE_MUL   (1.0/8.0)
        #define FXAA_SPAN_MAX     8.0
    
        vec4 applyFXAA(sampler2D tex, vec2 fragCoord) {
            vec4 color = vec4(0.0);
            vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;
            vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;
            vec3 rgbM  = texture2D(tex, fragCoord * inverseVP).xyz;
            vec3 luma = vec3(0.299, 0.587, 0.114);
            
            // Rest of the FXAA algorithm
            
            return color;
        }
    
        void main() {
            gl_FragColor = applyFXAA(u_texture, v_coord * uViewportSize);
        }
    `), g(ut, "gamma_pixel_shader", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_igamma;
    
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            color.xyz = pow(color.xyz, vec3(u_igamma));
            gl_FragColor = color;
        }
    `);
let LGraphTextureToViewport = ut;
LiteGraph.registerNodeType("texture/toviewport", LGraphTextureToViewport);
class LGraphTextureCopy {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("", "Texture"), this.properties = {
      size: 0,
      generate_mipmaps: !1,
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!(!t && !this._temp_texture) && this.isOutputConnected(0)) {
      if (t) {
        var r = t.width, s = t.height;
        this.properties.size != 0 && (r = this.properties.size, s = this.properties.size);
        var a = this._temp_texture, o = t.type;
        if (this.properties.precision === LGraphTexture.LOW ? o = gl$1.UNSIGNED_BYTE : this.properties.precision === LGraphTexture.HIGH && (o = gl$1.HIGH_PRECISION_FORMAT), !a || a.width != r || a.height != s || a.type != o) {
          var u = gl$1.LINEAR;
          this.properties.generate_mipmaps && GL$1.isPowerOfTwo(r) && GL$1.isPowerOfTwo(s) && (u = gl$1.LINEAR_MIPMAP_LINEAR), this._temp_texture = new GL$1.Texture(r, s, {
            type: o,
            format: gl$1.RGBA,
            minFilter: u,
            magFilter: gl$1.LINEAR
          });
        }
        t.copyTo(this._temp_texture), this.properties.generate_mipmaps && (this._temp_texture.bind(0), gl$1.generateMipmap(this._temp_texture.texture_type), this._temp_texture.unbind(0));
      }
      this.setOutputData(0, this._temp_texture);
    }
  }
}
g(LGraphTextureCopy, "title", "Copy"), g(LGraphTextureCopy, "desc", "Copy Texture"), g(LGraphTextureCopy, "widgets_info", {
  size: {
    widget: "combo",
    values: [0, 32, 64, 128, 256, 512, 1024, 2048]
  },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
});
LiteGraph.registerNodeType("texture/copy", LGraphTextureCopy);
const Ht = class Ht {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("", "Texture"), this.properties = {
      iterations: 1,
      generate_mipmaps: !1,
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!(!t && !this._temp_texture) && this.isOutputConnected(0) && !(!t || t.texture_type !== GL$1.TEXTURE_2D)) {
      if (this.properties.iterations < 1) {
        this.setOutputData(0, t);
        return;
      }
      var r = Ht._shader;
      r || (Ht._shader = r = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        Ht.pixel_shader
      ));
      var s = t.width | 0, a = t.height | 0, o = t.type;
      this.properties.precision === LGraphTexture.LOW ? o = gl$1.UNSIGNED_BYTE : this.properties.precision === LGraphTexture.HIGH && (o = gl$1.HIGH_PRECISION_FORMAT);
      var u = this.properties.iterations || 1, h = t, l = null, c = [], d = {
        type: o,
        format: t.format
      }, f = vec2.create(), _ = { u_offset: f };
      this._texture && GL$1.Texture.releaseTemporary(this._texture);
      for (let E = 0; E < u && (f[0] = 1 / s, f[1] = 1 / a, s = s >> 1 || 0, a = a >> 1 || 0, l = GL$1.Texture.getTemporary(s, a, d), c.push(l), h.setParameter(GL$1.TEXTURE_MAG_FILTER, GL$1.NEAREST), h.copyTo(l, r, _), !(s == 1 && a == 1)); ++E)
        h = l;
      this._texture = c.pop();
      for (let E = 0; E < c.length; ++E)
        GL$1.Texture.releaseTemporary(c[E]);
      this.properties.generate_mipmaps && (this._texture.bind(0), gl$1.generateMipmap(this._texture.texture_type), this._texture.unbind(0)), this.setOutputData(0, this._texture);
    }
  }
};
g(Ht, "title", "Downsample"), g(Ht, "desc", "Downsample Texture"), g(Ht, "widgets_info", {
  iterations: { type: "number", step: 1, precision: 0, min: 0 },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(Ht, "pixel_shader", `
        precision highp float;
        uniform sampler2D u_texture;
        uniform vec2 u_offset;
        varying vec2 v_coord;
    
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            color += texture2D(u_texture, v_coord + vec2(u_offset.x, 0.0));
            color += texture2D(u_texture, v_coord + vec2(0.0, u_offset.y));
            color += texture2D(u_texture, v_coord + u_offset);
            gl_FragColor = color * 0.25;
        }
    `);
let LGraphTextureDownsample = Ht;
LiteGraph.registerNodeType("texture/downsample", LGraphTextureDownsample);
class LGraphTextureResize {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("", "Texture"), this.properties = {
      size: [512, 512],
      generate_mipmaps: !1,
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!(!t && !this._temp_texture) && this.isOutputConnected(0) && !(!t || t.texture_type !== GL$1.TEXTURE_2D)) {
      var r = this.properties.size[0] | 0, s = this.properties.size[1] | 0;
      r == 0 && (r = t.width), s == 0 && (s = t.height);
      var a = t.type;
      this.properties.precision === LGraphTexture.LOW ? a = gl$1.UNSIGNED_BYTE : this.properties.precision === LGraphTexture.HIGH && (a = gl$1.HIGH_PRECISION_FORMAT), (!this._texture || this._texture.width != r || this._texture.height != s || this._texture.type != a) && (this._texture = new GL$1.Texture(r, s, { type: a })), t.copyTo(this._texture), this.properties.generate_mipmaps && (this._texture.bind(0), gl$1.generateMipmap(this._texture.texture_type), this._texture.unbind(0)), this.setOutputData(0, this._texture);
    }
  }
}
g(LGraphTextureResize, "title", "Resize"), g(LGraphTextureResize, "desc", "Resize Texture"), g(LGraphTextureResize, "widgets_info", {
  iterations: { type: "number", step: 1, precision: 0, min: 0 },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
});
LiteGraph.registerNodeType("texture/resize", LGraphTextureResize);
const Dt = class Dt {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("tex", "Texture"), this.addOutput("avg", "vec4"), this.addOutput("lum", "number"), this.properties = {
      use_previous_frame: !0,
      // to avoid stalls
      high_quality: !1
      // to use as much pixels as possible
    }, this._uniforms = {
      u_texture: 0,
      u_mipmap_offset: 0
    }, this._luminance = new Float32Array(4);
  }
  onExecute() {
    this.properties.use_previous_frame || this.updateAverage();
    var t = this._luminance;
    this.setOutputData(0, this._temp_texture), this.setOutputData(1, t), this.setOutputData(2, (t[0] + t[1] + t[2]) / 3);
  }
  // executed before rendering the frame
  onPreRenderExecute() {
    this.updateAverage();
  }
  updateAverage() {
    var t = this.getInputData(0);
    if (t && !(!this.isOutputConnected(0) && !this.isOutputConnected(1) && !this.isOutputConnected(2))) {
      if (!Dt._shader) {
        Dt._shader = new GL$1.Shader(
          GL$1.Shader.SCREEN_VERTEX_SHADER,
          Dt.pixel_shader
        );
        for (var r = new Float32Array(16), s = 0; s < r.length; ++s)
          r[s] = Math.random();
        Dt._shader.uniforms({
          u_samples_a: r.subarray(0, 16),
          u_samples_b: r.subarray(16, 32)
        });
      }
      var a = this._temp_texture, o = gl$1.UNSIGNED_BYTE;
      t.type != o && (o = gl$1.FLOAT), (!a || a.type != o) && (this._temp_texture = new GL$1.Texture(1, 1, {
        type: o,
        format: gl$1.RGBA,
        filter: gl$1.NEAREST
      })), this._uniforms.u_mipmap_offset = 0, this.properties.high_quality && ((!this._temp_pot2_texture || this._temp_pot2_texture.type != o) && (this._temp_pot2_texture = new GL$1.Texture(512, 512, {
        type: o,
        format: gl$1.RGBA,
        minFilter: gl$1.LINEAR_MIPMAP_LINEAR,
        magFilter: gl$1.LINEAR
      })), t.copyTo(this._temp_pot2_texture), t = this._temp_pot2_texture, t.bind(0), gl$1.generateMipmap(GL$1.TEXTURE_2D), this._uniforms.u_mipmap_offset = 9);
      var u = Dt._shader, h = this._uniforms;
      if (h.u_mipmap_offset = this.properties.mipmap_offset, gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.BLEND), this._temp_texture.drawTo(function() {
        t.toViewport(u, h);
      }), this.isOutputConnected(1) || this.isOutputConnected(2)) {
        var l = this._temp_texture.getPixels();
        if (l) {
          var c = this._luminance;
          o = this._temp_texture.type, c.set(l), o == gl$1.UNSIGNED_BYTE ? vec4.scale(c, c, 1 / 255) : o == GL$1.HALF_FLOAT || o == GL$1.HALF_FLOAT_OES;
        }
      }
    }
  }
};
g(Dt, "title", "Average"), g(Dt, "desc", `Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.
 If high_quality is true, then it generates the mipmaps first and reads from the lower one.`), g(Dt, "pixel_shader", `
        precision highp float;
        uniform mat4 u_samples_a;
        uniform mat4 u_samples_b;
        uniform sampler2D u_texture;
        uniform float u_mipmap_offset;
        varying vec2 v_coord;
    
        void main() {
            vec4 color = vec4(0.0);
            
            // Random average
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    color += texture2D(u_texture, vec2(u_samples_a[i][j], u_samples_b[i][j]), u_mipmap_offset);
                    color += texture2D(u_texture, vec2(1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j]), u_mipmap_offset);
                }
            }
            
            gl_FragColor = color * 0.03125;
        }
    `);
let LGraphTextureAverage = Dt;
LiteGraph.registerNodeType("texture/average", LGraphTextureAverage);
const Vt = class Vt {
  constructor() {
    this.addInput("in", "Texture"), this.addInput("factor", "Number"), this.addOutput("out", "Texture"), this.properties = { factor: 0.5 }, this._uniforms = {
      u_texture: 0,
      u_textureB: 1,
      u_factor: this.properties.factor
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!(!t || !this.isOutputConnected(0))) {
      Vt._shader || (Vt._shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        Vt.pixel_shader
      ));
      var r = this._temp_texture;
      if (!r || r.type != t.type || r.width != t.width || r.height != t.height) {
        var s = {
          type: t.type,
          format: gl$1.RGBA,
          filter: gl$1.NEAREST
        };
        this._temp_texture = new GL$1.Texture(t.width, t.height, s), this._temp_texture2 = new GL$1.Texture(
          t.width,
          t.height,
          s
        ), t.copyTo(this._temp_texture2);
      }
      var a = this._temp_texture, o = this._temp_texture2, u = Vt._shader, h = this._uniforms;
      h.u_factor = 1 - this.getInputOrProperty("factor"), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST), a.drawTo(function() {
        o.bind(1), t.toViewport(u, h);
      }), this.setOutputData(0, a), this._temp_texture = o, this._temp_texture2 = a;
    }
  }
};
g(Vt, "title", "Smooth"), g(Vt, "desc", "Smooth texture over time"), g(Vt, "pixel_shader", `precision highp float;
    precision highp float;
    uniform sampler2D u_texture;
    uniform sampler2D u_textureB;
    uniform float u_factor;
    varying vec2 v_coord;
    
    void main() {
        gl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );
    }
    `);
let LGraphTextureTemporalSmooth = Vt;
LiteGraph.registerNodeType("texture/temporal_smooth", LGraphTextureTemporalSmooth);
const dt = class dt {
  constructor() {
    this.addInput("in", "Texture"), this.addOutput("avg", "Texture"), this.addOutput("array", "Texture"), this.properties = { samples: 64, frames_interval: 1 }, this._uniforms = {
      u_texture: 0,
      u_textureB: 1,
      u_samples: this.properties.samples,
      u_isamples: 1 / this.properties.samples
    }, this.frame = 0;
  }
  getPreviewTexture() {
    return this._temp_texture2;
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!(!t || !this.isOutputConnected(0))) {
      dt._shader || (dt._shader_copy = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        dt.pixel_shader_copy
      ), dt._shader_avg = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        dt.pixel_shader_avg
      ));
      var r = clamp(this.properties.samples, 0, 64), s = this.frame, a = this.properties.frames_interval;
      if (a == 0 || s % a == 0) {
        var o = this._temp_texture;
        if (!o || o.type != t.type || o.width != r) {
          var u = {
            type: t.type,
            format: gl$1.RGBA,
            filter: gl$1.NEAREST
          };
          this._temp_texture = new GL$1.Texture(r, 1, u), this._temp_texture2 = new GL$1.Texture(r, 1, u), this._temp_texture_out = new GL$1.Texture(1, 1, u);
        }
        var h = this._temp_texture, l = this._temp_texture2, c = dt._shader_copy, d = dt._shader_avg, f = this._uniforms;
        f.u_samples = r, f.u_isamples = 1 / r, gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST), h.drawTo(function() {
          l.bind(1), t.toViewport(c, f);
        }), this._temp_texture_out.drawTo(function() {
          h.toViewport(d, f);
        }), this.setOutputData(0, this._temp_texture_out), this._temp_texture = l, this._temp_texture2 = h;
      } else this.setOutputData(0, this._temp_texture_out);
      this.setOutputData(1, this._temp_texture2), this.frame++;
    }
  }
};
g(dt, "title", "Lineal Avg Smooth"), g(dt, "desc", "Smooth texture linearly over time"), g(dt, "@samples", {
  type: "number",
  min: 1,
  max: 64,
  step: 1,
  precision: 1
}), g(dt, "pixel_shader_copy", `precision highp float;
    precision highp float;
    uniform sampler2D u_texture;
    uniform sampler2D u_textureB;
    uniform float u_isamples;
    varying vec2 v_coord;
    
    void main() {
        if( v_coord.x <= u_isamples )
            gl_FragColor = texture2D( u_texture, vec2(0.5) );
        else
            gl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );
    }
    `), g(dt, "pixel_shader_avg", `precision highp float;
    precision highp float;
    uniform sampler2D u_texture;
    uniform int u_samples;
    uniform float u_isamples;
    varying vec2 v_coord;
    
    void main() {
        vec4 color = vec4(0.0);
        for(int i = 0; i < 64; ++i)
        {
            color += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );
            if(i == (u_samples - 1))
                break;
        }
        gl_FragColor = color * u_isamples;
    }
    `);
let LGraphTextureLinearAvgSmooth = dt;
LiteGraph.registerNodeType("texture/linear_avg_smooth", LGraphTextureLinearAvgSmooth);
class LGraphImageToTexture {
  constructor() {
    this.addInput("Image", "image"), this.addOutput("", "Texture"), this.properties = {};
  }
  // LGraphImageToTexture.widgets_info = { size: { widget:"combo", values:[0,32,64,128,256,512,1024,2048]} };
  onExecute() {
    var o;
    var t = this.getInputData(0);
    if (t) {
      var r = t.videoWidth || t.width, s = t.videoHeight || t.height;
      if (t.gltexture) {
        this.setOutputData(0, t.gltexture);
        return;
      }
      var a = this._temp_texture;
      (!a || a.width != r || a.height != s) && (this._temp_texture = new GL$1.Texture(r, s, {
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      try {
        this._temp_texture.uploadImage(t);
      } catch (u) {
        (o = console.error) == null || o.call(console, "image comes from an unsafe location, cannot be uploaded to webgl: " + u);
        return;
      }
      this.setOutputData(0, this._temp_texture);
    }
  }
}
g(LGraphImageToTexture, "title", "Image to Texture"), g(LGraphImageToTexture, "desc", "Uploads an image to the GPU");
LiteGraph.registerNodeType("texture/imageToTexture", LGraphImageToTexture);
const St = class St {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("LUT", "Texture"), this.addInput("Intensity", "number"), this.addOutput("", "Texture"), this.properties = {
      enabled: !0,
      intensity: 1,
      precision: LGraphTexture.DEFAULT,
      texture: null
    }, St._shader || (St._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      St.pixel_shader
    ));
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === !1) {
        this.setOutputData(0, t);
        return;
      }
      if (t) {
        var r = this.getInputData(1);
        if (r || (r = LGraphTexture.getTexture(this.properties.texture)), !r) {
          this.setOutputData(0, t);
          return;
        }
        r.bind(0), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_MIN_FILTER, gl$1.LINEAR), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_WRAP_S, gl$1.CLAMP_TO_EDGE), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_WRAP_T, gl$1.CLAMP_TO_EDGE), gl$1.bindTexture(gl$1.TEXTURE_2D, null);
        var s = this.properties.intensity;
        this.isInputConnected(2) && (this.properties.intensity = s = this.getInputData(2)), this._tex = LGraphTexture.getTargetTexture(
          t,
          this._tex,
          this.properties.precision
        ), this._tex.drawTo(function() {
          r.bind(1), t.toViewport(St._shader, {
            u_texture: 0,
            u_textureB: 1,
            u_amount: s
          });
        }), this.setOutputData(0, this._tex);
      }
    }
  }
};
g(St, "widgets_info", {
  texture: { widget: "texture" },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(St, "title", "LUT"), g(St, "desc", "Apply LUT to Texture"), g(St, "pixel_shader", `precision highp float;
    precision highp float;
    varying vec2 v_coord;
    uniform sampler2D u_texture;
    uniform sampler2D u_textureB;
    uniform float u_amount;
    
    void main() {
            lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );
            mediump float blueColor = textureColor.b * 63.0;
            mediump vec2 quad1;
            quad1.y = floor(floor(blueColor) / 8.0);
            quad1.x = floor(blueColor) - (quad1.y * 8.0);
            mediump vec2 quad2;
            quad2.y = floor(ceil(blueColor) / 8.0);
            quad2.x = ceil(blueColor) - (quad2.y * 8.0);
            highp vec2 texPos1;
            texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);
            texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));
            highp vec2 texPos2;
            texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);
            texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));
            lowp vec4 newColor1 = texture2D(u_textureB, texPos1);
            lowp vec4 newColor2 = texture2D(u_textureB, texPos2);
            lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));
            gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);
    }
    `);
let LGraphTextureLUT = St;
LiteGraph.registerNodeType("texture/LUT", LGraphTextureLUT);
const Ct = class Ct {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("Atlas", "Texture"), this.addOutput("", "Texture"), this.properties = {
      enabled: !0,
      num_row_symbols: 4,
      symbol_size: 16,
      brightness: 1,
      colorize: !1,
      filter: !1,
      invert: !1,
      precision: LGraphTexture.DEFAULT,
      generate_mipmaps: !1,
      texture: null
    }, Ct._shader || (Ct._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      Ct.pixel_shader
    )), this._uniforms = {
      u_texture: 0,
      u_textureB: 1,
      u_row_simbols: 4,
      u_simbol_size: 16,
      u_res: vec2.create()
    };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.properties.enabled === !1) {
        this.setOutputData(0, t);
        return;
      }
      if (t) {
        var r = this.getInputData(1);
        if (r || (r = LGraphTexture.getTexture(this.properties.texture)), !r) {
          this.setOutputData(0, t);
          return;
        }
        r.bind(0), gl$1.texParameteri(
          gl$1.TEXTURE_2D,
          gl$1.TEXTURE_MAG_FILTER,
          this.properties.filter ? gl$1.LINEAR : gl$1.NEAREST
        ), gl$1.texParameteri(
          gl$1.TEXTURE_2D,
          gl$1.TEXTURE_MIN_FILTER,
          this.properties.filter ? gl$1.LINEAR : gl$1.NEAREST
        ), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_WRAP_S, gl$1.CLAMP_TO_EDGE), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_WRAP_T, gl$1.CLAMP_TO_EDGE), gl$1.bindTexture(gl$1.TEXTURE_2D, null);
        var s = this._uniforms;
        s.u_row_simbols = Math.floor(this.properties.num_row_symbols), s.u_symbol_size = this.properties.symbol_size, s.u_brightness = this.properties.brightness, s.u_invert = this.properties.invert ? 1 : 0, s.u_colorize = this.properties.colorize ? 1 : 0, this._tex = LGraphTexture.getTargetTexture(
          t,
          this._tex,
          this.properties.precision
        ), s.u_res[0] = this._tex.width, s.u_res[1] = this._tex.height, this._tex.bind(0), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_MAG_FILTER, gl$1.NEAREST), gl$1.texParameteri(gl$1.TEXTURE_2D, gl$1.TEXTURE_MIN_FILTER, gl$1.NEAREST), this._tex.drawTo(function() {
          r.bind(1), t.toViewport(Ct._shader, s);
        }), this.properties.generate_mipmaps && (this._tex.bind(0), gl$1.generateMipmap(this._tex.texture_type), this._tex.unbind(0)), this.setOutputData(0, this._tex);
      }
    }
  }
};
g(Ct, "widgets_info", {
  texture: { widget: "texture" },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(Ct, "title", "Encode"), g(Ct, "desc", "Apply a texture atlas to encode a texture"), g(Ct, "pixel_shader", `precision highp float;
    precision highp float;
    varying vec2 v_coord;
    uniform sampler2D u_texture;
    uniform sampler2D u_textureB;
    uniform float u_row_simbols;
    uniform float u_symbol_size;
    uniform float u_brightness;
    uniform float u_invert;
    uniform float u_colorize;
    uniform vec2 u_res;
    
    void main() {
        vec2 total_symbols = u_res / u_symbol_size;
        vec2 uv = floor(v_coord * total_symbols) / total_symbols; //pixelate 
        vec2 local_uv = mod(v_coord * u_res, u_symbol_size) / u_symbol_size;
        lowp vec4 textureColor = texture2D(u_texture, uv );
        float lum = clamp(u_brightness * (textureColor.x + textureColor.y + textureColor.z)/3.0,0.0,1.0);
        if( u_invert == 1.0 ) lum = 1.0 - lum;
        float index = floor( lum * (u_row_simbols * u_row_simbols - 1.0));
        float col = mod( index, u_row_simbols );
        float row = u_row_simbols - floor( index / u_row_simbols ) - 1.0;
        vec2 simbol_uv = ( vec2( col, row ) + local_uv ) / u_row_simbols;
        vec4 color = texture2D( u_textureB, simbol_uv );
        if(u_colorize == 1.0)
            color *= textureColor;
        gl_FragColor = color;
    }
    `);
let LGraphTextureEncode = Ct;
LiteGraph.registerNodeType("texture/encode", LGraphTextureEncode);
const Xt = class Xt {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("R", "Texture"), this.addOutput("G", "Texture"), this.addOutput("B", "Texture"), this.addOutput("A", "Texture"), Xt._shader || (Xt._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      Xt.pixel_shader
    ));
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      this._channels || (this._channels = Array(4));
      var r = gl$1.RGB, s = 0;
      for (let h = 0; h < 4; h++)
        this.isOutputConnected(h) ? ((!this._channels[h] || this._channels[h].width != t.width || this._channels[h].height != t.height || this._channels[h].type != t.type || this._channels[h].format != r) && (this._channels[h] = new GL$1.Texture(
          t.width,
          t.height,
          {
            type: t.type,
            format: r,
            filter: gl$1.LINEAR
          }
        )), s++) : this._channels[h] = null;
      if (s) {
        gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
        var a = Mesh.getScreenQuad(), o = Xt._shader, u = [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1]
        ];
        for (let h = 0; h < 4; h++)
          this._channels[h] && (this._channels[h].drawTo(function() {
            t.bind(0), o.uniforms({ u_texture: 0, u_mask: u[h] }).draw(a);
          }), this.setOutputData(h, this._channels[h]));
      }
    }
  }
};
g(Xt, "title", "Texture to Channels"), g(Xt, "desc", "Split texture channels"), g(Xt, "pixel_shader", `precision highp float;
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec4 u_mask;
        
        void main() {
            gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );
        }
        `);
let LGraphTextureChannels = Xt;
LiteGraph.registerNodeType("texture/textureChannels", LGraphTextureChannels);
const Nt = class Nt {
  constructor() {
    this.addInput("R", "Texture"), this.addInput("G", "Texture"), this.addInput("B", "Texture"), this.addInput("A", "Texture"), this.addOutput("Texture", "Texture"), this.properties = {
      precision: LGraphTexture.DEFAULT,
      R: 1,
      G: 1,
      B: 1,
      A: 1
    }, this._color = vec4.create(), this._uniforms = {
      u_textureR: 0,
      u_textureG: 1,
      u_textureB: 2,
      u_textureA: 3,
      u_color: this._color
    };
  }
  onExecute() {
    var t = LGraphTexture.getWhiteTexture(), r = this.getInputData(0) || t, s = this.getInputData(1) || t, a = this.getInputData(2) || t, o = this.getInputData(3) || t;
    gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
    var u = Mesh.getScreenQuad();
    Nt._shader || (Nt._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      Nt.pixel_shader
    ));
    var h = Nt._shader, l = Math.max(r.width, s.width, a.width, o.width), c = Math.max(r.height, s.height, a.height, o.height), d = this.properties.precision == LGraphTexture.HIGH ? LGraphTexture.HIGH_PRECISION_FORMAT : gl$1.UNSIGNED_BYTE;
    (!this._texture || this._texture.width != l || this._texture.height != c || this._texture.type != d) && (this._texture = new GL$1.Texture(l, c, {
      type: d,
      format: gl$1.RGBA,
      filter: gl$1.LINEAR
    }));
    var f = this._color;
    f[0] = this.properties.R, f[1] = this.properties.G, f[2] = this.properties.B, f[3] = this.properties.A;
    var _ = this._uniforms;
    this._texture.drawTo(function() {
      r.bind(0), s.bind(1), a.bind(2), o.bind(3), h.uniforms(_).draw(u);
    }), this.setOutputData(0, this._texture);
  }
};
g(Nt, "title", "Channels to Texture"), g(Nt, "desc", "Split texture channels"), g(Nt, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(Nt, "pixel_shader", `precision highp float;
    precision highp float;
    varying vec2 v_coord;
    uniform sampler2D u_textureR;
    uniform sampler2D u_textureG;
    uniform sampler2D u_textureB;
    uniform sampler2D u_textureA;
    uniform vec4 u_color;
    
    void main() {
        gl_FragColor = u_color * vec4(                 texture2D(u_textureR, v_coord).r,                texture2D(u_textureG, v_coord).r,                texture2D(u_textureB, v_coord).r,                texture2D(u_textureA, v_coord).r);
    }
    `);
let LGraphChannelsTexture = Nt;
LiteGraph.registerNodeType("texture/channelsTexture", LGraphChannelsTexture);
class LGraphTextureColor {
  constructor() {
    this.addOutput("Texture", "Texture"), this._tex_color = vec4.create(), this.properties = {
      color: vec4.create(),
      precision: LGraphTexture.DEFAULT
    };
  }
  onDrawBackground(t) {
    var r = this.properties.color;
    t.fillStyle = "rgb(" + Math.floor(clamp(r[0], 0, 1) * 255) + "," + Math.floor(clamp(r[1], 0, 1) * 255) + "," + Math.floor(clamp(r[2], 0, 1) * 255) + ")", this.flags.collapsed ? this.boxcolor = t.fillStyle : t.fillRect(0, 0, this.size[0], this.size[1]);
  }
  onExecute() {
    var t = this.properties.precision == LGraphTexture.HIGH ? LGraphTexture.HIGH_PRECISION_FORMAT : gl$1.UNSIGNED_BYTE;
    (!this._tex || this._tex.type != t) && (this._tex = new GL$1.Texture(1, 1, {
      format: gl$1.RGBA,
      type: t,
      minFilter: gl$1.NEAREST
    }));
    var r = this.properties.color;
    if (this.inputs)
      for (var s = 0; s < this.inputs.length; s++) {
        var a = this.inputs[s], o = this.getInputData(s);
        if (o !== void 0)
          switch (a.name) {
            case "RGB":
            case "RGBA":
              r.set(o);
              break;
            case "R":
              r[0] = o;
              break;
            case "G":
              r[1] = o;
              break;
            case "B":
              r[2] = o;
              break;
            case "A":
              r[3] = o;
              break;
          }
      }
    vec4.sqrDist(this._tex_color, r) > 1e-3 && (this._tex_color.set(r), this._tex.fill(r)), this.setOutputData(0, this._tex);
  }
  onGetInputs() {
    return [
      ["RGB", "vec3"],
      ["RGBA", "vec4"],
      ["R", "number"],
      ["G", "number"],
      ["B", "number"],
      ["A", "number"]
    ];
  }
}
g(LGraphTextureColor, "title", "Color"), g(LGraphTextureColor, "desc", "Generates a 1x1 texture with a constant color"), g(LGraphTextureColor, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
});
LiteGraph.registerNodeType("texture/color", LGraphTextureColor);
const yt = class yt {
  constructor() {
    this.addInput("A", "color"), this.addInput("B", "color"), this.addOutput("Texture", "Texture"), this.properties = {
      angle: 0,
      scale: 1,
      A: [0, 0, 0],
      B: [1, 1, 1],
      texture_size: 32
    }, yt._shader || (yt._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      yt.pixel_shader
    )), this._uniforms = {
      u_angle: 0,
      u_colorA: vec3.create(),
      u_colorB: vec3.create()
    };
  }
  onExecute() {
    gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
    var t = GL$1.Mesh.getScreenQuad(), r = yt._shader, s = this.getInputData(0);
    s || (s = this.properties.A);
    var a = this.getInputData(1);
    a || (a = this.properties.B);
    for (var o = 2; o < this.inputs.length; o++) {
      var u = this.inputs[o], h = this.getInputData(o);
      h !== void 0 && (this.properties[u.name] = h);
    }
    var l = this._uniforms;
    this._uniforms.u_angle = this.properties.angle * DEG2RAD, this._uniforms.u_scale = this.properties.scale, vec3.copy(l.u_colorA, s), vec3.copy(l.u_colorB, a);
    var c = parseInt(this.properties.texture_size);
    (!this._tex || this._tex.width != c) && (this._tex = new GL$1.Texture(c, c, {
      format: gl$1.RGB,
      filter: gl$1.LINEAR
    })), this._tex.drawTo(function() {
      r.uniforms(l).draw(t);
    }), this.setOutputData(0, this._tex);
  }
  onGetInputs() {
    return [
      ["angle", "number"],
      ["scale", "number"]
    ];
  }
};
g(yt, "title", "Gradient"), g(yt, "desc", "Generates a gradient"), g(yt, "@A", { type: "color" }), g(yt, "@B", { type: "color" }), g(yt, "@texture_size", {
  type: "enum",
  values: [32, 64, 128, 256, 512]
}), g(yt, "pixel_shader", `precision highp float;
        precision highp float;
        varying vec2 v_coord;
        uniform float u_angle;
        uniform float u_scale;
        uniform vec3 u_colorA;
        uniform vec3 u_colorB;
        
        vec2 rotate(vec2 v, float angle)
        {
            vec2 result;
            float _cos = cos(angle);
            float _sin = sin(angle);
            result.x = v.x * _cos - v.y * _sin;
            result.y = v.x * _sin + v.y * _cos;
            return result;
        }
        void main() {
            float f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;
            vec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));
            gl_FragColor = vec4(color,1.0);
        }
        `);
let LGraphTextureGradient = yt;
LiteGraph.registerNodeType("texture/gradient", LGraphTextureGradient);
const bt = class bt {
  constructor() {
    this.addInput("A", "Texture"), this.addInput("B", "Texture"), this.addInput("Mixer", "Texture"), this.addOutput("Texture", "Texture"), this.properties = {
      factor: 0.5,
      size_from_biggest: !0,
      invert: !1,
      precision: LGraphTexture.DEFAULT
    }, this._uniforms = {
      u_textureA: 0,
      u_textureB: 1,
      u_textureMix: 2,
      u_mix: vec4.create()
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      var r = this.getInputData(1);
      if (!(!t || !r)) {
        var s = this.getInputData(2), a = this.getInputData(3);
        this._tex = LGraphTexture.getTargetTexture(
          this.properties.size_from_biggest && r.width > t.width ? r : t,
          this._tex,
          this.properties.precision
        ), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
        var o = Mesh.getScreenQuad(), u = null, h = this._uniforms;
        if (s)
          u = bt._shader_tex, u || (u = bt._shader_tex = new GL$1.Shader(
            Shader.SCREEN_VERTEX_SHADER,
            bt.pixel_shader,
            { MIX_TEX: "" }
          ));
        else {
          u = bt._shader_factor, u || (u = bt._shader_factor = new GL$1.Shader(
            Shader.SCREEN_VERTEX_SHADER,
            bt.pixel_shader
          ));
          var l = a == null ? this.properties.factor : a;
          h.u_mix.set([l, l, l, l]);
        }
        var c = this.properties.invert;
        this._tex.drawTo(function() {
          t.bind(c ? 1 : 0), r.bind(c ? 0 : 1), s && s.bind(2), u.uniforms(h).draw(o);
        }), this.setOutputData(0, this._tex);
      }
    }
  }
  onGetInputs() {
    return [["factor", "number"]];
  }
};
g(bt, "title", "Mix"), g(bt, "desc", "Generates a texture mixing two textures"), g(bt, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(bt, "pixel_shader", `precision highp float;
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_textureA;
        uniform sampler2D u_textureB;
        #ifdef MIX_TEX
            uniform sampler2D u_textureMix;
        #else
            uniform vec4 u_mix;
        #endif
        
        void main() {
            #ifdef MIX_TEX
                vec4 f = texture2D(u_textureMix, v_coord);
            #else
                vec4 f = u_mix;
            #endif
            gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );
        }
        `);
let LGraphTextureMix = bt;
LiteGraph.registerNodeType("texture/mix", LGraphTextureMix);
const Rt = class Rt {
  constructor() {
    this.addInput("Tex.", "Texture"), this.addOutput("Edges", "Texture"), this.properties = {
      invert: !0,
      threshold: !1,
      factor: 1,
      precision: LGraphTexture.DEFAULT
    }, Rt._shader || (Rt._shader = new GL$1.Shader(
      Shader.SCREEN_VERTEX_SHADER,
      Rt.pixel_shader
    ));
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      if (t) {
        this._tex = LGraphTexture.getTargetTexture(
          t,
          this._tex,
          this.properties.precision
        ), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
        var r = Mesh.getScreenQuad(), s = Rt._shader, a = this.properties.invert, o = this.properties.factor, u = this.properties.threshold ? 1 : 0;
        this._tex.drawTo(function() {
          t.bind(0), s.uniforms({
            u_texture: 0,
            u_isize: [1 / t.width, 1 / t.height],
            u_factor: o,
            u_threshold: u,
            u_invert: a ? 1 : 0
          }).draw(r);
        }), this.setOutputData(0, this._tex);
      }
    }
  }
};
g(Rt, "title", "Edges"), g(Rt, "desc", "Detects edges"), g(Rt, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(Rt, "pixel_shader", `precision highp float;
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_isize;
        uniform int u_invert;
        uniform float u_factor;
        uniform float u_threshold;
        
        void main() {
            vec4 center = texture2D(u_texture, v_coord);
            vec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );
            vec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );
            vec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );
            vec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );
            vec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);
            diff *= u_factor;
            if(u_invert == 1)
                diff.xyz = vec3(1.0) - diff.xyz;
            if( u_threshold == 0.0 )
                gl_FragColor = vec4( diff.xyz, center.a );
            else
                gl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );
        }
        `);
let LGraphTextureEdges = Rt;
LiteGraph.registerNodeType("texture/edges", LGraphTextureEdges);
const Tt = class Tt {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("Distance", "number"), this.addInput("Range", "number"), this.addOutput("Texture", "Texture"), this.properties = {
      distance: 100,
      range: 50,
      only_depth: !1,
      high_precision: !1
    }, this._uniforms = {
      u_texture: 0,
      u_distance: 100,
      u_range: 50,
      u_camera_planes: null
    };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (t) {
        var r = gl$1.UNSIGNED_BYTE;
        this.properties.high_precision && (r = gl$1.half_float_ext ? gl$1.HALF_FLOAT_OES : gl$1.FLOAT), (!this._temp_texture || this._temp_texture.type != r || this._temp_texture.width != t.width || this._temp_texture.height != t.height) && (this._temp_texture = new GL$1.Texture(t.width, t.height, {
          type: r,
          format: gl$1.RGBA,
          filter: gl$1.LINEAR
        }));
        var s = this._uniforms, a = this.properties.distance;
        this.isInputConnected(1) && (a = this.getInputData(1), this.properties.distance = a);
        var o = this.properties.range;
        this.isInputConnected(2) && (o = this.getInputData(2), this.properties.range = o), s.u_distance = a, s.u_range = o, gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
        var u = Mesh.getScreenQuad();
        Tt._shader || (Tt._shader = new GL$1.Shader(
          Shader.SCREEN_VERTEX_SHADER,
          Tt.pixel_shader
        ), Tt._shader_onlydepth = new GL$1.Shader(
          Shader.SCREEN_VERTEX_SHADER,
          Tt.pixel_shader,
          { ONLY_DEPTH: "" }
        ));
        var h = this.properties.only_depth ? Tt._shader_onlydepth : Tt._shader, l = null;
        t.near_far_planes ? l = t.near_far_planes : window.LS && LS.Renderer._main_camera ? l = LS.Renderer._main_camera._uniforms.u_camera_planes : l = [0.1, 1e3], s.u_camera_planes = l, this._temp_texture.drawTo(function() {
          t.bind(0), h.uniforms(s).draw(u);
        }), this._temp_texture.near_far_planes = l, this.setOutputData(0, this._temp_texture);
      }
    }
  }
};
g(Tt, "title", "Depth Range"), g(Tt, "desc", "Generates a texture with a depth range"), g(Tt, "pixel_shader", `precision highp float;
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform float u_distance;
        uniform float u_range;
        
        float LinearDepth()
        {
            float zNear = u_camera_planes.x;
            float zFar = u_camera_planes.y;
            float depth = texture2D(u_texture, v_coord).x;
            depth = depth * 2.0 - 1.0;
            return zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));
        }
        
        void main() {
            float depth = LinearDepth();
            #ifdef ONLY_DEPTH
                gl_FragColor = vec4(depth);
            #else
                float diff = abs(depth * u_camera_planes.y - u_distance);
                float dof = 1.0;
                if(diff <= u_range)
                    dof = diff / u_range;
                gl_FragColor = vec4(dof);
            #endif
        }
    `);
let LGraphTextureDepthRange = Tt;
LiteGraph.registerNodeType("texture/depth_range", LGraphTextureDepthRange);
const Mt = class Mt {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("Texture", "Texture"), this.properties = {
      precision: LGraphTexture.DEFAULT,
      invert: !1
    }, this._uniforms = {
      u_texture: 0,
      u_camera_planes: null,
      // filled later
      u_ires: vec2.create()
    };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (!(!t || t.format != gl$1.DEPTH_COMPONENT && t.format != gl$1.DEPTH_STENCIL)) {
        var r = this.properties.precision == LGraphTexture.HIGH ? gl$1.HIGH_PRECISION_FORMAT : gl$1.UNSIGNED_BYTE;
        (!this._temp_texture || this._temp_texture.type != r || this._temp_texture.width != t.width || this._temp_texture.height != t.height) && (this._temp_texture = new GL$1.Texture(t.width, t.height, {
          type: r,
          format: gl$1.RGB,
          filter: gl$1.LINEAR
        }));
        var s = this._uniforms;
        s.u_invert = this.properties.invert ? 1 : 0, gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
        var a = Mesh.getScreenQuad();
        Mt._shader || (Mt._shader = new GL$1.Shader(
          GL$1.Shader.SCREEN_VERTEX_SHADER,
          Mt.pixel_shader
        ));
        var o = Mt._shader, u = null;
        t.near_far_planes ? u = t.near_far_planes : window.LS && LS.Renderer._main_camera ? u = LS.Renderer._main_camera._uniforms.u_camera_planes : u = [0.1, 1e3], s.u_camera_planes = u, s.u_ires.set([0, 0]), this._temp_texture.drawTo(function() {
          t.bind(0), o.uniforms(s).draw(a);
        }), this._temp_texture.near_far_planes = u, this.setOutputData(0, this._temp_texture);
      }
    }
  }
};
g(Mt, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(Mt, "title", "Linear Depth"), g(Mt, "desc", "Creates a color texture with linear depth"), g(Mt, "pixel_shader", `precision highp float;
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform int u_invert;
        uniform vec2 u_ires;
        
        void main() {
            float zNear = u_camera_planes.x;
            float zFar = u_camera_planes.y;
            float depth = texture2D(u_texture, v_coord + u_ires*0.5).x * 2.0 - 1.0;
            float f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));
            if( u_invert == 1 )
                f = 1.0 - f;
            gl_FragColor = vec4(vec3(f),1.0);
        }
        `);
let LGraphTextureLinearDepth = Mt;
LiteGraph.registerNodeType("texture/linear_depth", LGraphTextureLinearDepth);
const ce = class ce {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("Iterations", "number"), this.addInput("Intensity", "number"), this.addOutput("Blurred", "Texture"), this.properties = {
      intensity: 1,
      iterations: 1,
      preserve_aspect: !1,
      scale: [1, 1],
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isOutputConnected(0)) {
      var r = this._final_texture;
      (!r || r.width != t.width || r.height != t.height || r.type != t.type) && (r = this._final_texture = new GL$1.Texture(t.width, t.height, {
        type: t.type,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var s = this.properties.iterations;
      if (this.isInputConnected(1) && (s = this.getInputData(1), this.properties.iterations = s), s = Math.min(
        Math.floor(s),
        ce.max_iterations
      ), s == 0) {
        this.setOutputData(0, t);
        return;
      }
      var a = this.properties.intensity;
      this.isInputConnected(2) && (a = this.getInputData(2), this.properties.intensity = a);
      var o = LiteGraph.camera_aspect;
      !o && window.gl !== void 0 && (o = gl$1.canvas.height / gl$1.canvas.width), o || (o = 1), o = this.properties.preserve_aspect ? o : 1;
      var u = this.properties.scale || [1, 1];
      t.applyBlur(o * u[0], u[1], a, r);
      for (var h = 1; h < s; ++h)
        r.applyBlur(
          o * u[0] * (h + 1),
          u[1] * (h + 1),
          a
        );
      this.setOutputData(0, r);
    }
  }
  /*
  LGraphTextureBlur.pixel_shader = "precision highp float;\n\
      precision highp float;\n\
      varying vec2 v_coord;\n\
      uniform sampler2D u_texture;\n\
      uniform vec2 u_offset;\n\
      uniform float u_intensity;\n\
      void main() {\n\
          vec4 sum = vec4(0.0);\n\
          vec4 center = texture2D(u_texture, v_coord);\n\
          sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\n\
          sum += center * 0.16/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\n\
          sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\n\
          gl_FragColor = u_intensity * sum;\n\
      }\n\
      ";
  */
};
g(ce, "title", "Blur"), g(ce, "desc", "Blur a texture"), g(ce, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(ce, "max_iterations", 20);
let LGraphTextureBlur = ce;
LiteGraph.registerNodeType("texture/blur", LGraphTextureBlur);
const ot = class ot {
  constructor() {
    this.intensity = 0.5, this.persistence = 0.6, this.iterations = 8, this.threshold = 0.8, this.scale = 1, this.dirt_texture = null, this.dirt_factor = 0.5, this._textures = [], this._uniforms = {
      u_intensity: 1,
      u_texture: 0,
      u_glow_texture: 1,
      u_threshold: 0,
      u_texel_size: vec2.create()
    };
  }
  applyFX(t, r, s, a) {
    var o = t.width, u = t.height, h = {
      format: t.format,
      type: t.type,
      minFilter: GL$1.LINEAR,
      magFilter: GL$1.LINEAR,
      wrap: gl$1.CLAMP_TO_EDGE
    }, l = this._uniforms, c = this._textures, d = ot._cut_shader;
    d || (d = ot._cut_shader = new GL$1.Shader(
      GL$1.Shader.SCREEN_VERTEX_SHADER,
      ot.cut_pixel_shader
    )), gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.BLEND), l.u_threshold = this.threshold;
    var f = c[0] = GL$1.Texture.getTemporary(
      o,
      u,
      h
    );
    t.blit(f, d.uniforms(l));
    var _ = f, E = this.iterations;
    E = clamp(E, 1, 16) | 0;
    var m = l.u_texel_size, T = this.intensity;
    l.u_intensity = 1, l.u_delta = this.scale, d = ot._shader, d || (d = ot._shader = new GL$1.Shader(
      GL$1.Shader.SCREEN_VERTEX_SHADER,
      ot.scale_pixel_shader
    ));
    for (var L = 1; L < E && (o = o >> 1, (u | 0) > 1 && (u = u >> 1), !(o < 2)); L++)
      f = c[L] = GL$1.Texture.getTemporary(
        o,
        u,
        h
      ), m[0] = 1 / _.width, m[1] = 1 / _.height, _.blit(f, d.uniforms(l)), _ = f;
    for (a && (m[0] = 1 / _.width, m[1] = 1 / _.height, l.u_intensity = T, l.u_delta = 1, _.blit(a, d.uniforms(l))), gl$1.enable(gl$1.BLEND), gl$1.blendFunc(gl$1.ONE, gl$1.ONE), l.u_intensity = this.persistence, l.u_delta = 0.5, L -= 2; L >= 0; L--)
      f = c[L], c[L] = null, m[0] = 1 / _.width, m[1] = 1 / _.height, _.blit(f, d.uniforms(l)), GL$1.Texture.releaseTemporary(_), _ = f;
    if (gl$1.disable(gl$1.BLEND), s && _.blit(s), r) {
      var G = r, O = this.dirt_texture, b = this.dirt_factor;
      l.u_intensity = T, d = O ? ot._dirt_final_shader : ot._final_shader, d || (O ? d = ot._dirt_final_shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        ot.final_pixel_shader,
        { USE_DIRT: "" }
      ) : d = ot._final_shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        ot.final_pixel_shader
      )), G.drawTo(function() {
        t.bind(0), _.bind(1), O && (d.setUniform("u_dirt_factor", b), d.setUniform("u_dirt_texture", O.bind(2))), d.toViewport(l);
      });
    }
    GL$1.Texture.releaseTemporary(_);
  }
};
g(ot, "cut_pixel_shader", `precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_threshold;
        void main() {
            gl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );
        }`), g(ot, "scale_pixel_shader", `precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_texel_size;
        uniform float u_delta;
        uniform float u_intensity;
        
        vec4 sampleBox(vec2 uv) {
            vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;
            vec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);
            return s * 0.25;
        }
        void main() {
            gl_FragColor = u_intensity * sampleBox( v_coord );
        }`), g(ot, "final_pixel_shader", `precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform sampler2D u_glow_texture;
        #ifdef USE_DIRT
            uniform sampler2D u_dirt_texture;
        #endif
        uniform vec2 u_texel_size;
        uniform float u_delta;
        uniform float u_intensity;
        uniform float u_dirt_factor;
        
        vec4 sampleBox(vec2 uv) {
            vec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;
            vec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);
            return s * 0.25;
        }
        void main() {
            vec4 glow = sampleBox( v_coord );
            #ifdef USE_DIRT
                glow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );
            #endif
            gl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;
        }`);
let FXGlow = ot;
class LGraphTextureGlow {
  constructor() {
    this.addInput("in", "Texture"), this.addInput("dirt", "Texture"), this.addOutput("out", "Texture"), this.addOutput("glow", "Texture"), this.properties = {
      enabled: !0,
      intensity: 1,
      persistence: 0.99,
      iterations: 16,
      threshold: 0,
      scale: 1,
      dirt_factor: 0.5,
      precision: LGraphTexture.DEFAULT
    }, this.fx = new FXGlow();
  }
  onGetInputs() {
    return [
      ["enabled", "boolean"],
      ["threshold", "number"],
      ["intensity", "number"],
      ["persistence", "number"],
      ["iterations", "number"],
      ["dirt_factor", "number"]
    ];
  }
  onGetOutputs() {
    return [["average", "Texture"]];
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isAnyOutputConnected()) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.getInputOrProperty("enabled") === !1) {
        this.setOutputData(0, t);
        return;
      }
      var r = this.fx;
      r.threshold = this.getInputOrProperty("threshold"), r.iterations = this.getInputOrProperty("iterations"), r.intensity = this.getInputOrProperty("intensity"), r.persistence = this.getInputOrProperty("persistence"), r.dirt_texture = this.getInputData(1), r.dirt_factor = this.getInputOrProperty("dirt_factor"), r.scale = this.properties.scale;
      var s = LGraphTexture.getTextureType(this.properties.precision, t), a = null;
      this.isOutputConnected(2) && (a = this._average_texture, (!a || a.type != t.type || a.format != t.format) && (a = this._average_texture = new GL$1.Texture(1, 1, {
        type: t.type,
        format: t.format,
        filter: gl$1.LINEAR
      })));
      var o = null;
      this.isOutputConnected(1) && (o = this._glow_texture, (!o || o.width != t.width || o.height != t.height || o.type != s || o.format != t.format) && (o = this._glow_texture = new GL$1.Texture(
        t.width,
        t.height,
        { type: s, format: t.format, filter: gl$1.LINEAR }
      )));
      var u = null;
      this.isOutputConnected(0) && (u = this._final_texture, (!u || u.width != t.width || u.height != t.height || u.type != s || u.format != t.format) && (u = this._final_texture = new GL$1.Texture(
        t.width,
        t.height,
        { type: s, format: t.format, filter: gl$1.LINEAR }
      ))), r.applyFX(t, u, o, a), this.isOutputConnected(0) && this.setOutputData(0, u), this.isOutputConnected(1) && this.setOutputData(1, a), this.isOutputConnected(2) && this.setOutputData(2, o);
    }
  }
}
g(LGraphTextureGlow, "title", "Glow"), g(LGraphTextureGlow, "desc", "Filters a texture giving it a glow effect"), g(LGraphTextureGlow, "widgets_info", {
  iterations: {
    type: "number",
    min: 0,
    max: 16,
    step: 1,
    precision: 0
  },
  threshold: {
    type: "number",
    min: 0,
    max: 10,
    step: 0.01,
    precision: 2
  },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
});
LiteGraph.registerNodeType("texture/glow", LGraphTextureGlow);
const Lt = class Lt {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("Filtered", "Texture"), this.properties = { intensity: 1, radius: 5 };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isOutputConnected(0)) {
      var r = this._temp_texture;
      (!r || r.width != t.width || r.height != t.height || r.type != t.type) && (this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: t.type,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var s = this.properties.radius;
      if (s = Math.min(
        Math.floor(s),
        Lt.max_radius
      ), s == 0) {
        this.setOutputData(0, t);
        return;
      }
      var a = this.properties.intensity, o = LiteGraph.camera_aspect;
      !o && window.gl !== void 0 && (o = gl$1.canvas.height / gl$1.canvas.width), o || (o = 1), o = this.properties.preserve_aspect ? o : 1, Lt._shaders[s] || (Lt._shaders[s] = new GL$1.Shader(
        Shader.SCREEN_VERTEX_SHADER,
        Lt.pixel_shader,
        { RADIUS: s.toFixed(0) }
      ));
      var u = Lt._shaders[s], h = GL$1.Mesh.getScreenQuad();
      t.bind(0), this._temp_texture.drawTo(function() {
        u.uniforms({
          u_texture: 0,
          u_intensity: a,
          u_resolution: [t.width, t.height],
          u_iResolution: [1 / t.width, 1 / t.height]
        }).draw(h);
      }), this.setOutputData(0, this._temp_texture);
    }
  }
};
g(Lt, "title", "Kuwahara Filter"), g(Lt, "desc", "Filters a texture giving an artistic oil canvas painting"), g(Lt, "max_radius", 10), g(Lt, "_shaders", []), // from https://www.shadertoy.com/view/MsXSz4
g(Lt, "pixel_shader", `
    precision highp float;
    varying vec2 v_coord;
    uniform sampler2D u_texture;
    uniform float u_intensity;
    uniform vec2 u_resolution;
    uniform vec2 u_iResolution;
    #ifndef RADIUS
    #define RADIUS 7
    #endif
    void main() {
    
    const int radius = RADIUS;
    vec2 fragCoord = v_coord;
    vec2 src_size = u_iResolution;
    vec2 uv = v_coord;
    float n = float((radius + 1) * (radius + 1));
    int i;
    int j;
    vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);
    vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);
    vec3 c;
    
    for (int j = -radius; j <= 0; ++j)  {
        for (int i = -radius; i <= 0; ++i)  {
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;
            m0 += c;
            s0 += c * c;
        }
    }
    
    for (int j = -radius; j <= 0; ++j)  {
        for (int i = 0; i <= radius; ++i)  {
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;
            m1 += c;
            s1 += c * c;
        }
    }
    
    for (int j = 0; j <= radius; ++j)  {
        for (int i = 0; i <= radius; ++i)  {
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;
            m2 += c;
            s2 += c * c;
        }
    }
    
    for (int j = 0; j <= radius; ++j)  {
        for (int i = -radius; i <= 0; ++i)  {
            c = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;
            m3 += c;
            s3 += c * c;
        }
    }
    
    float min_sigma2 = 1e+2;
    m0 /= n;
    s0 = abs(s0 / n - m0 * m0);
    
    float sigma2 = s0.r + s0.g + s0.b;
    if (sigma2 < min_sigma2) {
        min_sigma2 = sigma2;
        gl_FragColor = vec4(m0, 1.0);
    }
    
    m1 /= n;
    s1 = abs(s1 / n - m1 * m1);
    
    sigma2 = s1.r + s1.g + s1.b;
    if (sigma2 < min_sigma2) {
        min_sigma2 = sigma2;
        gl_FragColor = vec4(m1, 1.0);
    }
    
    m2 /= n;
    s2 = abs(s2 / n - m2 * m2);
    
    sigma2 = s2.r + s2.g + s2.b;
    if (sigma2 < min_sigma2) {
        min_sigma2 = sigma2;
        gl_FragColor = vec4(m2, 1.0);
    }
    
    m3 /= n;
    s3 = abs(s3 / n - m3 * m3);
    
    sigma2 = s3.r + s3.g + s3.b;
    if (sigma2 < min_sigma2) {
        min_sigma2 = sigma2;
        gl_FragColor = vec4(m3, 1.0);
    }
    }
    `);
let LGraphTextureKuwaharaFilter = Lt;
LiteGraph.registerNodeType("texture/kuwahara", LGraphTextureKuwaharaFilter);
const At = class At {
  constructor() {
    this.addInput("Texture", "Texture"), this.addOutput("Filtered", "Texture"), this.properties = {
      sigma: 1.4,
      k: 1.6,
      p: 21.7,
      epsilon: 79,
      phi: 0.017
    };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isOutputConnected(0)) {
      var r = this._temp_texture;
      (!r || r.width != t.width || r.height != t.height || r.type != t.type) && (this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: t.type,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      })), At._xdog_shader || (At._xdog_shader = new GL$1.Shader(
        Shader.SCREEN_VERTEX_SHADER,
        At.xdog_pixel_shader
      ));
      var s = At._xdog_shader, a = GL$1.Mesh.getScreenQuad(), o = this.properties.sigma, u = this.properties.k, h = this.properties.p, l = this.properties.epsilon, c = this.properties.phi;
      t.bind(0), this._temp_texture.drawTo(function() {
        s.uniforms({
          src: 0,
          sigma: o,
          k: u,
          p: h,
          epsilon: l,
          phi: c,
          cvsWidth: t.width,
          cvsHeight: t.height
        }).draw(a);
      }), this.setOutputData(0, this._temp_texture);
    }
  }
};
g(At, "title", "XDoG Filter"), g(At, "desc", "Filters a texture giving an artistic ink style"), g(At, "max_radius", 10), g(At, "_shaders", []), // from https://github.com/RaymondMcGuire/GPU-Based-Image-Processing-Tools/blob/master/lib_webgl/scripts/main.js
g(At, "xdog_pixel_shader", `
    precision highp float;
    uniform sampler2D src;

    uniform float cvsHeight;
    uniform float cvsWidth;

    uniform float sigma;
    uniform float k;
    uniform float p;
    uniform float epsilon;
    uniform float phi;
    varying vec2 v_coord;

    float cosh(float val)
    {
    float tmp = exp(val);
    float cosH = (tmp + 1.0 / tmp) / 2.0;
    return cosH;
    }

    float tanh(float val)
    {
    float tmp = exp(val);
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);
    return tanH;
    }

    float sinh(float val)
    {
    float tmp = exp(val);
    float sinH = (tmp - 1.0 / tmp) / 2.0;
    return sinH;
    }

    void main(void){
    vec3 destColor = vec3(0.0);
    float tFrag = 1.0 / cvsHeight;
    float sFrag = 1.0 / cvsWidth;
    vec2 Frag = vec2(sFrag,tFrag);
    vec2 uv = gl_FragCoord.st;
    float twoSigmaESquared = 2.0 * sigma * sigma;
    float twoSigmaRSquared = twoSigmaESquared * k * k;
    int halfWidth = int(ceil( 1.0 * sigma * k ));

    const int MAX_NUM_ITERATION = 99999;
    vec2 sum = vec2(0.0);
    vec2 norm = vec2(0.0);

    for(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){
        if(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}
        int i = int(cnt / (2*halfWidth+1)) - halfWidth;
        int j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);

        float d = length(vec2(i,j));
        vec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), 
                            exp( -d * d / twoSigmaRSquared ));

        vec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;

        norm += kernel;
        sum += kernel * L;
    }

    sum /= norm;

    float H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);
    float edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));
    destColor = vec3(edge);
    gl_FragColor = vec4(destColor, 1.0);
    }`);
let LGraphTextureXDoGFilter = At;
LiteGraph.registerNodeType("texture/xDoG", LGraphTextureXDoGFilter);
const Zt = class Zt {
  constructor() {
    this.addOutput("Webcam", "Texture"), this.properties = { texture_name: "", facingMode: "user" }, this.boxcolor = "black", this.version = 0;
  }
  openStream() {
    if (!navigator.getUserMedia)
      return;
    this._waiting_confirmation = !0;
    var t = {
      audio: !1,
      video: { facingMode: this.properties.facingMode }
    };
    navigator.mediaDevices.getUserMedia(t).then(this.streamReady.bind(this)).catch(s);
    var r = this;
    function s(a) {
      var o;
      Zt.is_webcam_open = !1, (o = console.log) == null || o.call(console, "Webcam rejected", a), r._webcam_stream = !1, r.boxcolor = "red", r.trigger("stream_error");
    }
  }
  closeStream() {
    if (this._webcam_stream) {
      var t = this._webcam_stream.getTracks();
      if (t.length)
        for (var r = 0; r < t.length; ++r)
          t[r].stop();
      Zt.is_webcam_open = !1, this._webcam_stream = null, this._video = null, this.boxcolor = "black", this.trigger("stream_closed");
    }
  }
  streamReady(t) {
    this._webcam_stream = t, this.boxcolor = "green";
    var r = this._video;
    r || (r = document.createElement("video"), r.autoplay = !0, r.srcObject = t, this._video = r, r.onloadedmetadata = function(s) {
      var a;
      Zt.is_webcam_open = !0, (a = console.log) == null || a.call(console, s);
    }), this.trigger("stream_ready", r);
  }
  onPropertyChanged(t, r) {
    t == "facingMode" && (this.properties.facingMode = r, this.closeStream(), this.openStream());
  }
  onRemoved() {
    if (this._webcam_stream) {
      var t = this._webcam_stream.getTracks();
      if (t.length)
        for (var r = 0; r < t.length; ++r)
          t[r].stop();
      this._webcam_stream = null, this._video = null;
    }
  }
  onDrawBackground(t) {
    this.flags.collapsed || this.size[1] <= 20 || this._video && (t.save(), t.webgl ? this._video_texture && t.drawImage(
      this._video_texture,
      0,
      0,
      this.size[0],
      this.size[1]
    ) : t.drawImage(this._video, 0, 0, this.size[0], this.size[1]), t.restore());
  }
  onExecute() {
    if (this._webcam_stream == null && !this._waiting_confirmation && this.openStream(), !(!this._video || !this._video.videoWidth)) {
      var t = this._video.videoWidth, r = this._video.videoHeight, s = this._video_texture;
      if ((!s || s.width != t || s.height != r) && (this._video_texture = new GL$1.Texture(t, r, {
        format: gl$1.RGB,
        filter: gl$1.LINEAR
      })), this._video_texture.uploadImage(this._video), this._video_texture.version = ++this.version, this.properties.texture_name) {
        var a = LGraphTexture.getTexturesContainer();
        a[this.properties.texture_name] = this._video_texture;
      }
      this.setOutputData(0, this._video_texture);
      for (var o = 1; o < this.outputs.length; ++o)
        if (this.outputs[o])
          switch (this.outputs[o].name) {
            case "width":
              this.setOutputData(o, this._video.videoWidth);
              break;
            case "height":
              this.setOutputData(o, this._video.videoHeight);
              break;
          }
    }
  }
  onGetOutputs() {
    return [
      ["width", "number"],
      ["height", "number"],
      ["stream_ready", LiteGraph.EVENT],
      ["stream_closed", LiteGraph.EVENT],
      ["stream_error", LiteGraph.EVENT]
    ];
  }
};
g(Zt, "title", "Webcam"), g(Zt, "desc", "Webcam texture"), g(Zt, "is_webcam_open", !1);
let LGraphTextureWebcam = Zt;
LiteGraph.registerNodeType("texture/webcam", LGraphTextureWebcam);
const Wt = class Wt {
  constructor() {
    this.addInput("in", "Texture"), this.addInput("f", "number"), this.addOutput("out", "Texture"), this.properties = {
      enabled: !0,
      factor: 1,
      precision: LGraphTexture.LOW
    }, this._uniforms = { u_texture: 0, u_factor: 1 };
  }
  onGetInputs() {
    return [["enabled", "boolean"]];
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.getInputOrProperty("enabled") === !1) {
        this.setOutputData(0, t);
        return;
      }
      var r = this._temp_texture;
      (!r || r.width != t.width || r.height != t.height || r.type != t.type) && (r = this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: t.type,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var s = Wt._shader;
      s || (s = Wt._shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        Wt.pixel_shader
      ));
      var a = this.getInputData(1);
      a == null && (a = this.properties.factor);
      var o = this._uniforms;
      o.u_factor = a, gl$1.disable(gl$1.DEPTH_TEST), r.drawTo(function() {
        t.bind(0), s.uniforms(o).draw(GL$1.Mesh.getScreenQuad());
      }), this.setOutputData(0, r);
    }
  }
};
g(Wt, "title", "Lens FX"), g(Wt, "desc", "distortion and chromatic aberration"), g(Wt, "widgets_info", { precision: { widget: "combo", values: LGraphTexture.MODE_VALUES } }), g(Wt, "pixel_shader", `precision highp float;
    varying vec2 v_coord;
    uniform sampler2D u_texture;
    uniform float u_factor;
    vec2 barrelDistortion(vec2 coord, float amt) {
        vec2 cc = coord - 0.5;
        float dist = dot(cc, cc);
        return coord + cc * dist * amt;
    }
    
    float sat( float t )
    {
        return clamp( t, 0.0, 1.0 );
    }
    
    float linterp( float t ) {
        return sat( 1.0 - abs( 2.0*t - 1.0 ) );
    }
    
    float remap( float t, float a, float b ) {
        return sat( (t - a) / (b - a) );
    }
    
    vec4 spectrum_offset( float t ) {
        vec4 ret;
        float lo = step(t,0.5);
        float hi = 1.0-lo;
        float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
        ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);
    
        return pow( ret, vec4(1.0/2.2) );
    }
    
    const float max_distort = 2.2;
    const int num_iter = 12;
    const float reci_num_iter_f = 1.0 / float(num_iter);
    
    void main()
    {	
        vec2 uv=v_coord;
        vec4 sumcol = vec4(0.0);
        vec4 sumw = vec4(0.0);	
        for ( int i=0; i<num_iter;++i )
        {
            float t = float(i) * reci_num_iter_f;
            vec4 w = spectrum_offset( t );
            sumw += w;
            sumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );
        }
        gl_FragColor = sumcol / sumw;
    }`);
let LGraphLensFX = Wt;
LiteGraph.registerNodeType("texture/lensfx", LGraphLensFX);
class LGraphTextureFromData {
  constructor() {
    this.addInput("in", ""), this.properties = {
      precision: LGraphTexture.LOW,
      width: 0,
      height: 0,
      channels: 1
    }, this.addOutput("out", "Texture");
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (t) {
        var r = this.properties.channels, s = this.properties.width, a = this.properties.height;
        (!s || !a) && (s = Math.floor(t.length / r), a = 1);
        var o = gl$1.RGBA;
        r == 3 ? o = gl$1.RGB : r == 1 && (o = gl$1.LUMINANCE);
        var u = this._temp_texture, h = LGraphTexture.getTextureType(this.properties.precision);
        (!u || u.width != s || u.height != a || u.type != h) && (u = this._temp_texture = new GL$1.Texture(s, a, {
          type: h,
          format: o,
          filter: gl$1.LINEAR
        })), u.uploadData(t), this.setOutputData(0, u);
      }
    }
  }
}
g(LGraphTextureFromData, "title", "Data->Tex"), g(LGraphTextureFromData, "desc", "Generates or applies a curve to a texture"), g(LGraphTextureFromData, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
});
LiteGraph.registerNodeType("texture/fromdata", LGraphTextureFromData);
const mt = class mt {
  constructor() {
    g(this, "pixel_shader", `precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform sampler2D u_curve;
        uniform float u_range;
        
        void main() {
            vec4 color = texture2D( u_texture, v_coord ) * u_range;
            color.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;
            color.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;
            color.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;
            //color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;
            gl_FragColor = color;
        }`);
    this.addInput("in", "Texture"), this.addOutput("out", "Texture"), this.properties = {
      precision: LGraphTexture.LOW,
      split_channels: !1
    }, this._values = new Uint8Array(256 * 4), this._values.fill(255), this._curve_texture = null, this._uniforms = { u_texture: 0, u_curve: 1, u_range: 1 }, this._must_update = !0, this._points = {
      RGB: [
        [0, 0],
        [1, 1]
      ],
      R: [
        [0, 0],
        [1, 1]
      ],
      G: [
        [0, 0],
        [1, 1]
      ],
      B: [
        [0, 0],
        [1, 1]
      ]
    }, this.curve_editor = null, this.addWidget("toggle", "Split Channels", !1, "split_channels"), this.addWidget(
      "combo",
      "Channel",
      "RGB",
      { values: ["RGB", "R", "G", "B"] }
    ), this.curve_offset = 68, this.size = [240, 160];
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0), r = this._temp_texture;
      if (!t) {
        (this._must_update || !this._curve_texture) && this.updateCurve(), this.setOutputData(0, this._curve_texture);
        return;
      }
      var s = LGraphTexture.getTextureType(this.properties.precision, t);
      (!r || r.type != s || r.width != t.width || r.height != t.height || r.format != t.format) && (r = this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: s,
        format: t.format,
        filter: gl$1.LINEAR
      }));
      var a = mt._shader;
      a || (a = mt._shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        mt.pixel_shader
      )), (this._must_update || !this._curve_texture) && this.updateCurve();
      var o = this._uniforms, u = this._curve_texture;
      r.drawTo(function() {
        gl$1.disable(gl$1.DEPTH_TEST), t.bind(0), u.bind(1), a.uniforms(o).draw(GL$1.Mesh.getScreenQuad());
      }), this.setOutputData(0, r);
    }
  }
  sampleCurve(t, r) {
    if (r || (r = this._points.RGB), !!r) {
      for (var s = 0; s < r.length - 1; ++s) {
        var a = r[s], o = r[s + 1];
        if (!(o[0] < t)) {
          var u = o[0] - a[0];
          if (Math.abs(u) < 1e-5) return a[1];
          var h = (t - a[0]) / u;
          return a[1] * (1 - h) + o[1] * h;
        }
      }
      return 0;
    }
  }
  updateCurve() {
    for (var t = this._values, r = t.length / 4, s = this.properties.split_channels, a = 0; a < r; ++a) {
      if (s)
        t[a * 4] = clamp(
          this.sampleCurve(a / r, this._points.R) * 255,
          0,
          255
        ), t[a * 4 + 1] = clamp(
          this.sampleCurve(a / r, this._points.G) * 255,
          0,
          255
        ), t[a * 4 + 2] = clamp(
          this.sampleCurve(a / r, this._points.B) * 255,
          0,
          255
        );
      else {
        var o = this.sampleCurve(a / r);
        t[a * 4] = t[a * 4 + 1] = t[a * 4 + 2] = clamp(o * 255, 0, 255);
      }
      t[a * 4 + 3] = 255;
    }
    this._curve_texture || (this._curve_texture = new GL$1.Texture(256, 1, {
      format: gl$1.RGBA,
      magFilter: gl$1.LINEAR,
      wrap: gl$1.CLAMP_TO_EDGE
    })), this._curve_texture.uploadData(t, null, !0);
  }
  onSerialize(t) {
    var r = {};
    for (var s in this._points) r[s] = this._points[s].concat();
    t.curves = r;
  }
  onConfigure(t) {
    this._points = t.curves, this.curve_editor && (curve_editor.points = this._points), this._must_update = !0;
  }
  onMouseDown(t, r, s) {
    if (this.curve_editor) {
      var a = this.curve_editor.onMouseDown(
        [r[0], r[1] - this.curve_offset],
        s
      );
      return a && this.captureInput(!0), a;
    }
  }
  onMouseMove(t, r, s) {
    if (this.curve_editor)
      return this.curve_editor.onMouseMove(
        [r[0], r[1] - this.curve_offset],
        s
      );
  }
  onMouseUp(t, r, s) {
    if (this.curve_editor)
      return this.curve_editor.onMouseUp(
        [r[0], r[1] - this.curve_offset],
        s
      );
    this.captureInput(!1);
  }
  onDrawBackground(t, r) {
    if (!this.flags.collapsed) {
      this.curve_editor || (this.curve_editor = new LiteGraph.CurveEditor(this._points.R)), t.save(), t.translate(0, this.curve_offset);
      var s = this.widgets[1].value;
      this.properties.split_channels ? (s == "RGB" && (this.widgets[1].value = s = "R", this.widgets[1].disabled = !1), this.curve_editor.points = this._points.R, this.curve_editor.draw(
        t,
        [this.size[0], this.size[1] - this.curve_offset],
        r,
        "#111",
        mt.channel_line_colors.R,
        !0
      ), t.globalCompositeOperation = "lighten", this.curve_editor.points = this._points.G, this.curve_editor.draw(
        t,
        [this.size[0], this.size[1] - this.curve_offset],
        r,
        null,
        mt.channel_line_colors.G,
        !0
      ), this.curve_editor.points = this._points.B, this.curve_editor.draw(
        t,
        [this.size[0], this.size[1] - this.curve_offset],
        r,
        null,
        mt.channel_line_colors.B,
        !0
      ), t.globalCompositeOperation = "source-over") : (this.widgets[1].value = s = "RGB", this.widgets[1].disabled = !0), this.curve_editor.points = this._points[s], this.curve_editor.draw(
        t,
        [this.size[0], this.size[1] - this.curve_offset],
        r,
        this.properties.split_channels ? null : "#111",
        mt.channel_line_colors[s]
      ), t.restore();
    }
  }
};
g(mt, "title", "Curve"), g(mt, "desc", "Generates or applies a curve to a texture"), g(mt, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(mt, "channel_line_colors", {
  RGB: "#666",
  R: "#F33",
  G: "#3F3",
  B: "#33F"
});
let LGraphTextureCurve = mt;
LiteGraph.registerNodeType("texture/curve", LGraphTextureCurve);
const qt = class qt {
  constructor() {
    this.addInput("in", "Texture"), this.addInput("exp", "number"), this.addOutput("out", "Texture"), this.properties = { exposition: 1, precision: LGraphTexture.LOW }, this._uniforms = { u_texture: 0, u_exposition: 1 };
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isOutputConnected(0)) {
      var r = this._temp_texture;
      (!r || r.width != t.width || r.height != t.height || r.type != t.type) && (r = this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: t.type,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var s = qt._shader;
      s || (s = qt._shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        qt.pixel_shader
      )), this.properties.exposition;
      var a = this.getInputData(1);
      a != null && (this.properties.exposition = a);
      var o = this._uniforms;
      r.drawTo(function() {
        gl$1.disable(gl$1.DEPTH_TEST), t.bind(0), s.uniforms(o).draw(GL$1.Mesh.getScreenQuad());
      }), this.setOutputData(0, r);
    }
  }
};
g(qt, "title", "Exposition"), g(qt, "desc", "Controls texture exposition"), g(qt, "widgets_info", {
  exposition: { widget: "slider", min: 0, max: 3 },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(qt, "pixel_shader", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_exposition;
    
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            gl_FragColor = vec4(color.xyz * u_exposition, color.a);
        }
    `);
let LGraphExposition = qt;
LiteGraph.registerNodeType("texture/exposition", LGraphExposition);
const xt = class xt {
  constructor() {
    this.addInput("in", "Texture"), this.addInput("avg", "number,Texture"), this.addOutput("out", "Texture"), this.properties = {
      enabled: !0,
      scale: 1,
      gamma: 1,
      average_lum: 1,
      lum_white: 1,
      precision: LGraphTexture.LOW
    }, this._uniforms = {
      u_texture: 0,
      u_lumwhite2: 1,
      u_igamma: 1,
      u_scale: 1,
      u_average_lum: 1
    };
  }
  onGetInputs() {
    return [["enabled", "boolean"]];
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t && this.isOutputConnected(0)) {
      if (this.properties.precision === LGraphTexture.PASS_THROUGH || this.getInputOrProperty("enabled") === !1) {
        this.setOutputData(0, t);
        return;
      }
      var r = this._temp_texture;
      (!r || r.width != t.width || r.height != t.height || r.type != t.type) && (r = this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: t.type,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var s = this.getInputData(1);
      s == null && (s = this.properties.average_lum);
      var a = this._uniforms, o = null;
      s.constructor === Number ? (this.properties.average_lum = s, a.u_average_lum = this.properties.average_lum, o = xt._shader, o || (o = xt._shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        xt.pixel_shader
      ))) : s.constructor === GL$1.Texture && (a.u_average_texture = s.bind(1), o = xt._shader_texture, o || (o = xt._shader_texture = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        xt.pixel_shader,
        { AVG_TEXTURE: "" }
      ))), a.u_lumwhite2 = this.properties.lum_white * this.properties.lum_white, a.u_scale = this.properties.scale, a.u_igamma = 1 / this.properties.gamma, gl$1.disable(gl$1.DEPTH_TEST), r.drawTo(function() {
        t.bind(0), o.uniforms(a).draw(GL$1.Mesh.getScreenQuad());
      }), this.setOutputData(0, this._temp_texture);
    }
  }
};
g(xt, "title", "Tone Mapping"), g(xt, "desc", "Applies Tone Mapping to convert from high to low"), g(xt, "widgets_info", { precision: { widget: "combo", values: LGraphTexture.MODE_VALUES } }), g(xt, "pixel_shader", `precision highp float;
    varying vec2 v_coord;
    uniform sampler2D u_texture;
    uniform float u_scale;
    #ifdef AVG_TEXTURE
        uniform sampler2D u_average_texture;
    #else
        uniform float u_average_lum;
    #endif
    uniform float u_lumwhite2;
    uniform float u_igamma;
    vec3 RGB2xyY (vec3 rgb)
    {
            const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,
                                    0.2126, 0.7152, 0.0722,
                                    0.0193, 0.1192, 0.9505);
        vec3 XYZ = RGB2XYZ * rgb;
        
        float f = (XYZ.x + XYZ.y + XYZ.z);
        return vec3(XYZ.x / f,
                    XYZ.y / f,
                    XYZ.y);
    }
    
    void main() {
        vec4 color = texture2D( u_texture, v_coord );
        vec3 rgb = color.xyz;
        float average_lum = 0.0;
        #ifdef AVG_TEXTURE
            vec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;
            average_lum = (pixel.x + pixel.y + pixel.z) / 3.0;
        #else
            average_lum = u_average_lum;
        #endif
        //Ld - this part of the code is the same for both versions
        float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
        float L = (u_scale / average_lum) * lum;
        float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);
        //first
        //vec3 xyY = RGB2xyY(rgb);
        //xyY.z *= Ld;
        //rgb = xyYtoRGB(xyY);
        //second
        rgb = (rgb / lum) * Ld;
        rgb = max(rgb,vec3(0.001));
        rgb = pow( rgb, vec3( u_igamma ) );
        gl_FragColor = vec4( rgb, color.a );
    }`);
let LGraphToneMapping = xt;
LiteGraph.registerNodeType("texture/tonemapping", LGraphToneMapping);
const Yt = class Yt {
  constructor() {
    this.addOutput("out", "Texture"), this.properties = {
      width: 512,
      height: 512,
      seed: 0,
      persistence: 0.1,
      octaves: 8,
      scale: 1,
      offset: [0, 0],
      amplitude: 1,
      precision: LGraphTexture.DEFAULT
    }, this._key = 0, this._texture = null, this._uniforms = {
      u_persistence: 0.1,
      u_seed: 0,
      u_offset: vec2.create(),
      u_scale: 1,
      u_viewport: vec2.create()
    };
  }
  onGetInputs() {
    return [
      ["seed", "number"],
      ["persistence", "number"],
      ["octaves", "number"],
      ["scale", "number"],
      ["amplitude", "number"],
      ["offset", "vec2"]
    ];
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.properties.width | 0, r = this.properties.height | 0;
      t == 0 && (t = gl$1.viewport_data[2]), r == 0 && (r = gl$1.viewport_data[3]);
      var s = LGraphTexture.getTextureType(this.properties.precision), a = this._texture;
      (!a || a.width != t || a.height != r || a.type != s) && (a = this._texture = new GL$1.Texture(t, r, {
        type: s,
        format: gl$1.RGB,
        filter: gl$1.LINEAR
      }));
      var o = this.getInputOrProperty("persistence"), u = this.getInputOrProperty("octaves"), h = this.getInputOrProperty("offset"), l = this.getInputOrProperty("scale"), c = this.getInputOrProperty("amplitude"), d = this.getInputOrProperty("seed"), f = "" + t + r + s + o + u + l + d + h[0] + h[1] + c;
      if (f == this._key) {
        this.setOutputData(0, a);
        return;
      }
      this._key = f;
      var _ = this._uniforms;
      _.u_persistence = o, _.u_octaves = u, _.u_offset.set(h), _.u_scale = l, _.u_amplitude = c, _.u_seed = d * 128, _.u_viewport[0] = t, _.u_viewport[1] = r;
      var E = Yt._shader;
      E || (E = Yt._shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        Yt.pixel_shader
      )), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST), a.drawTo(function() {
        E.uniforms(_).draw(GL$1.Mesh.getScreenQuad());
      }), this.setOutputData(0, a);
    }
  }
};
g(Yt, "title", "Perlin"), g(Yt, "desc", "Generates a perlin noise texture"), g(Yt, "widgets_info", {
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
  width: { type: "number", precision: 0, step: 1 },
  height: { type: "number", precision: 0, step: 1 },
  octaves: { type: "number", precision: 0, step: 1, min: 1, max: 50 }
}), g(Yt, "pixel_shader", `precision highp float;
        varying vec2 v_coord;
        uniform vec2 u_offset;
        uniform float u_scale;
        uniform float u_persistence;
        uniform int u_octaves;
        uniform float u_amplitude;
        uniform vec2 u_viewport;
        uniform float u_seed;
        #define M_PI 3.14159265358979323846
        
        float rand(vec2 c){	return fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }
        
        float noise(vec2 p, float freq ){
            float unit = u_viewport.x/freq;
            vec2 ij = floor(p/unit);
            vec2 xy = mod(p,unit)/unit;
            //xy = 3.*xy*xy-2.*xy*xy*xy;
            xy = .5*(1.-cos(M_PI*xy));
            float a = rand((ij+vec2(0.,0.)));
            float b = rand((ij+vec2(1.,0.)));
            float c = rand((ij+vec2(0.,1.)));
            float d = rand((ij+vec2(1.,1.)));
            float x1 = mix(a, b, xy.x);
            float x2 = mix(c, d, xy.x);
            return mix(x1, x2, xy.y);
        }
        
        float pNoise(vec2 p, int res){
            float persistance = u_persistence;
            float n = 0.;
            float normK = 0.;
            float f = 4.;
            float amp = 1.0;
            int iCount = 0;
            for (int i = 0; i<50; i++){
                n+=amp*noise(p, f);
                f*=2.;
                normK+=amp;
                amp*=persistance;
                if (iCount >= res)
                    break;
                iCount++;
            }
            float nf = n/normK;
            return nf*nf*nf*nf;
        }
        void main() {
            vec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;
            vec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );
            gl_FragColor = color;
        }`);
let LGraphTexturePerlin = Yt;
LiteGraph.registerNodeType("texture/perlin", LGraphTexturePerlin);
const te = class te {
  constructor() {
    this.addInput("v"), this.addOutput("out", "Texture"), this.properties = {
      code: te.default_code,
      width: 512,
      height: 512,
      clear: !0,
      precision: LGraphTexture.DEFAULT,
      use_html_canvas: !1
    }, this._func = null, this._temp_texture = null, this.compileCode();
  }
  onPropertyChanged(t, r) {
    t == "code" && this.compileCode(r);
  }
  compileCode(t) {
    var r, s;
    if (this._func = null, !!LiteGraph.allow_scripts)
      try {
        this._func = new Function(
          "canvas",
          "ctx",
          "time",
          "script",
          "v",
          t
        ), this.boxcolor = "#00FF00";
      } catch (a) {
        this.boxcolor = "#FF0000", (r = console.error) == null || r.call(console, "Error parsing script"), (s = console.error) == null || s.call(console, a);
      }
  }
  onExecute() {
    var t = this._func;
    !t || !this.isOutputConnected(0) || this.executeDraw(t);
  }
  executeDraw(t) {
    var _, E;
    var r = this.properties.width || gl$1.canvas.width, s = this.properties.height || gl$1.canvas.height, a = this._temp_texture, o = LGraphTexture.getTextureType(this.properties.precision);
    (!a || a.width != r || a.height != s || a.type != o) && (a = this._temp_texture = new GL$1.Texture(r, s, {
      format: gl$1.RGBA,
      filter: gl$1.LINEAR,
      type: o
    }));
    var u = this.getInputData(0), h = this.properties, l = this, c = this.graph.getTime(), d = gl$1, f = gl$1.canvas;
    if ((this.properties.use_html_canvas || !enableWebGLCanvas) && (this._canvas ? (f = this._canvas, d = this._ctx) : (f = this._canvas = GL$1.createCanvas(r.height), d = this._ctx = f.getContext("2d")), f.width = r, f.height = s), d == gl$1)
      a.drawTo(function() {
        var m, T;
        gl$1.start2D(), h.clear && (gl$1.clearColor(0, 0, 0, 0), gl$1.clear(gl$1.COLOR_BUFFER_BIT));
        try {
          t.draw ? t.draw.call(
            l,
            f,
            d,
            c,
            t,
            u
          ) : t.call(
            l,
            f,
            d,
            c,
            t,
            u
          ), l.boxcolor = "#00FF00";
        } catch (L) {
          l.boxcolor = "#FF0000", (m = console.error) == null || m.call(console, "Error executing script"), (T = console.error) == null || T.call(console, L);
        }
        gl$1.finish2D();
      });
    else {
      h.clear && d.clearRect(0, 0, f.width, f.height);
      try {
        t.draw ? t.draw.call(
          this,
          f,
          d,
          c,
          t,
          u
        ) : t.call(this, f, d, c, t, u), this.boxcolor = "#00FF00";
      } catch (m) {
        this.boxcolor = "#FF0000", (_ = console.error) == null || _.call(console, "Error executing script"), (E = console.error) == null || E.call(console, m);
      }
      a.uploadImage(f);
    }
    this.setOutputData(0, a);
  }
};
g(te, "title", "Canvas2D"), g(te, "desc", "Executes Canvas2D code inside a texture or the viewport."), g(te, "help", "Set width and height to 0 to match viewport size."), g(te, "default_code", `//vars: canvas,ctx,time
ctx.fillStyle='red';
ctx.fillRect(0,0,50,50);
`), g(te, "widgets_info", {
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES },
  code: { type: "code" },
  width: { type: "number", precision: 0, step: 1 },
  height: { type: "number", precision: 0, step: 1 }
});
let LGraphTextureCanvas2D = te;
LiteGraph.registerNodeType("texture/canvas2D", LGraphTextureCanvas2D);
const jt = class jt {
  constructor() {
    this.addInput("in", "Texture"), this.addOutput("out", "Texture"), this.properties = {
      key_color: vec3.fromValues(0, 1, 0),
      threshold: 0.8,
      slope: 0.2,
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      if (t) {
        this._tex = LGraphTexture.getTargetTexture(
          t,
          this._tex,
          this.properties.precision
        ), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST), this._uniforms || (this._uniforms = {
          u_texture: 0,
          u_key_color: this.properties.key_color,
          u_threshold: 1,
          u_slope: 1
        });
        var r = this._uniforms, s = Mesh.getScreenQuad(), a = jt._shader;
        a || (a = jt._shader = new GL$1.Shader(
          GL$1.Shader.SCREEN_VERTEX_SHADER,
          jt.pixel_shader
        )), r.u_key_color = this.properties.key_color, r.u_threshold = this.properties.threshold, r.u_slope = this.properties.slope, this._tex.drawTo(function() {
          t.bind(0), a.uniforms(r).draw(s);
        }), this.setOutputData(0, this._tex);
      }
    }
  }
};
g(jt, "title", "Matte"), g(jt, "desc", "Extracts background"), g(jt, "widgets_info", {
  key_color: { widget: "color" },
  precision: { widget: "combo", values: LGraphTexture.MODE_VALUES }
}), g(jt, "pixel_shader", `precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec3 u_key_color;
        uniform float u_threshold;
        uniform float u_slope;
        
        void main() {
            vec3 color = texture2D( u_texture, v_coord ).xyz;
            float diff = length( normalize(color) - normalize(u_key_color) );
            float edge = u_threshold * (1.0 - u_slope);
            float alpha = smoothstep( edge, u_threshold, diff);
            gl_FragColor = vec4( color, alpha );
        }`);
let LGraphTextureMatte = jt;
LiteGraph.registerNodeType("texture/matte", LGraphTextureMatte);
class LGraphCubemapToTexture2D {
  constructor() {
    this.addInput("in", "texture"), this.addInput("yaw", "number"), this.addOutput("out", "texture"), this.properties = { yaw: 0 };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (!(!t || t.texture_type != GL$1.TEXTURE_CUBE_MAP)) {
        this._last_tex && (this._last_tex.height != t.height || this._last_tex.type != t.type) && (this._last_tex = null);
        var r = this.getInputOrProperty("yaw");
        this._last_tex = GL$1.Texture.cubemapToTexture2D(
          t,
          t.height,
          this._last_tex,
          !0,
          r
        ), this.setOutputData(0, this._last_tex);
      }
    }
  }
}
g(LGraphCubemapToTexture2D, "title", "CubemapToTexture2D"), g(LGraphCubemapToTexture2D, "desc", "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation");
LiteGraph.registerNodeType("texture/cubemapToTexture2D", LGraphCubemapToTexture2D);
var SHADERNODES_COLOR = "#345", LGShaders = LiteGraph.Shaders = {};
LGShaders.GLSL_types = [
  "float",
  "vec2",
  "vec3",
  "vec4",
  "mat3",
  "mat4",
  "sampler2D",
  "samplerCube"
];
var GLSL_types_const = LGShaders.GLSL_types_const = [
  "float",
  "vec2",
  "vec3",
  "vec4"
], GLSL_functions_desc = {
  radians: "T radians(T degrees)",
  degrees: "T degrees(T radians)",
  sin: "T sin(T angle)",
  cos: "T cos(T angle)",
  tan: "T tan(T angle)",
  asin: "T asin(T x)",
  acos: "T acos(T x)",
  atan: "T atan(T x)",
  atan2: "T atan(T x,T y)",
  pow: "T pow(T x,T y)",
  exp: "T exp(T x)",
  log: "T log(T x)",
  exp2: "T exp2(T x)",
  log2: "T log2(T x)",
  sqrt: "T sqrt(T x)",
  inversesqrt: "T inversesqrt(T x)",
  abs: "T abs(T x)",
  sign: "T sign(T x)",
  floor: "T floor(T x)",
  round: "T round(T x)",
  ceil: "T ceil(T x)",
  fract: "T fract(T x)",
  mod: "T mod(T x,T y)",
  // "T mod(T x,float y)"
  min: "T min(T x,T y)",
  max: "T max(T x,T y)",
  clamp: "T clamp(T x,T minVal = 0.0,T maxVal = 1.0)",
  mix: "T mix(T x,T y,T a)",
  // "T mix(T x,T y,float a)"
  step: "T step(T edge, T edge2, T x)",
  // "T step(float edge, T x)"
  smoothstep: "T smoothstep(T edge, T edge2, T x)",
  // "T smoothstep(float edge, T x)"
  length: "float length(T x)",
  distance: "float distance(T p0, T p1)",
  normalize: "T normalize(T x)",
  dot: "float dot(T x,T y)",
  cross: "vec3 cross(vec3 x,vec3 y)",
  reflect: "vec3 reflect(vec3 V,vec3 N)",
  refract: "vec3 refract(vec3 V,vec3 N, float IOR)"
}, GLSL_functions = {}, GLSL_functions_name = [];
parseGLSLDescriptions();
LGShaders.ALL_TYPES = "float,vec2,vec3,vec4";
function parseGLSLDescriptions() {
  GLSL_functions_name.length = 0;
  for (var n in GLSL_functions_desc) {
    var t = GLSL_functions_desc[n], r = t.indexOf(" "), s = t.substr(0, r), a = t.indexOf("(", r), o = t.substr(r, a - r).trim(), u = t.substr(a + 1, t.length - a - 2).split(",");
    for (var h in u) {
      var l = u[h].split(" ").filter(function(c) {
        return c;
      });
      u[h] = { type: l[0].trim(), name: l[1].trim() }, l[2] == "=" && (u[h].value = l[3].trim());
    }
    GLSL_functions[n] = {
      return_type: s,
      func: o,
      params: u
    }, GLSL_functions_name.push(o);
  }
}
function registerShaderNode(n, t) {
  t.color = SHADERNODES_COLOR, t.filter = "shader", t.prototype.clearDestination = function() {
    this.shader_destination = {};
  }, t.prototype.propagateDestination = function(s) {
    if (this.shader_destination[s] = !0, this.inputs)
      for (var a = 0; a < this.inputs.length; ++a) {
        var o = this.getInputNode(a);
        o && o.propagateDestination(s);
      }
  }, t.prototype.onPropertyChanged || (t.prototype.onPropertyChanged = function() {
    this.graph && this.graph._version++;
  }), LiteGraph.registerNodeType("shader::" + n, t);
}
function getShaderNodeVarName(n, t) {
  return "VAR_" + (t || "TEMP") + "_" + n.id;
}
function getInputLinkID(n, t) {
  if (!n.inputs) return null;
  var r = n.getInputLink(t);
  if (!r) return null;
  var s = n.graph.getNodeById(r.origin_id);
  return s ? s.getOutputVarName ? s.getOutputVarName(r.origin_slot) : "link_" + s.id + "_" + r.origin_slot : null;
}
function getOutputLinkID(n, t) {
  return n.isOutputConnected(t) ? "link_" + n.id + "_" + t : null;
}
LGShaders.registerShaderNode = registerShaderNode;
LGShaders.getInputLinkID = getInputLinkID;
LGShaders.getOutputLinkID = getOutputLinkID;
LGShaders.getShaderNodeVarName = getShaderNodeVarName;
LGShaders.parseGLSLDescriptions = parseGLSLDescriptions;
function valueToGLSL(n, t, r) {
  var s = 5;
  if (r != null && (s = r), !t)
    if (n.constructor === Number)
      t = "float";
    else if (n.length)
      switch (n.length) {
        case 2:
          t = "vec2";
          break;
        case 3:
          t = "vec3";
          break;
        case 4:
          t = "vec4";
          break;
        case 9:
          t = "mat3";
          break;
        case 16:
          t = "mat4";
          break;
        default:
          throw new Error("unknown type for glsl value size");
      }
    else
      throw new Error("unknown type for glsl value: " + n.constructor);
  switch (t) {
    case "float":
      return n.toFixed(s);
    case "vec2":
      return `vec2(${n[0].toFixed(s)},${n[1].toFixed(s)})`;
    case "color3":
    case "vec3":
      return `vec3(${n[0].toFixed(s)},${n[1].toFixed(s)},${n[2].toFixed(s)})`;
    case "color4":
    case "vec4":
      return `vec4(${n[0].toFixed(s)},${n[1].toFixed(s)},${n[2].toFixed(s)},${n[3].toFixed(s)})`;
    case "mat3":
      return "mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)";
    case "mat4":
      return "mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0)";
    default:
      throw t;
  }
}
var varToTypeGLSL = LiteGraph.varToTypeGLSL = function n(t, r, s) {
  if (r == s)
    return t;
  if (t == null)
    switch (s) {
      case "float":
        return "0.0";
      case "vec2":
        return "vec2(0.0)";
      case "vec3":
        return "vec3(0.0)";
      case "vec4":
        return "vec4(0.0,0.0,0.0,1.0)";
      default:
        return null;
    }
  if (!s)
    throw new Error("error: no output type specified");
  if (s == "float")
    switch (r) {
      // case "float":
      case "vec2":
      case "vec3":
      case "vec4":
        return t + ".x";
      default:
        return "0.0";
    }
  else if (s == "vec2")
    switch (r) {
      case "float":
        return "vec2(" + t + ")";
      // case "vec2":
      case "vec3":
      case "vec4":
        return t + ".xy";
      default:
        return "vec2(0.0)";
    }
  else if (s == "vec3")
    switch (r) {
      case "float":
        return "vec3(" + t + ")";
      case "vec2":
        return "vec3(" + t + ",0.0)";
      // case "vec3":
      case "vec4":
        return t + ".xyz";
      default:
        return "vec3(0.0)";
    }
  else if (s == "vec4")
    switch (r) {
      case "float":
        return "vec4(" + t + ")";
      case "vec2":
        return "vec4(" + t + ",0.0,1.0)";
      case "vec3":
        return "vec4(" + t + ",1.0)";
      default:
        return "vec4(0.0,0.0,0.0,1.0)";
    }
  throw new Error("type cannot be converted");
}, convertVarToGLSLType = LiteGraph.convertVarToGLSLType = function n(t, r, s) {
  if (r == s) return t;
  if (r == "float") return s + "(" + t + ")";
  if (s == "vec2")
    return "vec2(" + t + ".xy)";
  if (s == "vec3") {
    if (r == "vec2") return "vec3(" + t + ",0.0)";
    if (r == "vec4") return "vec4(" + t + ".xyz)";
  }
  if (s == "vec4") {
    if (r == "vec2") return "vec4(" + t + ",0.0,0.0)";
    if (s == "vec3") return "vec4(" + t + ",1.0)";
  }
  return null;
};
class LGShaderContext {
  constructor() {
    this.vs_template = "", this.fs_template = "", this.buffer_names = { uvs: "v_coord" }, this.extra = {}, this._functions = {}, this._uniforms = {}, this._codeparts = {}, this._uniform_value = null;
  }
  clear() {
    this._uniforms = {}, this._functions = {}, this._codeparts = {}, this._uniform_value = null, this.extra = {};
  }
  addUniform(t, r, s) {
    this._uniforms[t] = r, s != null && (this._uniform_value || (this._uniform_value = {}), this._uniform_value[t] = s);
  }
  addFunction(t, r) {
    this._functions[t] = r;
  }
  addCode(t, r, s) {
    s = s || { "": "" };
    for (var a in s) {
      var o = a ? a + "_" + t : t;
      this._codeparts[o] ? this._codeparts[o] += r + `
` : this._codeparts[o] = r + `
`;
    }
  }
  // the system works by grabbing code fragments from every node and concatenating them in blocks depending on where must they be attached
  computeCodeBlocks(t, r) {
    this.clear();
    var s = t.findNodesByType("shader::output/vertex");
    s = s && s.length ? s[0] : null;
    var a = t.findNodesByType("shader::output/fragcolor");
    if (a = a && a.length ? a[0] : null, !a)
      return null;
    t.sendEventToAllNodes("clearDestination"), s && s.propagateDestination("vs"), a && a.propagateDestination("fs"), t.sendEventToAllNodes("onGetCode", this);
    var o = "";
    for (let l in this._uniforms)
      o += "uniform " + this._uniforms[l] + " " + l + `;
`;
    if (r)
      for (let l in r)
        o += "uniform " + r[l] + " " + l + `;
`;
    var u = "";
    for (let l in this._functions)
      u += "//" + l + `
` + this._functions[l] + `
`;
    var h = this._codeparts;
    return h.uniforms = o, h.functions = u, h;
  }
  // replaces blocks using the vs and fs template and returns the final codes
  computeShaderCode(t) {
    var r = this.computeCodeBlocks(t), s = GL$1.Shader.replaceCodeUsingContext(
      this.vs_template,
      r
    ), a = GL$1.Shader.replaceCodeUsingContext(
      this.fs_template,
      r
    );
    return {
      vs_code: s,
      fs_code: a
    };
  }
  // generates the shader code from the template and the
  computeShader(t, r) {
    var a, o, u, h;
    var s = this.computeShaderCode(t);
    if ((a = console.log) == null || a.call(console, s.vs_code, s.fs_code), !LiteGraph.catch_exceptions)
      return this._shader_error = !0, r ? r.updateShader(s.vs_code, s.fs_code) : r = new GL$1.Shader(s.vs_code, s.fs_code), this._shader_error = !1, r;
    try {
      return r ? r.updateShader(s.vs_code, s.fs_code) : r = new GL$1.Shader(s.vs_code, s.fs_code), this._shader_error = !1, r;
    } catch (l) {
      return this._shader_error || ((o = console.error) == null || o.call(console, l), l.indexOf("Fragment shader") != -1 ? (u = console.log) == null || u.call(console, s.fs_code.split(`
`).map(function(c, d) {
        return d + ".- " + c;
      }).join(`
`)) : (h = console.log) == null || h.call(console, s.vs_code)), this._shader_error = !0, null;
    }
  }
  getShader(t) {
    if (this._shader && this._shader._version == t._version)
      return this._shader;
    var r = this.computeShader(t, this._shader);
    return r ? (this._shader = r, r._version = t._version, r) : null;
  }
  // some shader nodes could require to fill the box with some uniforms
  fillUniforms(t, r) {
    if (this._uniform_value)
      for (var s in this._uniform_value) {
        var a = this._uniform_value[s];
        a != null && (a.constructor === Function ? t[s] = a.call(this, r) : a.constructor === GL$1.Texture || (t[s] = a));
      }
  }
}
const Ft = class Ft {
  constructor() {
    this.subgraph = new LiteGraph.LGraph(), this.subgraph._subgraph_node = this, this.subgraph._is_subgraph = !0, this.subgraph.filter = "shader", this.addInput("in", "texture"), this.addOutput("out", "texture"), this.properties = {
      width: 0,
      height: 0,
      alpha: !1,
      precision: typeof LGraphTexture != "undefined" ? LGraphTexture.DEFAULT : 2
    };
    var t = this.subgraph.findNodesByType("shader::input/uniform")[0];
    t.pos = [200, 300];
    var r = LiteGraph.createNode("shader::texture/sampler2D");
    r.pos = [400, 300], this.subgraph.add(r);
    var s = LiteGraph.createNode("shader::output/fragcolor");
    s.pos = [600, 300], this.subgraph.add(s), t.connect(0, r), r.connect(0, s), this.size = [180, 60], this.redraw_on_mouse = !0, this._uniforms = {}, this._shader = null, this._context = new LGShaderContext(), this._context.vs_template = `#define VERTEX
` + GL$1.Shader.SCREEN_VERTEX_SHADER, this._context.fs_template = Ft.template;
  }
  onSerialize(t) {
    t.subgraph = this.subgraph.serialize();
  }
  onConfigure(t) {
    this.subgraph.configure(t.subgraph);
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      t && t.constructor != GL$1.Texture && (t = null);
      var r = this.properties.width | 0, s = this.properties.height | 0;
      r == 0 && (r = t ? t.width : gl$1.viewport_data[2]), s == 0 && (s = t ? t.height : gl$1.viewport_data[3]);
      var a = LGraphTexture.getTextureType(
        this.properties.precision,
        t
      ), o = this._texture;
      (!o || o.width != r || o.height != s || o.type != a) && (o = this._texture = new GL$1.Texture(r, s, {
        type: a,
        format: this.alpha ? gl$1.RGBA : gl$1.RGB,
        filter: gl$1.LINEAR
      }));
      var u = this.getShader(this.subgraph);
      if (u) {
        var h = this._uniforms;
        this._context.fillUniforms(h);
        var l = 0;
        if (this.inputs)
          for (var c = 0; c < this.inputs.length; ++c) {
            var d = this.inputs[c], f = this.getInputData(c);
            d.type == "texture" && (f || (f = GL$1.Texture.getWhiteTexture()), f = f.bind(l++)), f != null && (h["u_" + d.name] = f);
          }
        var _ = GL$1.Mesh.getScreenQuad();
        gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.BLEND), o.drawTo(function() {
          u.uniforms(h), u.draw(_);
        }), this.setOutputData(0, o);
      }
    }
  }
  // add input node inside subgraph
  onInputAdded(t) {
    var r = LiteGraph.createNode("shader::input/uniform");
    r.setProperty("name", t.name), r.setProperty("type", t.type), this.subgraph.add(r);
  }
  // remove all
  onInputRemoved(t, r) {
    for (var s = this.subgraph.findNodesByType("shader::input/uniform"), a = 0; a < s.length; ++a) {
      var o = s[a];
      o.properties.name == r.name && this.subgraph.remove(o);
    }
  }
  computeSize() {
    var t = this.inputs ? this.inputs.length : 0, r = this.outputs ? this.outputs.length : 0;
    return [
      200,
      Math.max(t, r) * LiteGraph.NODE_SLOT_HEIGHT + LiteGraph.NODE_TITLE_HEIGHT + 10
    ];
  }
  getShader() {
    var t = this._context.getShader(this.subgraph);
    return t ? this.boxcolor = null : this.boxcolor = "red", t;
  }
  onDrawBackground(t, r, s, a) {
    if (!this.flags.collapsed) {
      var o = this.getOutputData(0), u = this.inputs ? this.inputs.length * LiteGraph.NODE_SLOT_HEIGHT : 0;
      o && t == o.gl && this.size[1] > u + LiteGraph.NODE_TITLE_HEIGHT && t.drawImage(
        o,
        10,
        h,
        this.size[0] - 20,
        this.size[1] - u - LiteGraph.NODE_TITLE_HEIGHT
      );
      var h = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5, l = LiteGraph.isInsideRectangle(
        a[0],
        a[1],
        this.pos[0],
        this.pos[1] + h,
        this.size[0],
        LiteGraph.NODE_TITLE_HEIGHT
      );
      t.fillStyle = l ? "#555" : "#222", t.beginPath(), this._shape == LiteGraph.BOX_SHAPE ? t.rect(0, h, this.size[0] + 1, LiteGraph.NODE_TITLE_HEIGHT) : t.roundRect(
        0,
        h,
        this.size[0] + 1,
        LiteGraph.NODE_TITLE_HEIGHT,
        0,
        8
      ), t.fill(), t.textAlign = "center", t.font = "24px Arial", t.fillStyle = l ? "#DDD" : "#999", t.fillText("+", this.size[0] * 0.5, h + 24);
    }
  }
  onMouseDown(t, r, s) {
    var a = this.size[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5;
    r[1] > a && s.showSubgraphPropertiesDialog(this);
  }
  /*
  * @TODO: Either make it or excise it
  * LGraphShaderGraph.prototype.onDrawSubgraphBackground = function () {};
  */
  getExtraMenuOptions() {
    var t = this, r = [
      {
        content: "Print Code",
        callback: function() {
          var a;
          var s = t._context.computeShaderCode();
          (a = console.log) == null || a.call(console, s.vs_code, s.fs_code);
        }
      }
    ];
    return r;
  }
};
g(Ft, "template", `
        #define FRAGMENT
        precision highp float;
        varying vec2 v_coord;
        {{varying}}
        {{uniforms}}
        {{functions}}
        {{fs_functions}}
        void main() {
    
            vec2 uv = v_coord;
            vec4 fragcolor = vec4(0.0);
            vec4 fragcolor1 = vec4(0.0);
            {{fs_code}}
            gl_FragColor = fragcolor;
        }
    `), g(Ft, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(Ft, "title", "ShaderGraph"), g(Ft, "desc", "Builds a shader using a graph"), g(Ft, "input_node_type", "input/uniform"), g(Ft, "output_node_type", "output/fragcolor"), g(Ft, "title_color", SHADERNODES_COLOR);
let LGraphShaderGraph = Ft;
LiteGraph.registerNodeType("texture/shaderGraph", LGraphShaderGraph);
class LGraphShaderUniform {
  constructor() {
    this.addOutput("out", ""), this.properties = { name: "", type: "" };
  }
  getTitle() {
    return this.properties.name && this.flags.collapsed ? this.properties.type + " " + this.properties.name : "Uniform";
  }
  onPropertyChanged() {
    this.outputs[0].name = this.properties.type + " " + this.properties.name;
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = this.properties.type;
      if (!r) {
        if (!t.onGetPropertyInfo) return;
        var s = t.onGetPropertyInfo(this.property.name);
        if (!s) return;
        r = s.type;
      }
      r == "number" ? r = "float" : r == "texture" && (r = "sampler2D"), LGShaders.GLSL_types.indexOf(r) != -1 && (t.addUniform("u_" + this.properties.name, r), this.setOutputData(0, r));
    }
  }
  getOutputVarName() {
    return "u_" + this.properties.name;
  }
}
g(LGraphShaderUniform, "title", "Uniform"), g(LGraphShaderUniform, "desc", "Input data for the shader");
registerShaderNode("input/uniform", LGraphShaderUniform);
class LGraphShaderAttribute {
  constructor() {
    this.addOutput("out", "vec2"), this.properties = { name: "coord", type: "vec2" };
  }
  getTitle() {
    return "att. " + this.properties.name;
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = this.properties.type;
      !r || LGShaders.GLSL_types.indexOf(r) == -1 || (r == "number" && (r = "float"), this.properties.name != "coord" && t.addCode(
        "varying",
        " varying " + r + " v_" + this.properties.name + ";"
      ), this.setOutputData(0, r));
    }
  }
  getOutputVarName() {
    return "v_" + this.properties.name;
  }
}
g(LGraphShaderAttribute, "title", "Attribute"), g(LGraphShaderAttribute, "desc", "Input data from mesh attribute");
registerShaderNode("input/attribute", LGraphShaderAttribute);
class LGraphShaderSampler2D {
  constructor() {
    this.addInput("tex", "sampler2D"), this.addInput("uv", "vec2"), this.addOutput("rgba", "vec4"), this.addOutput("rgb", "vec3");
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = getInputLinkID(this, 0), s = getShaderNodeVarName(this), a = "vec4 " + s + ` = vec4(0.0);
`;
      if (r) {
        var o = getInputLinkID(this, 1) || t.buffer_names.uvs;
        a += s + " = texture2D(" + r + "," + o + `);
`;
      }
      var u = getOutputLinkID(this, 0);
      u && (a += "vec4 " + getOutputLinkID(this, 0) + " = " + s + `;
`);
      var h = getOutputLinkID(this, 1);
      h && (a += "vec3 " + getOutputLinkID(this, 1) + " = " + s + `.xyz;
`), t.addCode("code", a, this.shader_destination), this.setOutputData(0, "vec4"), this.setOutputData(1, "vec3");
    }
  }
}
g(LGraphShaderSampler2D, "title", "Sampler2D"), g(LGraphShaderSampler2D, "desc", "Reads a pixel from a texture");
registerShaderNode("texture/sampler2D", LGraphShaderSampler2D);
class LGraphShaderConstant {
  constructor() {
    this.addOutput("", "float"), this.properties = {
      type: "float",
      value: 0
    }, this.addWidget("combo", "type", "float", null, {
      values: GLSL_types_const,
      property: "type"
    }), this.updateWidgets();
  }
  getTitle() {
    return this.flags.collapsed ? valueToGLSL(this.properties.value, this.properties.type, 2) : "Const";
  }
  onPropertyChanged(t, r) {
    t == "type" && (this.outputs[0].type != r && (this.disconnectOutput(0), this.outputs[0].type = r), this.widgets.length = 1, this.updateWidgets()), t == "value" && (r.length ? (this.widgets[1].value = r[1], r.length > 2 && (this.widgets[2].value = r[2]), r.length > 3 && (this.widgets[3].value = r[3])) : this.widgets[1].value = r);
  }
  updateWidgets(t) {
    var a;
    var r = this;
    t = this.properties.value;
    var s = { step: 0.01 };
    switch (this.properties.type) {
      case "float":
        this.properties.value = 0, this.addWidget("number", "v", 0, {
          step: 0.01,
          property: "value"
        });
        break;
      case "vec2":
        this.properties.value = t && t.length == 2 ? [t[0], t[1]] : [0, 0, 0], this.addWidget(
          "number",
          "x",
          this.properties.value[0],
          function(o) {
            r.properties.value[0] = o;
          },
          s
        ), this.addWidget(
          "number",
          "y",
          this.properties.value[1],
          function(o) {
            r.properties.value[1] = o;
          },
          s
        );
        break;
      case "vec3":
        this.properties.value = t && t.length == 3 ? [t[0], t[1], t[2]] : [0, 0, 0], this.addWidget(
          "number",
          "x",
          this.properties.value[0],
          function(o) {
            r.properties.value[0] = o;
          },
          s
        ), this.addWidget(
          "number",
          "y",
          this.properties.value[1],
          function(o) {
            r.properties.value[1] = o;
          },
          s
        ), this.addWidget(
          "number",
          "z",
          this.properties.value[2],
          function(o) {
            r.properties.value[2] = o;
          },
          s
        );
        break;
      case "vec4":
        this.properties.value = t && t.length == 4 ? [
          t[0],
          t[1],
          t[2],
          t[3]
        ] : [0, 0, 0, 0], this.addWidget(
          "number",
          "x",
          this.properties.value[0],
          function(o) {
            r.properties.value[0] = o;
          },
          s
        ), this.addWidget(
          "number",
          "y",
          this.properties.value[1],
          function(o) {
            r.properties.value[1] = o;
          },
          s
        ), this.addWidget(
          "number",
          "z",
          this.properties.value[2],
          function(o) {
            r.properties.value[2] = o;
          },
          s
        ), this.addWidget(
          "number",
          "w",
          this.properties.value[3],
          function(o) {
            r.properties.value[3] = o;
          },
          s
        );
        break;
      default:
        (a = console.error) == null || a.call(console, "unknown type for constant");
    }
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = valueToGLSL(this.properties.value, this.properties.type), s = getOutputLinkID(this, 0);
      if (s) {
        var a = "	" + this.properties.type + " " + s + " = " + r + ";";
        t.addCode("code", a, this.shader_destination), this.setOutputData(0, this.properties.type);
      }
    }
  }
}
g(LGraphShaderConstant, "title", "const");
registerShaderNode("const/const", LGraphShaderConstant);
const ee = class ee {
  constructor() {
    this.addInput("xy", "vec2"), this.addInput("x", "float"), this.addInput("y", "float"), this.addOutput("xy", "vec2"), this.addOutput("x", "float"), this.addOutput("y", "float"), this.properties = { x: 0, y: 0 };
  }
  onPropertyChanged() {
    this.graph && this.graph._version++;
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = this.properties, s = getShaderNodeVarName(this), a = "	vec2 " + s + " = " + valueToGLSL([r.x, r.y]) + `;
`;
      for (let l = 0; l < ee.varmodes.length; ++l) {
        let c = ee.varmodes[l];
        var o = getInputLinkID(this, l);
        o && (a += "	" + s + "." + c + " = " + o + `;
`);
      }
      for (let l = 0; l < ee.varmodes.length; ++l) {
        let c = ee.varmodes[l];
        var u = getOutputLinkID(this, l);
        if (u) {
          var h = GLSL_types_const[c.length - 1];
          a += "	" + h + " " + u + " = " + s + "." + c + `;
`, this.setOutputData(l, h);
        }
      }
      t.addCode("code", a, this.shader_destination);
    }
  }
};
g(ee, "title", "vec2"), g(ee, "varmodes", ["xy", "x", "y"]);
let LGraphShaderVec2 = ee;
registerShaderNode("const/vec2", LGraphShaderVec2);
const re = class re {
  constructor() {
    this.addInput("xyz", "vec3"), this.addInput("x", "float"), this.addInput("y", "float"), this.addInput("z", "float"), this.addInput("xy", "vec2"), this.addInput("xz", "vec2"), this.addInput("yz", "vec2"), this.addOutput("xyz", "vec3"), this.addOutput("x", "float"), this.addOutput("y", "float"), this.addOutput("z", "float"), this.addOutput("xy", "vec2"), this.addOutput("xz", "vec2"), this.addOutput("yz", "vec2"), this.properties = { x: 0, y: 0, z: 0 };
  }
  onPropertyChanged() {
    this.graph && this.graph._version++;
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = this.properties, s = getShaderNodeVarName(this), a = "vec3 " + s + " = " + valueToGLSL([r.x, r.y, r.z]) + `;
`;
      for (let u = 0; u < re.varmodes.length; ++u) {
        let h = re.varmodes[u], l = getInputLinkID(this, u);
        l && (a += "	" + s + "." + h + " = " + l + `;
`);
      }
      for (let u = 0; u < re.varmodes.length; ++u) {
        let h = re.varmodes[u], l = getOutputLinkID(this, u);
        if (l) {
          var o = GLSL_types_const[h.length - 1];
          a += "	" + o + " " + l + " = " + s + "." + h + `;
`, this.setOutputData(u, o);
        }
      }
      t.addCode("code", a, this.shader_destination);
    }
  }
};
g(re, "title", "vec3"), g(re, "varmodes", ["xyz", "x", "y", "z", "xy", "xz", "yz"]);
let LGraphShaderVec3 = re;
registerShaderNode("const/vec3", LGraphShaderVec3);
const ie = class ie {
  constructor() {
    this.addInput("xyzw", "vec4"), this.addInput("xyz", "vec3"), this.addInput("x", "float"), this.addInput("y", "float"), this.addInput("z", "float"), this.addInput("w", "float"), this.addInput("xy", "vec2"), this.addInput("yz", "vec2"), this.addInput("zw", "vec2"), this.addOutput("xyzw", "vec4"), this.addOutput("xyz", "vec3"), this.addOutput("x", "float"), this.addOutput("y", "float"), this.addOutput("z", "float"), this.addOutput("xy", "vec2"), this.addOutput("yz", "vec2"), this.addOutput("zw", "vec2"), this.properties = { x: 0, y: 0, z: 0, w: 0 };
  }
  onPropertyChanged() {
    this.graph && this.graph._version++;
  }
  onGetCode(t) {
    if (this.shader_destination) {
      var r = this.properties, s = getShaderNodeVarName(this), a = "vec4 " + s + " = " + valueToGLSL([r.x, r.y, r.z, r.w]) + `;
`;
      for (let u = 0; u < ie.varmodes.length; ++u) {
        let h = ie.varmodes[u], l = getInputLinkID(this, u);
        l && (a += "	" + s + "." + h + " = " + l + `;
`);
      }
      for (let u = 0; u < ie.varmodes.length; ++u) {
        let h = ie.varmodes[u], l = getOutputLinkID(this, u);
        if (l) {
          var o = GLSL_types_const[h.length - 1];
          a += "	" + o + " " + l + " = " + s + "." + h + `;
`, this.setOutputData(u, o);
        }
      }
      t.addCode("code", a, this.shader_destination);
    }
  }
};
g(ie, "title", "vec4"), g(ie, "varmodes", [
  "xyzw",
  "xyz",
  "x",
  "y",
  "z",
  "w",
  "xy",
  "yz",
  "zw"
]);
let LGraphShaderVec4 = ie;
registerShaderNode("const/vec4", LGraphShaderVec4);
class LGraphShaderFragColor {
  constructor() {
    this.addInput("color", LGShaders.ALL_TYPES), this.block_delete = !0;
  }
  onGetCode(t) {
    var r = getInputLinkID(this, 0);
    if (r) {
      var s = this.getInputData(0), a = varToTypeGLSL(r, s, "vec4");
      t.addCode("fs_code", "fragcolor = " + a + ";");
    }
  }
}
g(LGraphShaderFragColor, "title", "FragColor"), g(LGraphShaderFragColor, "desc", "Pixel final color");
registerShaderNode("output/fragcolor", LGraphShaderFragColor);
const Le = class Le {
  constructor() {
    this.addInput("A", LGShaders.ALL_TYPES), this.addInput("B", LGShaders.ALL_TYPES), this.addOutput("out", ""), this.properties = { operation: "*" }, this.addWidget("combo", "op.", this.properties.operation, {
      property: "operation",
      values: Le.operations
    });
  }
  getTitle() {
    return this.flags.collapsed ? "A" + this.properties.operation + "B" : "Operation";
  }
  onGetCode(t) {
    if (this.shader_destination && this.isOutputConnected(0)) {
      var r = [];
      for (let c = 0; c < 3; ++c)
        r.push({
          name: getInputLinkID(this, c),
          type: this.getInputData(c) || "float"
        });
      var s = getOutputLinkID(this, 0);
      if (s) {
        var a = r[0].type, o = a, u = this.properties.operation, h = [];
        for (let c = 0; c < 2; ++c) {
          var l = r[c].name;
          l == null && (l = p.value != null ? p.value : "(1.0)", r[c].type = "float"), r[c].type != a && (r[c].type == "float" && (u == "*" || u == "/") || (l = convertVarToGLSLType(
            l,
            r[c].type,
            a
          ))), h.push(l);
        }
        t.addCode(
          "code",
          o + " " + s + " = " + h[0] + u + h[1] + ";",
          this.shader_destination
        ), this.setOutputData(0, o);
      }
    }
  }
};
g(Le, "title", "Operation"), g(Le, "operations", ["+", "-", "*", "/"]);
let LGraphShaderOperation = Le;
registerShaderNode("math/operation", LGraphShaderOperation);
class LGraphShaderFunc {
  constructor() {
    this.addInput("A", LGShaders.ALL_TYPES), this.addInput("B", LGShaders.ALL_TYPES), this.addOutput("out", ""), this.properties = { func: "floor" }, this._current = "floor", this.addWidget(
      "combo",
      "func",
      this.properties.func,
      {
        property: "func",
        values: GLSL_functions_name
      }
    );
  }
  onPropertyChanged(t, r) {
    if (this.graph && this.graph._version++, t == "func") {
      var s = GLSL_functions[r];
      if (!s)
        return;
      for (let o = s.params.length; o < this.inputs.length; ++o)
        this.removeInput(o);
      for (let o = 0; o < s.params.length; ++o) {
        var a = s.params[o];
        this.inputs[o] ? this.inputs[o].name = a.name + (a.value ? " (" + a.value + ")" : "") : this.addInput(a.name, LGShaders.ALL_TYPES);
      }
    }
  }
  getTitle() {
    return this.flags.collapsed ? this.properties.func : "Func";
  }
  onGetCode(t) {
    if (this.shader_destination && this.isOutputConnected(0)) {
      var r = [];
      for (let d = 0; d < 3; ++d)
        r.push({
          name: getInputLinkID(this, d),
          type: this.getInputData(d) || "float"
        });
      var s = getOutputLinkID(this, 0);
      if (s) {
        var a = GLSL_functions[this.properties.func];
        if (a) {
          var o = r[0].type, u = a.return_type;
          u == "T" && (u = o);
          var h = [];
          for (let d = 0; d < a.params.length; ++d) {
            var l = a.params[d], c = r[d].name;
            c == null && (c = l.value != null ? l.value : "(1.0)", r[d].type = "float"), (l.type == "T" && r[d].type != o || l.type != "T" && r[d].type != o) && (c = convertVarToGLSLType(
              c,
              r[d].type,
              o
            )), h.push(c);
          }
          t.addFunction(
            "round",
            `float round(float v){ return floor(v+0.5); }
vec2 round(vec2 v){ return floor(v+vec2(0.5));}
vec3 round(vec3 v){ return floor(v+vec3(0.5));}
vec4 round(vec4 v){ return floor(v+vec4(0.5)); }
`
          ), t.addCode(
            "code",
            u + " " + s + " = " + a.func + "(" + h.join(",") + ");",
            this.shader_destination
          ), this.setOutputData(0, u);
        }
      }
    }
  }
}
g(LGraphShaderFunc, "title", "Func");
registerShaderNode("math/func", LGraphShaderFunc);
class LGraphShaderSnippet {
  constructor() {
    this.addInput("A", LGShaders.ALL_TYPES), this.addInput("B", LGShaders.ALL_TYPES), this.addOutput("C", "vec4"), this.properties = {
      code: "C = A+B",
      type: "vec4"
    }, this.addWidget("text", "code", this.properties.code, { property: "code" }), this.addWidget("combo", "type", this.properties.type, {
      values: ["float", "vec2", "vec3", "vec4"],
      property: "type"
    });
  }
  onPropertyChanged(t, r) {
    this.graph && this.graph._version++, t == "type" && this.outputs[0].type != r && (this.disconnectOutput(0), this.outputs[0].type = r);
  }
  getTitle() {
    return this.flags.collapsed ? this.properties.code : "Snippet";
  }
  onGetCode(t) {
    if (!(!this.shader_destination || !this.isOutputConnected(0))) {
      var r = getInputLinkID(this, 0);
      r || (r = "1.0");
      var s = getInputLinkID(this, 1);
      s || (s = "1.0");
      var a = getOutputLinkID(this, 0);
      if (a) {
        var o = this.getInputData(0) || "float", u = this.getInputData(1) || "float", h = this.properties.type;
        if (o == "T" || u == "T")
          return null;
        var l = "funcSnippet" + this.id, c = `
` + h + " " + l + "( " + o + " A, " + u + ` B) {
`;
        c += "	" + h + " C = " + h + `(0.0);
`, c += "	" + this.properties.code + `;
`, c += `	return C;
}
`, t.addCode("functions", c, this.shader_destination), t.addCode(
          "code",
          h + " " + a + " = " + l + "(" + r + "," + s + ");",
          this.shader_destination
        ), this.setOutputData(0, h);
      }
    }
  }
}
g(LGraphShaderSnippet, "title", "Snippet");
registerShaderNode("utils/snippet", LGraphShaderSnippet);
class LGraphShaderRand {
  constructor() {
    this.addOutput("out", "float");
  }
  onGetCode(t) {
    if (!(!this.shader_destination || !this.isOutputConnected(0))) {
      var r = getOutputLinkID(this, 0);
      t.addUniform("u_rand" + this.id, "float", function() {
        return Math.random();
      }), t.addCode(
        "code",
        "float " + r + " = u_rand" + this.id + ";",
        this.shader_destination
      ), this.setOutputData(0, "float");
    }
  }
}
g(LGraphShaderRand, "title", "Rand");
registerShaderNode("input/rand", LGraphShaderRand);
const pe = class pe {
  constructor() {
    this.addInput("out", LGShaders.ALL_TYPES), this.addInput("scale", "float"), this.addOutput("out", "float"), this.properties = {
      type: "noise",
      scale: 1
    }, this.addWidget("combo", "type", this.properties.type, {
      property: "type",
      values: pe.NOISE_TYPES
    }), this.addWidget("number", "scale", this.properties.scale, { property: "scale" });
  }
  onGetCode(t) {
    if (!(!this.shader_destination || !this.isOutputConnected(0))) {
      var r = getInputLinkID(this, 0), s = getOutputLinkID(this, 0), a = this.getInputData(0);
      r || (a = "vec2", r = t.buffer_names.uvs), t.addFunction("noise", pe.shader_functions), t.addUniform(
        "u_noise_scale" + this.id,
        "float",
        this.properties.scale
      ), a == "float" ? t.addCode(
        "code",
        "float " + s + " = snoise( vec2(" + r + ") * u_noise_scale" + this.id + ");",
        this.shader_destination
      ) : a == "vec2" || a == "vec3" ? t.addCode(
        "code",
        "float " + s + " = snoise(" + r + " * u_noise_scale" + this.id + ");",
        this.shader_destination
      ) : a == "vec4" && t.addCode(
        "code",
        "float " + s + " = snoise(" + r + ".xyz * u_noise_scale" + this.id + ");",
        this.shader_destination
      ), this.setOutputData(0, "float");
    }
  }
};
g(pe, "NOISE_TYPES", ["noise", "rand"]), g(pe, "title", "noise"), g(pe, "shader_functions", `
        vec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }

        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
            m = m * m ;
            m = m * m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
            vec3 g;
            g.x = a0.x  * x0.x + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

        vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }

        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);

            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);

            vec3 x1 = x0 - i1 + 1.0 * C.xxx;
            vec3 x2 = x0 - i2 + 2.0 * C.xxx;
            vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

            i = mod(i, 289.0);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));

            float n_ = 1.0 / 7.0;
            vec3 ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            
            return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
        }

        vec3 hash3(vec2 p) {
            vec3 q = vec3(dot(p, vec2(127.1, 311.7)),
                        dot(p, vec2(269.5, 183.3)),
                        dot(p, vec2(419.2, 371.9)));
            return fract(sin(q) * 43758.5453);
        }

        vec4 hash4(vec3 p) {
            vec4 q = vec4(dot(p, vec3(127.1, 311.7, 257.3)),
                        dot(p, vec3(269.5, 183.3, 335.1)),
                        dot(p, vec3(314.5, 235.1, 467.3)),
                        dot(p, vec3(419.2, 371.9, 114.9)));
            return fract(sin(q) * 43758.5453);
        }

        float iqnoise(in vec2 x, float u, float v) {
            vec2 p = floor(x);
            vec2 f = fract(x);
            
            float k = 1.0 + 63.0 * pow(1.0 - v, 4.0);
            
            float va = 0.0;
            float wt = 0.0;
            for (int j = -2; j <= 2; j++)
                for (int i = -2; i <= 2; i++) {
                    vec2 g = vec2(float(i), float(j));
                    vec3 o = hash3(p + g) * vec3(u, u, 1.0);
                    vec2 r = g - f + o.xy;
                    float d = dot(r, r);
                    float ww = pow(1.0 - smoothstep(0.0, 1.414, sqrt(d)), k);
                    va += o.z * ww;
                    wt += ww;
                }
            
            return va / wt;
        }
    `);
let LGraphShaderNoise = pe;
registerShaderNode("math/noise", LGraphShaderNoise);
class LGraphShaderTime {
  constructor() {
    this.addOutput("out", "float");
  }
  onGetCode(t) {
    if (!(!this.shader_destination || !this.isOutputConnected(0))) {
      var r = getOutputLinkID(this, 0);
      t.addUniform("u_time" + this.id, "float", function() {
        return getTime() * 1e-3;
      }), t.addCode(
        "code",
        "float " + r + " = u_time" + this.id + ";",
        this.shader_destination
      ), this.setOutputData(0, "float");
    }
  }
}
g(LGraphShaderTime, "title", "Time");
registerShaderNode("input/time", LGraphShaderTime);
const de = class de {
  constructor() {
    this.addInput("in", "T"), this.addOutput("out", "float");
  }
  onGetCode(t) {
    if (!(!this.shader_destination || !this.isOutputConnected(0))) {
      var r = getInputLinkID(this, 0), s = "float", a = getOutputLinkID(this, 0), o = this.getInputData(0);
      r = varToTypeGLSL(r, o, "float"), t.addFunction("dither8x8", de.dither_func), t.addCode(
        "code",
        s + " " + a + " = dither8x8(" + r + ");",
        this.shader_destination
      ), this.setOutputData(0, s);
    }
  }
};
g(de, "title", "Dither"), g(de, "dither_values", [
  0.515625,
  0.140625,
  0.640625,
  0.046875,
  0.546875,
  0.171875,
  0.671875,
  0.765625,
  0.265625,
  0.890625,
  0.390625,
  0.796875,
  0.296875,
  0.921875,
  0.421875,
  0.203125,
  0.703125,
  0.078125,
  0.578125,
  0.234375,
  0.734375,
  0.109375,
  0.609375,
  0.953125,
  0.453125,
  0.828125,
  0.328125,
  0.984375,
  0.484375,
  0.859375,
  0.359375,
  0.0625,
  0.5625,
  0.1875,
  0.6875,
  0.03125,
  0.53125,
  0.15625,
  0.65625,
  0.8125,
  0.3125,
  0.9375,
  0.4375,
  0.78125,
  0.28125,
  0.90625,
  0.40625,
  0.25,
  0.75,
  0.125,
  0.625,
  0.21875,
  0.71875,
  0.09375,
  0.59375,
  1.0001,
  0.5,
  0.875,
  0.375,
  0.96875,
  0.46875,
  0.84375,
  0.34375
]), g(de, "dither_func", `
        float dither8x8(float brightness) {
            vec2 position = vec2(0.0);
            #ifdef FRAGMENT
            position = gl_FragCoord.xy;
            #endif
            int x = int(mod(position.x, 8.0));
            int y = int(mod(position.y, 8.0));
            int index = x + y * 8;
            float limit = 0.0;
            if (x < 8) {
                if (index == 0) limit = 0.015625;
                // Add more conditions or code here if needed
                // Example: if (condition) { ... }
            }
            ${de.dither_values.map((t, r) => `else if (index == ${r + 1}) limit = ${t};`).join(`
`)}
            return brightness < limit ? 0.0 : 1.0;
        }
    `);
let LGraphShaderDither = de;
registerShaderNode("math/dither", LGraphShaderDither);
class LGraphShaderRemap {
  constructor() {
    this.addInput("", LGShaders.ALL_TYPES), this.addOutput("", ""), this.properties = {
      min_value: 0,
      max_value: 1,
      min_value2: 0,
      max_value2: 1
    }, this.addWidget("number", "min", 0, {
      step: 0.1,
      property: "min_value"
    }), this.addWidget("number", "max", 1, {
      step: 0.1,
      property: "max_value"
    }), this.addWidget("number", "min2", 0, {
      step: 0.1,
      property: "min_value2"
    }), this.addWidget("number", "max2", 1, {
      step: 0.1,
      property: "max_value2"
    });
  }
  onPropertyChanged() {
    this.graph && this.graph._version++;
  }
  onConnectionsChange() {
    var t = this.getInputDataType(0);
    this.outputs[0].type = t || "T";
  }
  onGetCode(t) {
    var c;
    if (!(!this.shader_destination || !this.isOutputConnected(0))) {
      var r = getInputLinkID(this, 0), s = getOutputLinkID(this, 0);
      if (!(!r && !s)) {
        var a = this.getInputDataType(0);
        if (this.outputs[0].type = a, a == "T") {
          (c = console.warn) == null || c.call(console, "node type is T and cannot be resolved");
          return;
        }
        if (!r) {
          t.addCode(
            "code",
            "	" + a + " " + s + " = " + a + `(0.0);
`
          );
          return;
        }
        var o = valueToGLSL(this.properties.min_value), u = valueToGLSL(this.properties.max_value), h = valueToGLSL(this.properties.min_value2), l = valueToGLSL(this.properties.max_value2);
        t.addCode(
          "code",
          `${a} ${s} = ( (${r} - ${o}) / (${u} - ${o}) ) * (${l} - ${h}) + ${h};`,
          this.shader_destination
        ), this.setOutputData(0, a);
      }
    }
  }
}
g(LGraphShaderRemap, "title", "Remap");
registerShaderNode("math/remap", LGraphShaderRemap);
function generateGeometryId() {
  return Math.random() * 1e5 | 0;
}
const j = class j {
  constructor() {
    this.addInput("obj", ""), this.addInput("radius", "number"), this.addOutput("out", "geometry"), this.addOutput("points", "[vec3]"), this.properties = {
      radius: 1,
      num_points: 4096,
      generate_normals: !0,
      regular: !1,
      mode: j.SPHERE,
      force_update: !1
    }, this.points = new Float32Array(this.properties.num_points * 3), this.normals = new Float32Array(this.properties.num_points * 3), this.must_update = !0, this.version = 0;
    var t = this;
    this.addWidget("button", "update", null, function() {
      t.must_update = !0;
    }), this.geometry = {
      vertices: null,
      _id: generateGeometryId()
    }, this._old_obj = null, this._last_radius = null;
  }
  onPropertyChanged(t, r) {
    this.must_update = !0;
  }
  onExecute() {
    var t = this.getInputData(0);
    (t != this._old_obj || t && t._version != this._old_obj_version) && (this._old_obj = t, this.must_update = !0);
    var r = this.getInputData(1);
    r == null && (r = this.properties.radius), this._last_radius != r && (this._last_radius = r, this.must_update = !0), (this.must_update || this.properties.force_update) && (this.must_update = !1, this.updatePoints()), this.geometry.vertices = this.points, this.geometry.normals = this.normals, this.geometry._version = this.version, this.setOutputData(0, this.geometry);
  }
  updatePoints() {
    var t = this.properties.num_points | 0;
    t < 1 && (t = 1), (!this.points || this.points.length != t * 3) && (this.points = new Float32Array(t * 3)), this.properties.generate_normals ? (!this.normals || this.normals.length != this.points.length) && (this.normals = new Float32Array(this.points.length)) : this.normals = null;
    var r = this._last_radius || this.properties.radius, s = this.properties.mode, a = this.getInputData(0);
    this._old_obj_version = a ? a._version : null, this.points = j.generatePoints(
      r,
      t,
      s,
      this.points,
      this.normals,
      this.properties.regular,
      a
    ), this.version++;
  }
  static generatePoints(t, r, s, a, o, u, h) {
    var f;
    var l = r * 3;
    (!a || a.length != l) && (a = new Float32Array(l));
    var c = new Float32Array(3), d = new Float32Array([0, 1, 0]);
    if (u) {
      if (s == j.RECTANGLE) {
        let _ = Math.floor(Math.sqrt(r));
        for (let E = 0; E < _; ++E)
          for (let m = 0; m < _; ++m) {
            let T = E * 3 + m * 3 * _;
            a[T] = (E / _ - 0.5) * t * 2, a[T + 1] = 0, a[T + 2] = (m / _ - 0.5) * t * 2;
          }
        if (a = new Float32Array(a.subarray(0, _ * _ * 3)), o)
          for (let E = 0; E < o.length; E += 3)
            o.set(d, E);
      } else if (s == j.SPHERE) {
        let _ = Math.floor(Math.sqrt(r));
        for (let E = 0; E < _; ++E)
          for (let m = 0; m < _; ++m) {
            let T = E * 3 + m * 3 * _;
            GL.polarToCartesian(
              c,
              E / _ * 2 * Math.PI,
              (m / _ - 0.5) * 2 * Math.PI,
              t
            ), a[T] = c[0], a[T + 1] = c[1], a[T + 2] = c[2];
          }
        a = new Float32Array(a.subarray(0, _ * _ * 3)), o && j.generateSphericalNormals(a, o);
      } else if (s == j.CIRCLE) {
        for (let _ = 0; _ < l; _ += 3) {
          let E = 2 * Math.PI * (_ / l);
          a[_] = Math.cos(E) * t, a[_ + 1] = 0, a[_ + 2] = Math.sin(E) * t;
        }
        if (o)
          for (let _ = 0; _ < o.length; _ += 3)
            o.set(d, _);
      }
    } else if (s == j.RECTANGLE) {
      for (let _ = 0; _ < l; _ += 3)
        a[_] = (Math.random() - 0.5) * t * 2, a[_ + 1] = 0, a[_ + 2] = (Math.random() - 0.5) * t * 2;
      if (o)
        for (let _ = 0; _ < o.length; _ += 3)
          o.set(d, _);
    } else if (s == j.CUBE) {
      for (let _ = 0; _ < l; _ += 3)
        a[_] = (Math.random() - 0.5) * t * 2, a[_ + 1] = (Math.random() - 0.5) * t * 2, a[_ + 2] = (Math.random() - 0.5) * t * 2;
      if (o)
        for (let _ = 0; _ < o.length; _ += 3)
          o.set(d, _);
    } else s == j.SPHERE ? (j.generateSphere(a, l, t), o && j.generateSphericalNormals(a, o)) : s == j.HEMISPHERE ? (j.generateHemisphere(a, l, t), o && j.generateSphericalNormals(a, o)) : s == j.CIRCLE ? (j.generateInsideCircle(a, l, t), o && j.generateSphericalNormals(a, o)) : s == j.INSIDE_SPHERE ? (j.generateInsideSphere(a, l, t), o && j.generateSphericalNormals(a, o)) : s == j.OBJECT ? j.generateFromObject(
      a,
      o,
      l,
      h,
      !1
    ) : s == j.OBJECT_UNIFORMLY ? j.generateFromObject(a, o, l, h, !0) : s == j.OBJECT_INSIDE ? j.generateFromInsideObject(a, l, h) : (f = console.warn) == null || f.call(console, "wrong mode in LGraphPoints3D");
    return a;
  }
  static generateSphericalNormals(t, r) {
    for (var s = new Float32Array(3), a = 0; a < r.length; a += 3)
      s[0] = t[a], s[1] = t[a + 1], s[2] = t[a + 2], vec3.normalize(s, s), r.set(s, a);
  }
  static generateSphere(t, r, s) {
    for (var a = 0; a < r; a += 3) {
      var o = Math.random(), u = Math.random(), h = 2 * Math.cos(2 * Math.PI * o) * Math.sqrt(u * (1 - u)), l = 1 - 2 * u, c = 2 * Math.sin(2 * Math.PI * o) * Math.sqrt(u * (1 - u));
      t[a] = h * s, t[a + 1] = l * s, t[a + 2] = c * s;
    }
  }
  static generateHemisphere(t, r, s) {
    for (var a = 0; a < r; a += 3) {
      var o = Math.random(), u = Math.random(), h = Math.cos(2 * Math.PI * o) * Math.sqrt(1 - u * u), l = u, c = Math.sin(2 * Math.PI * o) * Math.sqrt(1 - u * u);
      t[a] = h * s, t[a + 1] = l * s, t[a + 2] = c * s;
    }
  }
  static generateInsideCircle(t, r, s) {
    for (var a = 0; a < r; a += 3) {
      var o = Math.random(), u = Math.random(), h = Math.cos(2 * Math.PI * o) * Math.sqrt(1 - u * u), l = Math.sin(2 * Math.PI * o) * Math.sqrt(1 - u * u);
      t[a] = h * s, t[a + 1] = 0, t[a + 2] = l * s;
    }
  }
  static generateInsideSphere(t, r, s) {
    for (var a = 0; a < r; a += 3) {
      var o = Math.random(), u = Math.random(), h = o * 2 * Math.PI, l = Math.acos(2 * u - 1), c = Math.cbrt(Math.random()) * s, d = Math.sin(h), f = Math.cos(h), _ = Math.sin(l), E = Math.cos(l);
      t[a] = c * _ * f, t[a + 1] = c * _ * d, t[a + 2] = c * E;
    }
  }
  static generateFromObject(t, r, s, a, o) {
    if (!a) return;
    var u = null, h = null, l = null, c = null;
    function d(F, V) {
      var $ = F.length, U = 0, H = 0, z = $;
      if ($ == 0) return -1;
      if ($ == 1) return 0;
      for (; z >= U; ) {
        H = (z + U) * 0.5 | 0;
        var K = F[H];
        if (K == V) return H;
        if (U == z - 1) return U;
        K < V ? U = H : z = H;
      }
      return H;
    }
    if (a.constructor === GL.Mesh && (u = a.vertexBuffers.vertices.data, h = a.vertexBuffers.normals ? a.vertexBuffers.normals.data : null, l = a.indexBuffers.indices ? a.indexBuffers.indices.data : null, l || (l = a.indexBuffers.triangles ? a.indexBuffers.triangles.data : null)), !u) return null;
    var f = l ? l.length / 3 : u.length / 9, _ = 0;
    if (o) {
      c = new Float32Array(f);
      for (let F = 0; F < f; ++F) {
        l ? (N = l[F * 3] * 3, C = l[F * 3 + 1] * 3, D = l[F * 3 + 2] * 3) : (N = F * 9, C = F * 9 + 3, D = F * 9 + 6);
        var E = u.subarray(N, N + 3), m = u.subarray(C, C + 3), T = u.subarray(D, D + 3), L = vec3.distance(E, m), G = vec3.distance(m, T), O = vec3.distance(T, E), b = (L + G + O) / 2;
        _ += Math.sqrt(b * (b - L) * (b - G) * (b - O)), c[F] = _;
      }
      for (let F = 0; F < f; ++F)
        c[F] /= _;
    }
    for (let F = 0; F < s; F += 3) {
      var I = Math.random(), S = o ? d(c, I) : Math.floor(I * f), N = 0, C = 0, D = 0;
      l ? (N = l[S * 3] * 3, C = l[S * 3 + 1] * 3, D = l[S * 3 + 2] * 3) : (N = S * 9, C = S * 9 + 3, D = S * 9 + 6);
      var b = Math.random(), M = Math.random(), P = Math.sqrt(b), A = 1 - P, R = P * (1 - M), B = M * P;
      if (t[F] = A * u[N] + R * u[C] + B * u[D], t[F + 1] = A * u[N + 1] + R * u[C + 1] + B * u[D + 1], t[F + 2] = A * u[N + 2] + R * u[C + 2] + B * u[D + 2], r && h) {
        r[F] = A * h[N] + R * h[C] + B * h[D], r[F + 1] = A * h[N + 1] + R * h[C + 1] + B * h[D + 1], r[F + 2] = A * h[N + 2] + R * h[C + 2] + B * h[D + 2];
        var X = r.subarray(F, F + 3);
        vec3.normalize(X, X);
      }
    }
  }
  static generateFromInsideObject(t, r, s) {
    if (!(!s || s.constructor !== GL.Mesh)) {
      var a = s.getBoundingBox();
      s.octree || (s.octree = new GL.Octree(s));
      for (var o = s.octree, u = vec3.create(), h = vec3.fromValues(1, 0, 0), l = vec3.create(), c = 0, d = 0; c < r && d < t.length * 10; ) {
        d += 1;
        var f = vec3.random(l);
        f[0] = (f[0] * 2 - 1) * a[3] + a[0], f[1] = (f[1] * 2 - 1) * a[4] + a[1], f[2] = (f[2] * 2 - 1) * a[5] + a[2], u.set(f);
        var _ = o.testRay(
          u,
          h,
          0,
          1e4,
          !0,
          GL.Octree.ALL
        );
        !_ || _.length % 2 == 0 || (t.set(f, c), c += 3);
      }
    }
  }
};
g(j, "RECTANGLE", 1), g(j, "CIRCLE", 2), g(j, "CUBE", 10), g(j, "SPHERE", 11), g(j, "HEMISPHERE", 12), g(j, "INSIDE_SPHERE", 13), g(j, "OBJECT", 20), g(j, "OBJECT_UNIFORMLY", 21), g(j, "OBJECT_INSIDE", 22), g(j, "MODE_VALUES", {
  rectangle: j.RECTANGLE,
  circle: j.CIRCLE,
  cube: j.CUBE,
  sphere: j.SPHERE,
  hemisphere: j.HEMISPHERE,
  inside_sphere: j.INSIDE_SPHERE,
  object: j.OBJECT,
  object_uniformly: j.OBJECT_UNIFORMLY,
  object_inside: j.OBJECT_INSIDE
}), g(j, "widgets_info", {
  mode: {
    widget: "combo",
    values: j.MODE_VALUES
  }
}), g(j, "title", "list of points"), g(j, "desc", "returns an array of points");
let LGraphPoints3D = j;
LiteGraph.registerNodeType("geometry/points3D", LGraphPoints3D);
const ht = class ht {
  constructor() {
    this.addInput("points", "geometry"), this.addOutput("instances", "[mat4]"), this.properties = {
      mode: 1,
      autoupdate: !0
    }, this.must_update = !0, this.matrices = [], this.first_time = !0;
  }
  onExecute() {
    var t = this.getInputData(0);
    if (!t) {
      this.setOutputData(0, null);
      return;
    }
    if (this.isOutputConnected(0)) {
      var r = t._version != this._version || t._id != this._geometry_id;
      (r && this.properties.autoupdate || this.first_time) && (this.first_time = !1, this.updateInstances(t)), this.setOutputData(0, this.matrices);
    }
  }
  updateInstances(t) {
    var r = t.vertices;
    if (!r) return null;
    var s = t.normals, a = this.matrices, o = r.length / 3;
    a.length != o && (a.length = o);
    for (var u = mat4.create(), h = vec3.create(), l = vec3.fromValues(0, 1, 0), c = vec3.fromValues(0, 0, -1), d = quat.create(), f = vec3.create(), _ = vec3.create(), E = vec3.create(), m = 0; m < r.length; m += 3) {
      var T = m / 3, L = a[T];
      L || (L = a[T] = mat4.create()), L.set(u);
      var G = r.subarray(m, m + 3);
      switch (this.properties.mode) {
        case ht.NORMAL:
          if (mat4.setTranslation(L, G), s) {
            var O = s.subarray(m, m + 3);
            E.set(O), vec3.normalize(E, E), vec3.cross(_, c, E), vec3.normalize(_, _), vec3.cross(f, _, E), vec3.normalize(f, f), L.set(_, 0), L.set(E, 4), L.set(f, 8), mat4.setTranslation(L, G);
          }
          break;
        case ht.VERTICAL:
          mat4.setTranslation(L, G);
          break;
        case ht.SPHERICAL:
          f.set(G), vec3.normalize(f, f), vec3.cross(_, l, f), vec3.normalize(_, _), vec3.cross(E, f, _), vec3.normalize(E, E), L.set(_, 0), L.set(E, 4), L.set(f, 8), mat4.setTranslation(L, G);
          break;
        case ht.RANDOM:
          h[0] = Math.random() * 2 - 1, h[1] = Math.random() * 2 - 1, h[2] = Math.random() * 2 - 1, vec3.normalize(h, h), quat.setAxisAngle(d, h, Math.random() * 2 * Math.PI), mat4.fromQuat(L, d), mat4.setTranslation(L, G);
          break;
        case ht.RANDOM_VERTICAL:
          quat.setAxisAngle(d, l, Math.random() * 2 * Math.PI), mat4.fromQuat(L, d), mat4.setTranslation(L, G);
          break;
      }
    }
    this._version = t._version, this._geometry_id = t._id;
  }
};
g(ht, "NORMAL", 0), g(ht, "VERTICAL", 1), g(ht, "SPHERICAL", 2), g(ht, "RANDOM", 3), g(ht, "RANDOM_VERTICAL", 4), g(ht, "modes", {
  normal: 0,
  vertical: 1,
  spherical: 2,
  random: 3,
  random_vertical: 4
}), g(ht, "widgets_info", {
  mode: {
    widget: "combo",
    values: ht.modes
  }
}), g(ht, "title", "points to inst");
let LGraphPointsToInstances = ht;
LiteGraph.registerNodeType("geometry/points_to_instances", LGraphPointsToInstances);
class LGraphGeometryTransform {
  constructor() {
    this.addInput("in", "geometry,[mat4]"), this.addInput("mat4", "mat4"), this.addOutput("out", "geometry"), this.properties = {}, this.geometry = {
      type: "triangles",
      vertices: null,
      _id: generateGeometryId(),
      _version: 0
    }, this._last_geometry_id = -1, this._last_version = -1, this._last_key = "", this.must_update = !0;
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1);
    if (t) {
      if (t.constructor === Array) {
        if (t.length == 0 || (this.outputs[0].type = "[mat4]", !this.isOutputConnected(0))) return;
        if (!r) {
          this.setOutputData(0, t);
          return;
        }
        this._output || (this._output = new Array()), this._output.length != t.length && (this._output.length = t.length);
        for (var s = 0; s < t.length; ++s) {
          var a = this._output[s];
          a || (a = this._output[s] = mat4.create()), mat4.multiply(a, t[s], r);
        }
        this.setOutputData(0, this._output);
        return;
      }
      if (!(!t.vertices || !t.vertices.length)) {
        var o = t;
        if (this.outputs[0].type = "geometry", !!this.isOutputConnected(0)) {
          if (!r) {
            this.setOutputData(0, o);
            return;
          }
          var u = Array.from(r).join(",");
          (this.must_update || o._id != this._last_geometry_id || o._version != this._last_version || u != this._last_key) && (this.updateGeometry(o, r), this._last_key = u, this._last_version = o._version, this._last_geometry_id = o._id, this.must_update = !1), this.setOutputData(0, this.geometry);
        }
      }
    }
  }
  updateGeometry(t, r) {
    var s = t.vertices, a = this.geometry.vertices;
    (!a || a.length != s.length) && (a = this.geometry.vertices = new Float32Array(s.length));
    var o = vec3.create();
    for (let c = 0, d = a.length; c < d; c += 3)
      o[0] = s[c], o[1] = s[c + 1], o[2] = s[c + 2], mat4.multiplyVec3(o, r, o), a[c] = o[0], a[c + 1] = o[1], a[c + 2] = o[2];
    if (t.normals) {
      (!this.geometry.normals || this.geometry.normals.length != t.normals.length) && (this.geometry.normals = new Float32Array(t.normals.length));
      var u = this.geometry.normals, h = mat4.invert(mat4.create(), r);
      h && mat4.transpose(h, h);
      var l = t.normals;
      for (let c = 0, d = u.length; c < d; c += 3)
        o[0] = l[c], o[1] = l[c + 1], o[2] = l[c + 2], mat4.multiplyVec3(o, h, o), u[c] = o[0], u[c + 1] = o[1], u[c + 2] = o[2];
    }
    this.geometry.type = t.type, this.geometry._version++;
  }
}
g(LGraphGeometryTransform, "title", "Transform");
LiteGraph.registerNodeType("geometry/transform", LGraphGeometryTransform);
class LGraphGeometryPolygon {
  constructor() {
    this.addInput("sides", "number"), this.addInput("radius", "number"), this.addOutput("out", "geometry"), this.properties = { sides: 6, radius: 1, uvs: !1 }, this.geometry = {
      type: "line_loop",
      vertices: null,
      _id: generateGeometryId()
    }, this.geometry_id = -1, this.version = -1, this.must_update = !0, this.last_info = { sides: -1, radius: -1 };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputOrProperty("sides"), r = this.getInputOrProperty("radius");
      t = Math.max(3, t) | 0, (this.last_info.sides != t || this.last_info.radius != r) && this.updateGeometry(t, r), this.setOutputData(0, this.geometry);
    }
  }
  updateGeometry(t, r) {
    var s = 3 * t, a = this.geometry.vertices;
    (!a || a.length != s) && (a = this.geometry.vertices = new Float32Array(3 * t));
    var o = Math.PI * 2 / t, u = this.properties.uvs;
    u && (uvs = this.geometry.coords = new Float32Array(3 * t));
    for (var h = 0; h < t; ++h) {
      var l = o * -h, c = Math.cos(l) * r, d = 0, f = Math.sin(l) * r;
      a[h * 3] = c, a[h * 3 + 1] = d, a[h * 3 + 2] = f;
    }
    this.geometry._id = ++this.geometry_id, this.geometry._version = ++this.version, this.last_info.sides = t, this.last_info.radius = r;
  }
}
g(LGraphGeometryPolygon, "title", "Polygon");
LiteGraph.registerNodeType("geometry/polygon", LGraphGeometryPolygon);
class LGraphGeometryExtrude {
  constructor() {
    this.addInput("", "geometry"), this.addOutput("", "geometry"), this.properties = {
      top_cap: !0,
      bottom_cap: !0,
      offset: [0, 100, 0]
    }, this.version = -1, this._last_geo_version = -1, this._must_update = !0;
  }
  onPropertyChanged(t, r) {
    this._must_update = !0;
  }
  onExecute() {
    var t = this.getInputData(0);
    !t || !this.isOutputConnected(0) || ((t.version != this._last_geo_version || this._must_update) && (this._geo = this.extrudeGeometry(t, this._geo), this._geo && (this._geo.version = this.version++), this._must_update = !1), this.setOutputData(0, this._geo));
  }
  extrudeGeometry(t) {
    var r = t.vertices, s = r.length / 3, a = vec3.create(), o = vec3.create(), u = vec3.create(), h = vec3.create(), l = new Float32Array(this.properties.offset);
    if (t.type == "line_loop")
      for (var c = new Float32Array(s * 6 * 3), d = 0, f = 0, _ = r.length; f < _; f += 3)
        a[0] = r[f], a[1] = r[f + 1], a[2] = r[f + 2], f + 3 < _ ? (o[0] = r[f + 3], o[1] = r[f + 4], o[2] = r[f + 5]) : (o[0] = r[0], o[1] = r[1], o[2] = r[2]), vec3.add(u, a, l), vec3.add(h, o, l), c.set(a, d), d += 3, c.set(o, d), d += 3, c.set(u, d), d += 3, c.set(o, d), d += 3, c.set(h, d), d += 3, c.set(u, d), d += 3;
    var E = {
      _id: generateGeometryId(),
      type: "triangles",
      vertices: c
    };
    return E;
  }
}
g(LGraphGeometryExtrude, "title", "extrude");
LiteGraph.registerNodeType("geometry/extrude", LGraphGeometryExtrude);
class LGraphGeometryEval {
  constructor() {
    this.addInput("in", "geometry"), this.addOutput("out", "geometry"), this.properties = {
      code: "V[1] += 0.01 * Math.sin(I + T*0.001);",
      execute_every_frame: !1
    }, this.geometry = null, this.geometry_id = -1, this.version = -1, this.must_update = !0, this.vertices = null, this.func = null;
  }
  onConfigure() {
    this.compileCode();
  }
  compileCode() {
    if (this.properties.code)
      try {
        this.func = new Function("V", "I", "T", this.properties.code), this.boxcolor = "#AFA", this.must_update = !0;
      } catch {
        this.boxcolor = "red";
      }
  }
  onPropertyChanged(t, r) {
    t == "code" && (this.properties.code = r, this.compileCode());
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      if (!this.func) {
        this.setOutputData(0, t);
        return;
      }
      if (this.geometry_id != t._id || this.version != t._version || this.must_update || this.properties.execute_every_frame) {
        this.must_update = !1, this.geometry_id = t._id, this.properties.execute_every_frame ? this.version++ : this.version = t._version;
        var r = this.func, s = getTime();
        this.geometry || (this.geometry = {});
        for (let u in t)
          t[u] != null && (t[u].constructor == Float32Array ? this.geometry[u] = new Float32Array(t[u]) : this.geometry[u] = t[u]);
        this.geometry._id = t._id, this.properties.execute_every_frame ? this.geometry._version = this.version : this.geometry._version = t._version + 1;
        var a = vec3.create(), o = this.vertices;
        !o || this.vertices.length != t.vertices.length ? o = this.vertices = new Float32Array(t.vertices) : o.set(t.vertices);
        for (let u = 0; u < o.length; u += 3)
          a[0] = o[u], a[1] = o[u + 1], a[2] = o[u + 2], r(a, u / 3, s), o[u] = a[0], o[u + 1] = a[1], o[u + 2] = a[2];
        this.geometry.vertices = o;
      }
      this.setOutputData(0, this.geometry);
    }
  }
}
g(LGraphGeometryEval, "title", "geoeval"), g(LGraphGeometryEval, "desc", "eval code"), g(LGraphGeometryEval, "widgets_info", { code: { widget: "code" } });
LiteGraph.registerNodeType("geometry/eval", LGraphGeometryEval);
class LGraphConnectPoints {
  constructor() {
    this.addInput("in", "geometry"), this.addOutput("out", "geometry"), this.properties = {
      min_dist: 0.4,
      max_dist: 0.5,
      max_connections: 0,
      probability: 1
    }, this.geometry_id = -1, this.version = -1, this.my_version = 1, this.must_update = !0;
  }
  onPropertyChanged(t, r) {
    this.must_update = !0;
  }
  onExecute() {
    var t = this.getInputData(0);
    if (t) {
      if (this.geometry_id != t._id || this.version != t._version || this.must_update) {
        this.must_update = !1, this.geometry_id = t._id, this.version = t._version, this.geometry = {};
        for (let G in t)
          this.geometry[G] = t[G];
        this.geometry._id = generateGeometryId(), this.geometry._version = this.my_version++;
        var r = t.vertices, s = r.length, a = this.properties.min_dist, o = this.properties.max_dist, u = this.properties.probability, h = this.properties.max_connections, l = [];
        for (let G = 0; G < s; G += 3) {
          var c = r[G], d = r[G + 1], f = r[G + 2], _ = 0;
          for (let O = G + 3; O < s; O += 3) {
            var E = r[O], m = r[O + 1], T = r[O + 2], L = Math.sqrt((c - E) * (c - E) + (d - m) * (d - m) + (f - T) * (f - T));
            if (!(L > o || L < a || u < 1 && u < Math.random()) && (l.push(G / 3, O / 3), _ += 1, h && _ > h))
              break;
          }
        }
        this.geometry.indices = this.indices = new Uint32Array(l);
      }
      this.indices && this.indices.length ? (this.geometry.indices = this.indices, this.setOutputData(0, this.geometry)) : this.setOutputData(0, null);
    }
  }
}
g(LGraphConnectPoints, "title", "connect points"), g(LGraphConnectPoints, "desc", "adds indices between near points");
LiteGraph.registerNodeType("geometry/connectPoints", LGraphConnectPoints);
if (typeof GL != "undefined") {
  class n {
    constructor() {
      this.addInput("mesh", "mesh"), this.addOutput("out", "geometry"), this.geometry = {}, this.last_mesh = null;
    }
    onExecute() {
      var l = this.getInputData(0);
      if (l) {
        if (l != this.last_mesh) {
          this.last_mesh = l;
          for (i in l.vertexBuffers) {
            var c = l.vertexBuffers[i];
            this.geometry[i] = c.data;
          }
          l.indexBuffers.triangles && (this.geometry.indices = l.indexBuffers.triangles.data), this.geometry._id = generateGeometryId(), this.geometry._version = 0;
        }
        this.setOutputData(0, this.geometry), this.geometry && this.setOutputData(1, this.geometry.vertices);
      }
    }
  }
  g(n, "title", "to geometry"), g(n, "desc", "converts a mesh to geometry"), LiteGraph.registerNodeType("geometry/toGeometry", n);
  class t {
    constructor() {
      this.addInput("in", "geometry"), this.addOutput("mesh", "mesh"), this.properties = {}, this.version = -1, this.mesh = null;
    }
    updateMesh(l) {
      this.mesh || (this.mesh = new GL.Mesh());
      for (let T in l)
        if (T[0] != "_") {
          var c = l[T], d = GL.Mesh.common_buffers[T];
          if (!(!d && T != "indices")) {
            var f = d ? d.spacing : 3, _ = this.mesh.vertexBuffers[T];
            !_ || _.data.length != c.length ? _ = new GL.Buffer(
              T == "indices" ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,
              c,
              f,
              GL.DYNAMIC_DRAW
            ) : (_.data.set(c), _.upload(GL.DYNAMIC_DRAW)), this.mesh.addBuffer(T, _);
          }
        }
      if (this.mesh.vertexBuffers.normals && this.mesh.vertexBuffers.normals.data.length != this.mesh.vertexBuffers.vertices.data.length) {
        var E = new Float32Array([0, 1, 0]), m = new Float32Array(this.mesh.vertexBuffers.vertices.data.length);
        for (let T = 0; T < m.length; T += 3) m.set(E, T);
        _ = new GL.Buffer(GL.ARRAY_BUFFER, m, 3), this.mesh.addBuffer("normals", _);
      }
      return this.mesh.updateBoundingBox(), this.geometry_id = this.mesh.id = l._id, this.version = this.mesh.version = l._version, this.mesh;
    }
    onExecute() {
      var l = this.getInputData(0);
      l && ((this.version != l._version || this.geometry_id != l._id) && this.updateMesh(l), this.setOutputData(0, this.mesh));
    }
  }
  g(t, "title", "Geo to Mesh"), LiteGraph.registerNodeType("geometry/toMesh", t);
  const o = class o {
    constructor() {
      this.addInput("mesh", "mesh"), this.addInput("mat4", "mat4"), this.addInput("tex", "texture"), this.properties = {
        enabled: !0,
        primitive: GL.TRIANGLES,
        additive: !1,
        color: [1, 1, 1],
        opacity: 1
      }, this.color = vec4.create([1, 1, 1, 1]), this.model_matrix = mat4.create(), this.uniforms = {
        u_color: this.color,
        u_model: this.model_matrix
      };
    }
    onExecute() {
      var c;
      if (this.properties.enabled) {
        var l = this.getInputData(0);
        if (l) {
          (c = console.warn) == null || c.call(console, "cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
          return;
        }
      }
    }
  };
  g(o, "title", "Render Mesh"), g(o, "desc", "renders a mesh flat"), g(o, "PRIMITIVE_VALUES", {
    points: GL.POINTS,
    lines: GL.LINES,
    line_loop: GL.LINE_LOOP,
    line_strip: GL.LINE_STRIP,
    triangles: GL.TRIANGLES,
    triangle_fan: GL.TRIANGLE_FAN,
    triangle_strip: GL.TRIANGLE_STRIP
  }), g(o, "widgets_info", {
    primitive: {
      widget: "combo",
      values: o.PRIMITIVE_VALUES
    },
    color: { widget: "color" }
  });
  let r = o;
  LiteGraph.registerNodeType("geometry/render_mesh", r);
  const u = class u {
    constructor() {
      this.addInput("size", "number"), this.addOutput("out", "mesh"), this.properties = { type: 1, size: 1, subdivisions: 32 }, this.version = Math.random() * 1e5 | 0, this.last_info = { type: -1, size: -1, subdivisions: -1 };
    }
    onExecute() {
      if (this.isOutputConnected(0)) {
        var l = this.getInputOrProperty("size");
        (this.last_info.type != this.properties.type || this.last_info.size != l || this.last_info.subdivisions != this.properties.subdivisions) && this.updateMesh(
          this.properties.type,
          l,
          this.properties.subdivisions
        ), this.setOutputData(0, this._mesh);
      }
    }
    updateMesh(l, c, d) {
      switch (d = Math.max(0, d) | 0, l) {
        case 1:
          this._mesh = GL.Mesh.cube({
            size: c,
            normals: !0,
            coords: !0
          });
          break;
        case 2:
          this._mesh = GL.Mesh.plane({
            size: c,
            xz: !0,
            detail: d,
            normals: !0,
            coords: !0
          });
          break;
        case 3:
          this._mesh = GL.Mesh.cylinder({
            size: c,
            subdivisions: d,
            normals: !0,
            coords: !0
          });
          break;
        case 4:
          this._mesh = GL.Mesh.sphere({
            size: c,
            long: d,
            lat: d,
            normals: !0,
            coords: !0
          });
          break;
        case 5:
          this._mesh = GL.Mesh.circle({
            size: c,
            slices: d,
            normals: !0,
            coords: !0
          });
          break;
        case 6:
          this._mesh = GL.Mesh.sphere({
            size: c,
            long: d,
            lat: d,
            normals: !0,
            coords: !0,
            hemi: !0
          });
          break;
        case 7:
          this._mesh = GL.Mesh.icosahedron({
            size: c,
            subdivisions: d
          });
          break;
        case 8:
          this._mesh = GL.Mesh.cone({
            radius: c,
            height: c,
            subdivisions: d
          });
          break;
        case 9:
          this._mesh = GL.Mesh.plane({
            size: c,
            xz: !1,
            detail: d,
            normals: !0,
            coords: !0
          });
          break;
      }
      this.last_info.type = l, this.last_info.size = c, this.last_info.subdivisions = d, this._mesh.version = this.version++;
    }
  };
  g(u, "title", "Primitive"), g(u, "VALID", {
    CUBE: 1,
    PLANE: 2,
    CYLINDER: 3,
    SPHERE: 4,
    CIRCLE: 5,
    HEMISPHERE: 6,
    ICOSAHEDRON: 7,
    CONE: 8,
    QUAD: 9
  }), g(u, "widgets_info", {
    type: {
      widget: "combo",
      values: u.VALID
    }
  });
  let s = u;
  LiteGraph.registerNodeType("geometry/mesh_primitive", s);
  class a {
    constructor() {
      this.addInput("in", "geometry"), this.addInput("mat4", "mat4"), this.addInput("tex", "texture"), this.properties = {
        enabled: !0,
        point_size: 0.1,
        fixed_size: !1,
        additive: !0,
        color: [1, 1, 1],
        opacity: 1
      }, this.color = vec4.create([1, 1, 1, 1]), this.uniforms = {
        u_point_size: 1,
        u_perspective: 1,
        u_point_perspective: 1,
        u_color: this.color
      }, this.geometry_id = -1, this.version = -1, this.mesh = null;
    }
    updateMesh(l) {
      !this.buffer || !this.buffer.data || this.buffer.data.length != l.vertices.length ? this.buffer = new GL.Buffer(
        GL.ARRAY_BUFFER,
        l.vertices,
        3,
        GL.DYNAMIC_DRAW
      ) : (this.buffer.data.set(l.vertices), this.buffer.upload(GL.DYNAMIC_DRAW)), this.mesh || (this.mesh = new GL.Mesh()), this.mesh.addBuffer("vertices", this.buffer), this.geometry_id = this.mesh.id = l._id, this.version = this.mesh.version = l._version;
    }
    onExecute() {
      var c;
      if (this.properties.enabled) {
        var l = this.getInputData(0);
        if (l) {
          (this.version != l._version || this.geometry_id != l._id) && this.updateMesh(l);
          {
            (c = console.warn) == null || c.call(console, "cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
            return;
          }
        }
      }
    }
  }
  g(a, "title", "renderPoints"), g(a, "desc", "render points with a texture"), g(a, "widgets_info", { color: { widget: "color" } }), g(a, "vertex_shader_code", `
            precision mediump float;
            attribute vec3 a_vertex;
            varying vec3 v_vertex;
            attribute vec3 a_normal;
            varying vec3 v_normal;
            #ifdef USE_COLOR
                attribute vec4 a_color;
                varying vec4 v_color;
            #endif
            attribute vec2 a_coord;
            varying vec2 v_coord;
            #ifdef USE_SIZE
                attribute float a_extra;
            #endif
            #ifdef USE_INSTANCING
                attribute mat4 u_model;
            #else
                uniform mat4 u_model;
            #endif
            uniform mat4 u_viewprojection;
            uniform float u_point_size;
            uniform float u_perspective;
            uniform float u_point_perspective;
            float computePointSize(float radius, float w)
            {
                if(radius < 0.0)
                    return -radius;
                return u_perspective * radius / w;
            }
            void main() {
                v_coord = a_coord;
                #ifdef USE_COLOR
                    v_color = a_color;
                #endif
                v_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;
                v_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;
                gl_Position = u_viewprojection * vec4(v_vertex,1.0);
                gl_PointSize = u_point_size;
                #ifdef USE_SIZE
                    gl_PointSize = a_extra;
                #endif
                if(u_point_perspective != 0.0)
                    gl_PointSize = computePointSize( gl_PointSize, gl_Position.w );
            }
        `), g(a, "fragment_shader_code", `
            precision mediump float;
            uniform vec4 u_color;
            #ifdef USE_COLOR
                varying vec4 v_color;
            #endif
            varying vec2 v_coord;
            uniform sampler2D u_texture;
            void main() {
                vec4 color = u_color;
                #ifdef USE_TEXTURED_POINTS
                    color *= texture2D(u_texture, gl_PointCoord.xy);
                #else
                    #ifdef USE_TEXTURE
                        color *= texture2D(u_texture, v_coord);
                        if(color.a < 0.1)
                            discard;
                    #endif
                    #ifdef USE_POINTS
                        float dist = length( gl_PointCoord.xy - vec2(0.5) );
                        if( dist > 0.45 )
                            discard;
                    #endif
                #endif
                #ifdef USE_COLOR
                    color *= v_color;
                #endif
                gl_FragColor = color;
            }
        `), LiteGraph.registerNodeType("geometry/render_points", a);
}
const It = class It {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("Aberration", "number"), this.addInput("Distortion", "number"), this.addInput("Blur", "number"), this.addOutput("Texture", "Texture"), this.properties = {
      aberration: 1,
      distortion: 1,
      blur: 1,
      precision: LGraphTexture.DEFAULT
    }, It._shader || (It._shader = new GL$1.Shader(
      GL$1.Shader.SCREEN_VERTEX_SHADER,
      It.pixel_shader
    ), It._texture = new GL$1.Texture(3, 1, {
      format: gl$1.RGB,
      wrap: gl$1.CLAMP_TO_EDGE,
      magFilter: gl$1.LINEAR,
      minFilter: gl$1.LINEAR,
      pixel_data: [255, 0, 0, 0, 255, 0, 0, 0, 255]
    }));
  }
  onExecute() {
    var t = this.getInputData(0);
    if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
      this.setOutputData(0, t);
      return;
    }
    if (t) {
      this._tex = LGraphTexture.getTargetTexture(
        t,
        this._tex,
        this.properties.precision
      );
      var r = this.properties.aberration;
      this.isInputConnected(1) && (r = this.getInputData(1), this.properties.aberration = r);
      var s = this.properties.distortion;
      this.isInputConnected(2) && (s = this.getInputData(2), this.properties.distortion = s);
      var a = this.properties.blur;
      this.isInputConnected(3) && (a = this.getInputData(3), this.properties.blur = a), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
      var o = Mesh.getScreenQuad(), u = It._shader;
      this._tex.drawTo(function() {
        t.bind(0), u.uniforms({
          u_texture: 0,
          u_aberration: r,
          u_distortion: s,
          u_blur: a
        }).draw(o);
      }), this.setOutputData(0, this._tex);
    }
  }
  /*
      float normalized_tunable_sigmoid(float xs, float k)\n\
      {\n\
          xs = xs * 2.0 - 1.0;\n\
          float signx = sign(xs);\n\
          float absx = abs(xs);\n\
          return signx * ((-k - 1.0)*absx)/(2.0*(-2.0*k*absx+k-1.0)) + 0.5;\n\
      }\n\
  */
};
g(It, "title", "Lens"), g(It, "desc", "Camera Lens distortion"), g(It, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(It, "pixel_shader", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform float u_aberration;
        uniform float u_distortion;
        uniform float u_blur;
        
        void main() {
            vec2 coord = v_coord;
            float dist = distance(vec2(0.5), coord);
            vec2 dist_coord = coord - vec2(0.5);
            float percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;
            dist_coord *= percent;
            coord = dist_coord + vec2(0.5);
            vec4 color = texture2D(u_texture, coord, u_blur * dist);
            color.r = texture2D(u_texture, vec2(0.5) + dist_coord * (1.0 + 0.01 * u_aberration), u_blur * dist).r;
            color.b = texture2D(u_texture, vec2(0.5) + dist_coord * (1.0 - 0.01 * u_aberration), u_blur * dist).b;
            gl_FragColor = color;
        }
    `);
let LGraphFXLens = It;
LiteGraph.registerNodeType("fx/lens", LGraphFXLens);
const ct = class ct {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("Blurred", "Texture"), this.addInput("Mask", "Texture"), this.addInput("Threshold", "number"), this.addOutput("Texture", "Texture"), this.properties = {
      shape: "",
      size: 10,
      alpha: 1,
      threshold: 1,
      high_precision: !1
    };
  }
  onExecute() {
    var t = this.getInputData(0), r = this.getInputData(1), s = this.getInputData(2);
    if (!t || !s || !this.properties.shape) {
      this.setOutputData(0, t);
      return;
    }
    r || (r = t);
    var a = LGraphTexture.getTexture(this.properties.shape);
    if (a) {
      var o = this.properties.threshold;
      this.isInputConnected(3) && (o = this.getInputData(3), this.properties.threshold = o);
      var u = gl$1.UNSIGNED_BYTE;
      this.properties.high_precision && (u = gl$1.half_float_ext ? gl$1.HALF_FLOAT_OES : gl$1.FLOAT), (!this._temp_texture || this._temp_texture.type != u || this._temp_texture.width != t.width || this._temp_texture.height != t.height) && (this._temp_texture = new GL$1.Texture(t.width, t.height, {
        type: u,
        format: gl$1.RGBA,
        filter: gl$1.LINEAR
      }));
      var h = ct._first_shader;
      h || (h = ct._first_shader = new GL$1.Shader(
        GL$1.Shader.SCREEN_VERTEX_SHADER,
        ct._first_pixel_shader
      ));
      var l = ct._second_shader;
      l || (l = ct._second_shader = new GL$1.Shader(
        ct._second_vertex_shader,
        ct._second_pixel_shader
      ));
      var c = this._points_mesh;
      (!c || c._width != t.width || c._height != t.height || c._spacing != 2) && (c = this.createPointsMesh(t.width, t.height, 2));
      var d = Mesh.getScreenQuad(), f = this.properties.size, _ = this.properties.alpha;
      gl$1.disable(gl$1.DEPTH_TEST), gl$1.disable(gl$1.BLEND), this._temp_texture.drawTo(function() {
        t.bind(0), r.bind(1), s.bind(2), h.uniforms({
          u_texture: 0,
          u_texture_blur: 1,
          u_mask: 2,
          u_texsize: [t.width, t.height]
        }).draw(d);
      }), this._temp_texture.drawTo(function() {
        gl$1.enable(gl$1.BLEND), gl$1.blendFunc(gl$1.ONE, gl$1.ONE), t.bind(0), a.bind(3), l.uniforms({
          u_texture: 0,
          u_mask: 2,
          u_shape: 3,
          u_alpha: _,
          u_threshold: o,
          u_pointSize: f,
          u_itexsize: [1 / t.width, 1 / t.height]
        }).draw(c, gl$1.POINTS);
      }), this.setOutputData(0, this._temp_texture);
    }
  }
  createPointsMesh(t, r, s) {
    for (var a = Math.round(t / s), o = Math.round(r / s), u = new Float32Array(a * o * 2), h = -1, l = 2 / t * s, c = 2 / r * s, d = 0; d < o; ++d) {
      for (var f = -1, _ = 0; _ < a; ++_) {
        var E = d * a * 2 + _ * 2;
        u[E] = f, u[E + 1] = h, f += l;
      }
      h += c;
    }
    return this._points_mesh = GL$1.Mesh.load({ vertices2D: u }), this._points_mesh._width = t, this._points_mesh._height = r, this._points_mesh._spacing = s, this._points_mesh;
  }
};
g(ct, "title", "Bokeh"), g(ct, "desc", "applies an Bokeh effect"), g(ct, "widgets_info", { shape: { widget: "texture" } }), /*
LGraphTextureBokeh._pixel_shader = "precision highp float;\n\
        varying vec2 a_coord;\n\
        uniform sampler2D u_texture;\n\
        uniform sampler2D u_shape;\n\
        \n\
        void main() {\n\
            vec4 color = texture2D( u_texture, gl_PointCoord );\n\
            color *= v_color * u_alpha;\n\
            gl_FragColor = color;\n\
        }\n";
*/
g(ct, "_first_pixel_shader", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform sampler2D u_texture_blur;
        uniform sampler2D u_mask;

        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            vec4 blurred_color = texture2D(u_texture_blur, v_coord);
            float mask = texture2D(u_mask, v_coord).x;
            gl_FragColor = mix(color, blurred_color, mask);
        }
    `), g(ct, "_second_vertex_shader", `
        precision highp float;
        attribute vec2 a_vertex2D;
        varying vec4 v_color;
        uniform sampler2D u_texture;
        uniform sampler2D u_mask;
        uniform vec2 u_itexsize;
        uniform float u_pointSize;
        uniform float u_threshold;
        
        void main() {
            vec2 coord = a_vertex2D * 0.5 + 0.5;
            v_color = texture2D(u_texture, coord);
            v_color += texture2D(u_texture, coord + vec2(u_itexsize.x, 0.0));
            v_color += texture2D(u_texture, coord + vec2(0.0, u_itexsize.y));
            v_color += texture2D(u_texture, coord + u_itexsize);
            v_color *= 0.25;
            float mask = texture2D(u_mask, coord).x;
            float luminance = length(v_color) * mask;
            // luminance /= (u_pointSize * u_pointSize) * 0.01;
            luminance -= u_threshold;
            if (luminance < 0.0) {
                gl_Position.x = -100.0;
                return;
            }
            gl_PointSize = u_pointSize;
            gl_Position = vec4(a_vertex2D, 0.0, 1.0);
        }
    `), g(ct, "_second_pixel_shader", `
        precision highp float;
        varying vec4 v_color;
        uniform sampler2D u_shape;
        uniform float u_alpha;
        
        void main() {
            vec4 color = texture2D(u_shape, gl_PointCoord);
            color *= v_color * u_alpha;
            gl_FragColor = color;
        }
    `);
let LGraphFXBokeh = ct;
LiteGraph.registerNodeType("fx/bokeh", LGraphFXBokeh);
const ft = class ft {
  constructor() {
    this.addInput("Texture", "Texture"), this.addInput("value1", "number"), this.addInput("value2", "number"), this.addOutput("Texture", "Texture"), this.properties = {
      fx: "halftone",
      value1: 1,
      value2: 1,
      precision: LGraphTexture.DEFAULT
    };
  }
  onExecute() {
    if (this.isOutputConnected(0)) {
      var t = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, t);
        return;
      }
      if (t) {
        this._tex = LGraphTexture.getTargetTexture(
          t,
          this._tex,
          this.properties.precision
        );
        var r = this.properties.value1;
        this.isInputConnected(1) && (r = this.getInputData(1), this.properties.value1 = r);
        var s = this.properties.value2;
        this.isInputConnected(2) && (s = this.getInputData(2), this.properties.value2 = s);
        var a = this.properties.fx, o = ft.shaders[a];
        if (!o) {
          var u = ft["pixel_shader_" + a];
          if (!u)
            return;
          o = ft.shaders[a] = new GL$1.Shader(
            GL$1.Shader.SCREEN_VERTEX_SHADER,
            u
          );
        }
        gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
        var h = Mesh.getScreenQuad(), l = LS ? LS.Renderer._current_camera : null, c;
        l ? c = [
          LS.Renderer._current_camera.near,
          LS.Renderer._current_camera.far
        ] : c = [1, 100];
        var d = null;
        a == "noise" && (d = LGraphTexture.getNoiseTexture()), this._tex.drawTo(function() {
          t.bind(0), a == "noise" && d.bind(1), o.uniforms({
            u_texture: 0,
            u_noise: 1,
            u_size: [t.width, t.height],
            u_rand: [Math.random(), Math.random()],
            u_value1: r,
            u_value2: s,
            u_camera_planes: c
          }).draw(h);
        }), this.setOutputData(0, this._tex);
      }
    }
  }
};
g(ft, "title", "FX"), g(ft, "desc", "applies an FX from a list"), g(ft, "widgets_info", {
  fx: {
    widget: "combo",
    values: ["halftone", "pixelate", "lowpalette", "noise", "gamma"]
  },
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(ft, "shaders", {}), g(ft, "pixel_shader_halftone", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        
        float pattern() {
            float s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);
            vec2 tex = v_coord * u_size.xy;
            vec2 point = vec2(
                c * tex.x - s * tex.y ,
                s * tex.x + c * tex.y
            ) * u_value2;
            return (sin(point.x) * sin(point.y)) * 4.0;
        }
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            float average = (color.r + color.g + color.b) / 3.0;
            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);
        }
    `), g(ft, "pixel_shader_pixelate", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        
        void main() {
            vec2 coord = vec2(floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2);
            vec4 color = texture2D(u_texture, coord);
            gl_FragColor = color;
        }
    `), g(ft, "pixel_shader_lowpalette", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform vec2 u_camera_planes;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            gl_FragColor = floor(color * u_value1) / u_value1;
        }
    `), g(ft, "pixel_shader_noise", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform sampler2D u_noise;
        uniform vec2 u_size;
        uniform float u_value1;
        uniform float u_value2;
        uniform vec2 u_rand;
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            vec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);
            gl_FragColor = vec4(color.xyz + noise * u_value1, color.a);
        }
    `), g(ft, "pixel_shader_gamma", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_value1;
        
        void main() {
            vec4 color = texture2D(u_texture, v_coord);
            float gamma = 1.0 / u_value1;
            gl_FragColor = vec4(pow(color.xyz, vec3(gamma)), color.a);
        }
    `);
let LGraphFXGeneric = ft;
LiteGraph.registerNodeType("fx/generic", LGraphFXGeneric);
const Pt = class Pt {
  constructor() {
    this.addInput("Tex.", "Texture"), this.addInput("intensity", "number"), this.addOutput("Texture", "Texture"), this.properties = {
      intensity: 1,
      invert: !1,
      precision: LGraphTexture.DEFAULT
    }, Pt._shader || (Pt._shader = new GL$1.Shader(
      GL$1.Shader.SCREEN_VERTEX_SHADER,
      Pt.pixel_shader
    ));
  }
  onExecute() {
    var t = this.getInputData(0);
    if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
      this.setOutputData(0, t);
      return;
    }
    if (t) {
      this._tex = LGraphTexture.getTargetTexture(
        t,
        this._tex,
        this.properties.precision
      );
      var r = this.properties.intensity;
      this.isInputConnected(1) && (r = this.getInputData(1), this.properties.intensity = r), gl$1.disable(gl$1.BLEND), gl$1.disable(gl$1.DEPTH_TEST);
      var s = Mesh.getScreenQuad(), a = Pt._shader, o = this.properties.invert;
      this._tex.drawTo(function() {
        t.bind(0), a.uniforms({
          u_texture: 0,
          u_intensity: r,
          u_isize: [1 / t.width, 1 / t.height],
          u_invert: o ? 1 : 0
        }).draw(s);
      }), this.setOutputData(0, this._tex);
    }
  }
};
g(Pt, "title", "Vigneting"), g(Pt, "desc", "Vigneting"), g(Pt, "widgets_info", {
  precision: {
    widget: "combo",
    values: LGraphTexture.MODE_VALUES
  }
}), g(Pt, "pixel_shader", `
        precision highp float;
        varying vec2 v_coord;
        uniform sampler2D u_texture;
        uniform float u_intensity;
        uniform int u_invert;
        
        void main() {
            float luminance = 1.0 - length(v_coord - vec2(0.5)) * 1.414;
            vec4 color = texture2D(u_texture, v_coord);
            
            if (u_invert == 1) {
                luminance = 1.0 - luminance;
            }
            
            luminance = mix(1.0, luminance, u_intensity);
            gl_FragColor = vec4(luminance * color.xyz, color.a);
        }
    `);
let LGraphFXVigneting = Pt;
LiteGraph.registerNodeType("fx/vigneting", LGraphFXVigneting);
var MIDI_COLOR = "#243";
const rt = class rt {
  constructor(t) {
    this.channel = 0, this.cmd = 0, this.data = new Uint32Array(3), t && this.setup(t);
  }
  fromJSON(t) {
    this.setup(t.data);
  }
  setup(t) {
    var r = t;
    t.constructor === Object && (r = t.data), this.data.set(r);
    var s = r[0];
    this.status = s;
    var a = s & 240;
    s >= 240 ? this.cmd = s : this.cmd = a, this.cmd == rt.NOTEON && this.velocity == 0 && (this.cmd = rt.NOTEOFF), this.cmd_str = rt.commands[this.cmd] || "", (a >= rt.NOTEON || a <= rt.NOTEOFF) && (this.channel = s & 15);
  }
  get velocity() {
    return this.cmd == rt.NOTEON ? this.data[2] : -1;
  }
  set velocity(t) {
    this.data[2] = t;
  }
  get note() {
    return this.cmd != rt.NOTEON ? -1 : rt.toNoteString(this.data[1], !0);
  }
  set note(t) {
    throw new Error("notes cannot be assigned this way, must modify the data[1]");
  }
  get octave() {
    if (this.cmd != rt.NOTEON)
      return -1;
    var t = this.data[1] - 24;
    return Math.floor(t / 12 + 1);
  }
  set octave(t) {
    throw new Error("octave cannot be assigned this way, must modify the data[1]");
  }
  // returns HZs
  getPitch() {
    return Math.pow(2, (this.data[1] - 69) / 12) * 440;
  }
  static computePitch(t) {
    return Math.pow(2, (t - 69) / 12) * 440;
  }
  getCC() {
    return this.data[1];
  }
  getCCValue() {
    return this.data[2];
  }
  // not tested, there is a formula missing here
  getPitchBend() {
    return this.data[1] + (this.data[2] << 7) - 8192;
  }
  static computePitchBend(t, r) {
    return t + (r << 7) - 8192;
  }
  setCommandFromString(t) {
    this.cmd = rt.computeCommandFromString(t);
  }
  static computeCommandFromString(t) {
    if (!t)
      return 0;
    if (t && t.constructor === Number)
      return t;
    switch (t = t.toUpperCase(), t) {
      case "NOTE ON":
      case "NOTEON":
        return rt.NOTEON;
      case "NOTE OFF":
      case "NOTEOFF":
        return rt.NOTEON;
      case "KEY PRESSURE":
      case "KEYPRESSURE":
        return rt.KEYPRESSURE;
      case "CONTROLLER CHANGE":
      case "CONTROLLERCHANGE":
      case "CC":
        return rt.CONTROLLERCHANGE;
      case "PROGRAM CHANGE":
      case "PROGRAMCHANGE":
      case "PC":
        return rt.PROGRAMCHANGE;
      case "CHANNEL PRESSURE":
      case "CHANNELPRESSURE":
        return rt.CHANNELPRESSURE;
      case "PITCH BEND":
      case "PITCHBEND":
        return rt.PITCHBEND;
      case "TIME TICK":
      case "TIMETICK":
        return rt.TIMETICK;
      default:
        return Number(t);
    }
  }
  // transform from a pitch number to string like "C4"
  static toNoteString(t, r) {
    t = Math.round(t);
    var s = t - 21, a = Math.floor((t - 24) / 12 + 1);
    return s = s % 12, s < 0 && (s = 12 + s), rt.notes[s] + (r ? "" : a);
  }
  static NoteStringToPitch(t) {
    t = t.toUpperCase();
    var r = t[0], s = 4;
    t[1] == "#" ? (r += "#", t.length > 2 && (s = Number(t[2]))) : t.length > 1 && (s = Number(t[1]));
    var a = rt.note_to_index[r];
    return a == null ? null : (s - 1) * 12 + a + 21;
  }
  toString() {
    var t = "" + this.channel + ". ";
    switch (this.cmd) {
      case rt.NOTEON:
        t += "NOTEON " + rt.toNoteString(this.data[1]);
        break;
      case rt.NOTEOFF:
        t += "NOTEOFF " + rt.toNoteString(this.data[1]);
        break;
      case rt.CONTROLLERCHANGE:
        t += "CC " + this.data[1] + " " + this.data[2];
        break;
      case rt.PROGRAMCHANGE:
        t += "PC " + this.data[1];
        break;
      case rt.PITCHBEND:
        t += "PITCHBEND " + this.getPitchBend();
        break;
      case rt.KEYPRESSURE:
        t += "KEYPRESS " + this.data[1];
        break;
    }
    return t;
  }
  toHexString() {
    return this.data.map((t) => t.toString(16)).join(" ");
  }
  toJSON() {
    return {
      data: [this.data[0], this.data[1], this.data[2]],
      object_class: "MIDIEvent"
    };
  }
};
g(rt, "notes", [
  "A",
  "A#",
  "B",
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#"
]), g(rt, "note_to_index", {
  A: 0,
  "A#": 1,
  B: 2,
  C: 3,
  "C#": 4,
  D: 5,
  "D#": 6,
  E: 7,
  F: 8,
  "F#": 9,
  G: 10,
  "G#": 11
}), g(rt, "commands", {
  128: "note off",
  144: "note on",
  160: "key pressure",
  176: "controller change",
  192: "program change",
  208: "channel pressure",
  224: "pitch bend",
  240: "system",
  242: "Song pos",
  243: "Song select",
  246: "Tune request",
  248: "time tick",
  250: "Start Song",
  251: "Continue Song",
  252: "Stop Song",
  254: "Sensing",
  255: "Reset"
}), g(rt, "commands_short", {
  128: "NOTEOFF",
  144: "NOTEOFF",
  160: "KEYP",
  176: "CC",
  192: "PC",
  208: "CP",
  224: "PB",
  240: "SYS",
  242: "POS",
  243: "SELECT",
  246: "TUNEREQ",
  248: "TT",
  250: "START",
  251: "CONTINUE",
  252: "STOP",
  254: "SENS",
  255: "RESET"
}), g(rt, "commands_reversed", {});
let MIDIEvent = rt;
MIDIEvent.NOTEOFF = 128;
MIDIEvent.NOTEON = 144;
MIDIEvent.KEYPRESSURE = 160;
MIDIEvent.CONTROLLERCHANGE = 176;
MIDIEvent.PROGRAMCHANGE = 192;
MIDIEvent.CHANNELPRESSURE = 208;
MIDIEvent.PITCHBEND = 224;
MIDIEvent.TIMETICK = 248;
LiteGraph.MIDIEvent = MIDIEvent;
for (var i$1 in MIDIEvent.commands)
  MIDIEvent.commands_reversed[MIDIEvent.commands[i$1]] = i$1;
const fe = class fe {
  constructor(t, r) {
    var s;
    if (!navigator.requestMIDIAccess) {
      this.error = "not suppoorted", r ? r("Not supported") : (s = console.error) == null || s.call(console, "MIDI NOT SUPPORTED, enable by chrome://flags");
      return;
    }
    this.on_ready = t, this.state = {
      note: [],
      cc: []
    }, this.input_ports = null, this.input_ports_info = [], this.output_ports = null, this.output_ports_info = [], navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this));
  }
  onMIDISuccess(t) {
    var r, s;
    (r = console.log) == null || r.call(console, "MIDI ready!"), LiteGraph.debug && ((s = console.log) == null || s.call(console, t)), this.midi = t, this.updatePorts(), this.on_ready && this.on_ready(this);
  }
  updatePorts() {
    var o, u;
    var t = this.midi;
    this.input_ports = t.inputs, this.input_ports_info = [], this.output_ports = t.outputs, this.output_ports_info = [];
    for (var r = 0, s = this.input_ports.values(), a = s.next(); a && a.done === !1; ) {
      let h = a.value;
      this.input_ports_info.push(h), LiteGraph.debug && ((o = console.log) == null || o.call(console, "Input port [type:'" + h.type + "'] id:'" + h.id + "' manufacturer:'" + h.manufacturer + "' name:'" + h.name + "' version:'" + h.version + "'")), r++, a = s.next();
    }
    for (this.num_input_ports = r, r = 0, s = this.output_ports.values(), a = s.next(); a && a.done === !1; ) {
      let h = a.value;
      this.output_ports_info.push(h), LiteGraph.debug && ((u = console.log) == null || u.call(console, "Output port [type:'" + h.type + "'] id:'" + h.id + "' manufacturer:'" + h.manufacturer + "' name:'" + h.name + "' version:'" + h.version + "'")), r++, a = s.next();
    }
    this.num_output_ports = r;
  }
  onMIDIFailure(t) {
    var r;
    (r = console.error) == null || r.call(console, "Failed to get MIDI access - " + t);
  }
  openInputPort(t, r) {
    var o;
    var s = this.input_ports.get("input-" + t);
    if (!s)
      return !1;
    fe.input = this;
    var a = this;
    return s.onmidimessage = function(u) {
      var h = new MIDIEvent(u.data);
      a.updateState(h), r && r(u.data, h), fe.on_message && fe.on_message(u.data, h);
    }, (o = console.log) == null || o.call(console, "port open: ", s), !0;
  }
  updateState(t) {
    switch (t.cmd) {
      case MIDIEvent.NOTEON:
        this.state.note[t.value1 | 0] = t.value2;
        break;
      case MIDIEvent.NOTEOFF:
        this.state.note[t.value1 | 0] = 0;
        break;
      case MIDIEvent.CONTROLLERCHANGE:
        this.state.cc[t.getCC()] = t.getCCValue();
        break;
    }
  }
  sendMIDI(t, r) {
    if (r) {
      var s = this.output_ports_info[t];
      s && (fe.output = this, r.constructor === MIDIEvent ? s.send(r.data) : s.send(r));
    }
  }
};
g(fe, "input", null);
let MIDIInterface = fe;
MIDIInterface.MIDIEvent = MIDIEvent;
class LGMIDIIn {
  constructor() {
    this.addOutput("on_midi", LiteGraph.EVENT), this.addOutput("out", "midi"), this.properties = { port: 0 }, this._last_midi_event = null, this._current_midi_event = null, this.boxcolor = "#AAA", this._last_time = 0;
    var t = this;
    new MIDIInterface(function(r) {
      t._midi = r, t._waiting && t.onStart(), t._waiting = !1;
    });
  }
  getPropertyInfo(t) {
    if (this._midi && t == "port") {
      for (var r = {}, s = 0; s < this._midi.input_ports_info.length; ++s) {
        var a = this._midi.input_ports_info[s];
        r[s] = s + ".- " + a.name + " version:" + a.version;
      }
      return { type: "enum", values: r };
    }
  }
  onStart() {
    this._midi ? this._midi.openInputPort(
      this.properties.port,
      this.onMIDIEvent.bind(this)
    ) : this._waiting = !0;
  }
  onMIDIEvent(t, r) {
    this._last_midi_event = r, this.boxcolor = "#AFA", this._last_time = LiteGraph.getTime(), this.trigger("on_midi", r), r.cmd == MIDIEvent.NOTEON ? this.trigger("on_noteon", r) : r.cmd == MIDIEvent.NOTEOFF ? this.trigger("on_noteoff", r) : r.cmd == MIDIEvent.CONTROLLERCHANGE ? this.trigger("on_cc", r) : r.cmd == MIDIEvent.PROGRAMCHANGE ? this.trigger("on_pc", r) : r.cmd == MIDIEvent.PITCHBEND && this.trigger("on_pitchbend", r);
  }
  onDrawBackground(t) {
    if (this.boxcolor = "#AAA", !this.flags.collapsed && this._last_midi_event) {
      t.fillStyle = "white";
      var r = LiteGraph.getTime(), s = 1 - Math.max(0, (r - this._last_time) * 1e-3);
      if (s > 0) {
        var a = t.globalAlpha;
        t.globalAlpha *= s, t.font = "12px Tahoma", t.fillText(
          this._last_midi_event.toString(),
          2,
          this.size[1] * 0.5 + 3
        ), t.globalAlpha = a;
      }
    }
  }
  onExecute() {
    if (this.outputs)
      for (var t = this._last_midi_event, r = 0; r < this.outputs.length; ++r) {
        var s = this.outputs[r], a = null;
        switch (s.name) {
          case "midi":
            a = this._midi;
            break;
          case "last_midi":
            a = t;
            break;
          default:
            continue;
        }
        this.setOutputData(r, a);
      }
  }
  onGetOutputs() {
    return [
      ["last_midi", "midi"],
      ["on_midi", LiteGraph.EVENT],
      ["on_noteon", LiteGraph.EVENT],
      ["on_noteoff", LiteGraph.EVENT],
      ["on_cc", LiteGraph.EVENT],
      ["on_pc", LiteGraph.EVENT],
      ["on_pitchbend", LiteGraph.EVENT]
    ];
  }
}
g(LGMIDIIn, "title", "MIDI Input"), g(LGMIDIIn, "desc", "Reads MIDI from a input port"), g(LGMIDIIn, "color", MIDI_COLOR);
LGMIDIIn.MIDIInterface = MIDIInterface;
LiteGraph.registerNodeType("midi/input", LGMIDIIn);
const ve = class ve {
  constructor() {
    this.addInput("send", LiteGraph.EVENT), this.properties = { port: 0 };
    var t = this;
    new MIDIInterface(function(r) {
      t._midi = r, t.widget.options.values = t.getMIDIOutputs();
    }), this.widget = this.addWidget("combo", "Device", this.properties.port, {
      property: "port",
      values: this.getMIDIOutputs.bind(this)
    }), this.size = [340, 60];
  }
  onGetPropertyInfo(t) {
    if (this._midi && t == "port") {
      var r = this.getMIDIOutputs();
      return { type: "enum", values: r };
    }
  }
  getMIDIOutputs() {
    var t = {};
    if (!this._midi) return ve.default_ports;
    if (this._midi.output_ports_info)
      for (var r = 0; r < this._midi.output_ports_info.length; ++r) {
        var s = this._midi.output_ports_info[r];
        if (s) {
          var a = r + ".- " + s.name + " version:" + s.version;
          t[r] = a;
        }
      }
    return t;
  }
  onAction(t, r) {
    this._midi && (t == "send" && this._midi.sendMIDI(this.properties.port, r), this.trigger("midi", r));
  }
  onGetInputs() {
    return [["send", LiteGraph.ACTION]];
  }
  onGetOutputs() {
    return [["on_midi", LiteGraph.EVENT]];
  }
};
g(ve, "title", "MIDI Output"), g(ve, "desc", "Sends MIDI to output channel"), g(ve, "color", MIDI_COLOR), g(ve, "default_ports", { 0: "unknown" });
let LGMIDIOut = ve;
LGMIDIOut.MIDIInterface = MIDIInterface;
LiteGraph.registerNodeType("midi/output", LGMIDIOut);
class LGMIDIShow {
  constructor() {
    this.addInput("on_midi", LiteGraph.EVENT), this._str = "", this.size = [200, 40];
  }
  getTitle() {
    return this.flags.collapsed ? this._str : this.title;
  }
  onAction(t, r) {
    r && (r.constructor === MIDIEvent ? this._str = r.toString() : this._str = "???");
  }
  onDrawForeground(t) {
    !this._str || this.flags.collapsed || (t.font = "30px Arial", t.fillText(this._str, 10, this.size[1] * 0.8));
  }
  onGetInputs() {
    return [["in", LiteGraph.ACTION]];
  }
  onGetOutputs() {
    return [["on_midi", LiteGraph.EVENT]];
  }
}
g(LGMIDIShow, "title", "MIDI Show"), g(LGMIDIShow, "desc", "Shows MIDI in the graph"), g(LGMIDIShow, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/show", LGMIDIShow);
class LGMIDIFilter {
  constructor() {
    this.properties = {
      channel: -1,
      cmd: -1,
      min_value: -1,
      max_value: -1
    };
    var t = this;
    this._learning = !1, this.addWidget("button", "Learn", "", function() {
      t._learning = !0, t.boxcolor = "#FA3";
    }), this.addInput("in", LiteGraph.EVENT), this.addOutput("on_midi", LiteGraph.EVENT), this.boxcolor = "#AAA";
  }
  getTitle() {
    var t = null;
    return this.properties.cmd == -1 ? t = "Nothing" : t = MIDIEvent.commands_short[this.properties.cmd] || "Unknown", this.properties.min_value != -1 && this.properties.max_value != -1 && (t += " " + (this.properties.min_value == this.properties.max_value ? this.properties.max_value : this.properties.min_value + ".." + this.properties.max_value)), "Filter: " + t;
  }
  onPropertyChanged(t, r) {
    if (t == "cmd") {
      var s = Number(r);
      isNaN(s) && (s = MIDIEvent.commands[r] || 0), this.properties.cmd = s;
    }
  }
  onAction(t, r) {
    if (!(!r || r.constructor !== MIDIEvent)) {
      if (this._learning)
        this._learning = !1, this.boxcolor = "#AAA", this.properties.channel = r.channel, this.properties.cmd = r.cmd, this.properties.min_value = this.properties.max_value = r.data[1];
      else if (this.properties.channel != -1 && r.channel != this.properties.channel || this.properties.cmd != -1 && r.cmd != this.properties.cmd || this.properties.min_value != -1 && r.data[1] < this.properties.min_value || this.properties.max_value != -1 && r.data[1] > this.properties.max_value)
        return;
      this.trigger("on_midi", r);
    }
  }
}
g(LGMIDIFilter, "title", "MIDI Filter"), g(LGMIDIFilter, "desc", "Filters MIDI messages"), g(LGMIDIFilter, "color", MIDI_COLOR), g(LGMIDIFilter, "@cmd", {
  type: "enum",
  title: "Command",
  values: MIDIEvent.commands_reversed
});
LiteGraph.registerNodeType("midi/filter", LGMIDIFilter);
class LGMIDIEvent {
  constructor() {
    this.properties = {
      channel: 0,
      cmd: 144,
      // 0x90
      value1: 1,
      value2: 1
    }, this.addInput("send", LiteGraph.EVENT), this.addInput("assign", LiteGraph.EVENT), this.addOutput("on_midi", LiteGraph.EVENT), this.midi_event = new MIDIEvent(), this.gate = !1;
  }
  onAction(t, r) {
    if (t == "assign") {
      this.properties.channel = r.channel, this.properties.cmd = r.cmd, this.properties.value1 = r.data[1], this.properties.value2 = r.data[2], r.cmd == MIDIEvent.NOTEON ? this.gate = !0 : r.cmd == MIDIEvent.NOTEOFF && (this.gate = !1);
      return;
    }
    r = this.midi_event, r.channel = this.properties.channel, this.properties.cmd && this.properties.cmd.constructor === String ? r.setCommandFromString(this.properties.cmd) : r.cmd = this.properties.cmd, r.data[0] = r.cmd | r.channel, r.data[1] = Number(this.properties.value1), r.data[2] = Number(this.properties.value2), this.trigger("on_midi", r);
  }
  onExecute() {
    var t = this.properties;
    if (this.inputs)
      for (let a = 0; a < this.inputs.length; ++a) {
        var r = this.inputs[a];
        if (r.link == -1)
          continue;
        let o;
        switch (r.name) {
          case "note":
            o = this.getInputData(a), o != null && (o.constructor === String && (o = MIDIEvent.NoteStringToPitch(o)), this.properties.value1 = (o | 0) % 255);
            break;
          case "cmd":
            o = this.getInputData(a), o != null && (this.properties.cmd = o);
            break;
          case "value1":
            o = this.getInputData(a), o != null && (this.properties.value1 = LiteGraph.clamp(o | 0, 0, 127));
            break;
          case "value2":
            o = this.getInputData(a), o != null && (this.properties.value2 = LiteGraph.clamp(o | 0, 0, 127));
            break;
        }
      }
    if (this.outputs)
      for (let a = 0; a < this.outputs.length; ++a) {
        var s = this.outputs[a];
        let o = null;
        switch (s.name) {
          case "midi":
            o = new MIDIEvent(), o.setup([t.cmd, t.value1, t.value2]), o.channel = t.channel;
            break;
          case "command":
            o = t.cmd;
            break;
          case "cc":
            o = t.value1;
            break;
          case "cc_value":
            o = t.value2;
            break;
          case "note":
            o = t.cmd == MIDIEvent.NOTEON || t.cmd == MIDIEvent.NOTEOFF ? t.value1 : null;
            break;
          case "velocity":
            o = t.cmd == MIDIEvent.NOTEON ? t.value2 : null;
            break;
          case "pitch":
            o = t.cmd == MIDIEvent.NOTEON ? MIDIEvent.computePitch(t.value1) : null;
            break;
          case "pitchbend":
            o = t.cmd == MIDIEvent.PITCHBEND ? MIDIEvent.computePitchBend(
              t.value1,
              t.value2
            ) : null;
            break;
          case "gate":
            o = this.gate;
            break;
          default:
            continue;
        }
        o !== null && this.setOutputData(a, o);
      }
  }
  onPropertyChanged(t, r) {
    t == "cmd" && (this.properties.cmd = MIDIEvent.computeCommandFromString(r));
  }
  onGetInputs() {
    return [
      ["cmd", "number"],
      ["note", "number"],
      ["value1", "number"],
      ["value2", "number"]
    ];
  }
  onGetOutputs() {
    return [
      ["midi", "midi"],
      ["on_midi", LiteGraph.EVENT],
      ["command", "number"],
      ["note", "number"],
      ["velocity", "number"],
      ["cc", "number"],
      ["cc_value", "number"],
      ["pitch", "number"],
      ["gate", "bool"],
      ["pitchbend", "number"]
    ];
  }
}
g(LGMIDIEvent, "title", "MIDIEvent"), g(LGMIDIEvent, "desc", "Create a MIDI Event"), g(LGMIDIEvent, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/event", LGMIDIEvent);
class LGMIDICC {
  constructor() {
    this.properties = {
      //		channel: 0,
      cc: 1,
      value: 0
    }, this.addOutput("value", "number");
  }
  onExecute() {
    MIDIInterface.input && (this.properties.value = MIDIInterface.input.state.cc[this.properties.cc]), this.setOutputData(0, this.properties.value);
  }
}
g(LGMIDICC, "title", "MIDICC"), g(LGMIDICC, "desc", "gets a Controller Change"), g(LGMIDICC, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/cc", LGMIDICC);
const se = class se {
  constructor() {
    this.addInput("generate", LiteGraph.ACTION), this.addInput("scale", "string"), this.addInput("octave", "number"), this.addOutput("note", LiteGraph.EVENT), this.properties = {
      notes: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#",
      octave: 2,
      duration: 0.5,
      mode: "sequence"
    }, this.notes_pitches = se.processScale(this.properties.notes), this.sequence_index = 0;
  }
  static processScale(t) {
    for (var r = t.split(","), s = 0; s < r.length; ++s) {
      var a = r[s];
      a.length == 2 && a[1] != "#" || a.length > 2 ? r[s] = -LiteGraph.MIDIEvent.NoteStringToPitch(a) : r[s] = MIDIEvent.note_to_index[a] || 0;
    }
    return r;
  }
  onPropertyChanged(t, r) {
    t == "notes" && (this.notes_pitches = se.processScale(r));
  }
  onExecute() {
    var t = this.getInputData(2);
    t != null && (this.properties.octave = t);
    var r = this.getInputData(1);
    r && (this.notes_pitches = se.processScale(r));
  }
  onAction(t, r) {
    var s = 0, a = this.notes_pitches.length, o = 0;
    this.properties.mode == "sequence" ? o = this.sequence_index = (this.sequence_index + 1) % a : this.properties.mode == "random" && (o = Math.floor(Math.random() * a));
    var u = this.notes_pitches[o];
    u >= 0 ? s = u + (this.properties.octave - 1) * 12 + 33 : s = -u, r = new MIDIEvent(), r.setup([MIDIEvent.NOTEON, s, 10]);
    var h = this.properties.duration || 1;
    this.trigger("note", r), setTimeout(
      function() {
        var l = new MIDIEvent();
        l.setup([MIDIEvent.NOTEOFF, s, 0]), this.trigger("note", l);
      }.bind(this),
      h * 1e3
    );
  }
};
g(se, "title", "MIDI Generator"), g(se, "desc", "Generates a random MIDI note"), g(se, "color", MIDI_COLOR);
let LGMIDIGenerator = se;
LiteGraph.registerNodeType("midi/generator", LGMIDIGenerator);
class LGMIDITranspose {
  constructor() {
    this.properties = { amount: 0 }, this.addInput("in", LiteGraph.ACTION), this.addInput("amount", "number"), this.addOutput("out", LiteGraph.EVENT), this.midi_event = new MIDIEvent();
  }
  onAction(t, r) {
    !r || r.constructor !== MIDIEvent || (r.data[0] == MIDIEvent.NOTEON || r.data[0] == MIDIEvent.NOTEOFF ? (this.midi_event = new MIDIEvent(), this.midi_event.setup(r.data), this.midi_event.data[1] = Math.round(this.midi_event.data[1] + this.properties.amount), this.trigger("out", this.midi_event)) : this.trigger("out", r));
  }
  onExecute() {
    var t = this.getInputData(1);
    t != null && (this.properties.amount = t);
  }
}
g(LGMIDITranspose, "title", "MIDI Transpose"), g(LGMIDITranspose, "desc", "Transpose a MIDI note"), g(LGMIDITranspose, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/transpose", LGMIDITranspose);
class LGMIDIQuantize {
  constructor() {
    this.properties = { scale: "A,A#,B,C,C#,D,D#,E,F,F#,G,G#" }, this.addInput("note", LiteGraph.ACTION), this.addInput("scale", "string"), this.addOutput("out", LiteGraph.EVENT), this.valid_notes = new Array(12), this.offset_notes = new Array(12), this.processScale(this.properties.scale);
  }
  onPropertyChanged(t, r) {
    t == "scale" && this.processScale(r);
  }
  processScale(t) {
    this._current_scale = t, this.notes_pitches = LGMIDIGenerator.processScale(t);
    for (let s = 0; s < 12; ++s)
      this.valid_notes[s] = this.notes_pitches.indexOf(s) != -1;
    for (let s = 0; s < 12; ++s) {
      if (this.valid_notes[s]) {
        this.offset_notes[s] = 0;
        continue;
      }
      for (var r = 1; r < 12; ++r) {
        if (this.valid_notes[(s - r) % 12]) {
          this.offset_notes[s] = -r;
          break;
        }
        if (this.valid_notes[(s + r) % 12]) {
          this.offset_notes[s] = r;
          break;
        }
      }
    }
  }
  onAction(t, r) {
    if (!(!r || r.constructor !== MIDIEvent))
      if (r.data[0] == MIDIEvent.NOTEON || r.data[0] == MIDIEvent.NOTEOFF) {
        this.midi_event = new MIDIEvent(), this.midi_event.setup(r.data);
        var s = r.note, a = MIDIEvent.note_to_index[s], o = this.offset_notes[a];
        this.midi_event.data[1] += o, this.trigger("out", this.midi_event);
      } else
        this.trigger("out", r);
  }
  onExecute() {
    var t = this.getInputData(1);
    t != null && t != this._current_scale && this.processScale(t);
  }
}
g(LGMIDIQuantize, "title", "MIDI Quantize Pitch"), g(LGMIDIQuantize, "desc", "Transpose a MIDI note tp fit an scale"), g(LGMIDIQuantize, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/quantize", LGMIDIQuantize);
class LGMIDIFromFile {
  constructor() {
    var t;
    this.properties = {
      url: "",
      autoplay: !0
    }, this.addInput("play", LiteGraph.ACTION), this.addInput("pause", LiteGraph.ACTION), this.addOutput("note", LiteGraph.EVENT), this._midi = null, this._current_time = 0, this._playing = !1, typeof MidiParser == "undefined" && ((t = console.error) == null || t.call(console, "midi-parser.js not included, LGMidiPlay requires that library: https://raw.githubusercontent.com/colxi/midi-parser-js/master/src/main.js"), this.boxcolor = "red");
  }
  onAction(t) {
    t == "play" ? this.play() : t == "pause" && (this._playing = !this._playing);
  }
  onPropertyChanged(t, r) {
    t == "url" && this.loadMIDIFile(r);
  }
  onExecute() {
    if (this._midi && this._playing) {
      this._current_time += this.graph.elapsed_time;
      for (var t = this._current_time * 100, r = 0; r < this._midi.tracks; ++r) {
        var s = this._midi.track[r];
        s._last_pos || (s._last_pos = 0, s._time = 0);
        var a = s.event[s._last_pos];
        if (a && s._time + a.deltaTime <= t && (s._last_pos++, s._time += a.deltaTime, a.data)) {
          var o = a.type << 4 + a.channel, u = new MIDIEvent();
          u.setup([o, a.data[0], a.data[1]]), this.trigger("note", u);
        }
      }
    }
  }
  play() {
    if (this._playing = !0, this._current_time = 0, !!this._midi)
      for (var t = 0; t < this._midi.tracks; ++t) {
        var r = this._midi.track[t];
        r._last_pos = 0, r._time = 0;
      }
  }
  loadMIDIFile(t) {
    LiteGraph.fetchFile(
      t,
      "arraybuffer",
      (r) => {
        this.boxcolor = "#AFA", this._midi = MidiParser.parse(new Uint8Array(r)), this.properties.autoplay && this.play();
      },
      () => {
        this.boxcolor = "#FAA", this._midi = null;
      }
    );
  }
  onDropFile(t) {
    this.properties.url = "", this.loadMIDIFile(t);
  }
}
g(LGMIDIFromFile, "title", "MIDI fromFile"), g(LGMIDIFromFile, "desc", "Plays a MIDI file"), g(LGMIDIFromFile, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/fromFile", LGMIDIFromFile);
class LGMIDIPlay {
  constructor() {
    var r;
    if (this.properties = {
      volume: 0.5,
      duration: 1
    }, this.addInput("note", LiteGraph.ACTION), this.addInput("volume", "number"), this.addInput("duration", "number"), this.addOutput("note", LiteGraph.EVENT), typeof AudioSynth == "undefined")
      (r = console.error) == null || r.call(console, "Audiosynth.js not included, LGMidiPlay requires that library"), this.boxcolor = "red";
    else {
      var t = this.synth = new AudioSynth();
      this.instrument = t.createInstrument("piano");
    }
  }
  onAction(t, r) {
    if (!(!r || r.constructor !== MIDIEvent)) {
      if (this.instrument && r.data[0] == MIDIEvent.NOTEON) {
        var s = r.note;
        if (!s || s == "undefined" || s.constructor !== String)
          return;
        this.instrument.play(
          s,
          r.octave,
          this.properties.duration,
          this.properties.volume
        );
      }
      this.trigger("note", r);
    }
  }
  onExecute() {
    var t = this.getInputData(1);
    t != null && (this.properties.volume = t);
    var r = this.getInputData(2);
    r != null && (this.properties.duration = r);
  }
}
g(LGMIDIPlay, "title", "MIDI Play"), g(LGMIDIPlay, "desc", "Plays a MIDI note"), g(LGMIDIPlay, "color", MIDI_COLOR);
LiteGraph.registerNodeType("midi/play", LGMIDIPlay);
const ae = class ae {
  constructor() {
    this.properties = {
      num_octaves: 2,
      start_octave: 2
    }, this.addInput("note", LiteGraph.ACTION), this.addInput("reset", LiteGraph.ACTION), this.addOutput("note", LiteGraph.EVENT), this.size = [400, 100], this.keys = [], this._last_key = -1;
  }
  onDrawForeground(t) {
    if (!this.flags.collapsed) {
      var r = this.properties.num_octaves * 12;
      this.keys.length = r;
      var s = this.size[0] / (this.properties.num_octaves * 7), a = this.size[1];
      t.globalAlpha = 1;
      for (var o = 0; o < 2; o++)
        for (var u = 0; u < r; ++u) {
          var h = ae.keys[u % 12];
          if (h.t == o) {
            var l = Math.floor(u / 12), c = l * 7 * s + h.x * s;
            o == 0 ? t.fillStyle = this.keys[u] ? "#CCC" : "white" : t.fillStyle = this.keys[u] ? "#333" : "black", t.fillRect(
              c + 1,
              0,
              s * h.w - 2,
              a * h.h
            );
          }
        }
    }
  }
  getKeyIndex(t) {
    for (var r = this.size[0] / (this.properties.num_octaves * 7), s = this.size[1], a = 1; a >= 0; a--)
      for (var o = 0; o < this.keys.length; ++o) {
        var u = ae.keys[o % 12];
        if (u.t == a) {
          var h = Math.floor(o / 12), l = h * 7 * r + u.x * r, c = r * u.w, d = s * u.h;
          if (!(t[0] < l || t[0] > l + c || t[1] > d))
            return o;
        }
      }
    return -1;
  }
  onAction(t, r) {
    if (t == "reset") {
      for (var s = 0; s < this.keys.length; ++s)
        this.keys[s] = !1;
      return;
    }
    if (!(!r || r.constructor !== MIDIEvent)) {
      var a = r, o = (this.properties.start_octave - 1) * 12 + 29, u = a.data[1] - o;
      u >= 0 && u < this.keys.length && (a.data[0] == MIDIEvent.NOTEON ? this.keys[u] = !0 : a.data[0] == MIDIEvent.NOTEOFF && (this.keys[u] = !1)), this.trigger("note", a);
    }
  }
  onMouseDown(t, r) {
    if (!(r[1] < 0)) {
      var s = this.getKeyIndex(r);
      this.keys[s] = !0, this._last_key = s;
      var a = (this.properties.start_octave - 1) * 12 + 29 + s, o = new MIDIEvent();
      return o.setup([MIDIEvent.NOTEON, a, 100]), this.trigger("note", o), !0;
    }
  }
  onMouseMove(t, r) {
    if (!(r[1] < 0 || this._last_key == -1)) {
      this.setDirtyCanvas(!0);
      var s = this.getKeyIndex(r);
      if (this._last_key == s)
        return !0;
      this.keys[this._last_key] = !1;
      var a = (this.properties.start_octave - 1) * 12 + 29 + this._last_key, o = new MIDIEvent();
      return o.setup([MIDIEvent.NOTEOFF, a, 100]), this.trigger("note", o), this.keys[s] = !0, a = (this.properties.start_octave - 1) * 12 + 29 + s, o = new MIDIEvent(), o.setup([MIDIEvent.NOTEON, a, 100]), this.trigger("note", o), this._last_key = s, !0;
    }
  }
  onMouseUp(t, r) {
    if (!(r[1] < 0)) {
      var s = this.getKeyIndex(r);
      this.keys[s] = !1, this._last_key = -1;
      var a = (this.properties.start_octave - 1) * 12 + 29 + s, o = new MIDIEvent();
      return o.setup([MIDIEvent.NOTEOFF, a, 100]), this.trigger("note", o), !0;
    }
  }
};
g(ae, "title", "MIDI Keys"), g(ae, "desc", "Keyboard to play notes"), g(ae, "color", MIDI_COLOR), g(ae, "keys", [
  { x: 0, w: 1, h: 1, t: 0 },
  { x: 0.75, w: 0.5, h: 0.6, t: 1 },
  { x: 1, w: 1, h: 1, t: 0 },
  { x: 1.75, w: 0.5, h: 0.6, t: 1 },
  { x: 2, w: 1, h: 1, t: 0 },
  { x: 2.75, w: 0.5, h: 0.6, t: 1 },
  { x: 3, w: 1, h: 1, t: 0 },
  { x: 4, w: 1, h: 1, t: 0 },
  { x: 4.75, w: 0.5, h: 0.6, t: 1 },
  { x: 5, w: 1, h: 1, t: 0 },
  { x: 5.75, w: 0.5, h: 0.6, t: 1 },
  { x: 6, w: 1, h: 1, t: 0 }
]);
let LGMIDIKeys = ae;
LiteGraph.registerNodeType("midi/keys", LGMIDIKeys);
const lt = class lt {
  static getAudioContext() {
    var t;
    if (!this._audio_context) {
      if (window.AudioContext = window.AudioContext || window.webkitAudioContext, !window.AudioContext)
        return (t = console.error) == null || t.call(console, "AudioContext not supported by browser"), null;
      this._audio_context = new AudioContext(), this._audio_context.onmessage = function(r) {
        var s;
        (s = console.log) == null || s.call(console, "msg", r);
      }, this._audio_context.onended = function(r) {
        var s;
        (s = console.log) == null || s.call(console, "ended", r);
      }, this._audio_context.oncomplete = function(r) {
        var s;
        (s = console.log) == null || s.call(console, "complete", r);
      };
    }
    return this._audio_context;
  }
  static connect(t, r) {
    var s;
    try {
      t.connect(r);
    } catch (a) {
      (s = console.warn) == null || s.call(console, "LGraphAudio:", a);
    }
  }
  static disconnect(t, r) {
    var s;
    try {
      t.disconnect(r);
    } catch (a) {
      (s = console.warn) == null || s.call(console, "LGraphAudio:", a);
    }
  }
  static changeAllAudiosConnections(t, r) {
    if (t.inputs)
      for (let s = 0; s < t.inputs.length; ++s) {
        let a = t.inputs[s], o = t.graph.links[a.link];
        if (!o)
          continue;
        let u = t.graph.getNodeById(o.origin_id), h = null;
        u.getAudioNodeInOutputSlot ? h = u.getAudioNodeInOutputSlot(o.origin_slot) : h = u.audionode;
        let l = null;
        t.getAudioNodeInInputSlot ? l = t.getAudioNodeInInputSlot(s) : l = t.audionode, r ? lt.connect(h, l) : lt.disconnect(h, l);
      }
    if (t.outputs)
      for (let s = 0; s < t.outputs.length; ++s) {
        let a = t.outputs[s];
        for (let o = 0; o < a.links.length; ++o) {
          let u = t.graph.links[a.links[o]];
          if (!u)
            continue;
          let h = null;
          t.getAudioNodeInOutputSlot ? h = t.getAudioNodeInOutputSlot(s) : h = t.audionode;
          let l = t.graph.getNodeById(u.target_id), c = null;
          l.getAudioNodeInInputSlot ? c = l.getAudioNodeInInputSlot(u.target_slot) : c = l.audionode, r ? lt.connect(h, c) : lt.disconnect(h, c);
        }
      }
  }
  // used by many nodes
  static onConnectionsChange(t, r, s, a) {
    if (t == LiteGraph.OUTPUT) {
      var o = null;
      if (a && (o = this.graph.getNodeById(a.target_id)), !!o) {
        var u = null;
        this.getAudioNodeInOutputSlot ? u = this.getAudioNodeInOutputSlot(r) : u = this.audionode;
        var h = null;
        o.getAudioNodeInInputSlot ? h = o.getAudioNodeInInputSlot(a.target_slot) : h = o.audionode, s ? lt.connect(u, h) : lt.disconnect(u, h);
      }
    }
  }
  // this function helps creating wrappers to existing classes
  static createAudioNodeWrapper(t) {
    var r = t.prototype.onPropertyChanged;
    t.prototype.onPropertyChanged = function(s, a) {
      r && r.call(this, s, a), this.audionode && this.audionode[s] !== void 0 && (this.audionode[s].value !== void 0 ? this.audionode[s].value = a : this.audionode[s] = a);
    }, t.prototype.onConnectionsChange = lt.onConnectionsChange;
  }
  static loadSound(t, r, s) {
    if (lt.cached_audios[t] && t.includes("blob:")) {
      r && r(lt.cached_audios[t]);
      return;
    }
    lt.onProcessAudioURL && (t = lt.onProcessAudioURL(t));
    var a = new XMLHttpRequest();
    a.open("GET", t, !0), a.responseType = "arraybuffer";
    var o = lt.getAudioContext();
    a.onload = function() {
      var h;
      (h = console.log) == null || h.call(console, "AudioSource loaded"), o.decodeAudioData(
        a.response,
        function(l) {
          var c;
          (c = console.log) == null || c.call(console, "AudioSource decoded"), lt.cached_audios[t] = l, r && r(l);
        },
        u
      );
    }, a.send();
    function u(h) {
      var l;
      (l = console.log) == null || l.call(console, "Audio loading sample error:", h), s && s(h);
    }
    return a;
  }
};
// contains the samples decoded of the loaded audios in AudioBuffer format
g(lt, "cached_audios", {});
let LGAudio = lt;
class LGAudioSource {
  constructor() {
    this.properties = {
      src: "",
      gain: 0.5,
      loop: !0,
      autoplay: !0,
      playbackRate: 1
    }, this._loading_audio = !1, this._audiobuffer = null, this._audionodes = [], this._last_sourcenode = null, this.addOutput("out", "audio"), this.addInput("gain", "number");
    var t = LGAudio.getAudioContext();
    this.audionode = t.createGain(), this.audionode.graphnode = this, this.audionode.gain.value = this.properties.gain, this.properties.src && this.loadSound(this.properties.src);
  }
  onAdded(t) {
    t.status === LiteGraph.LGraph.STATUS_RUNNING && this.onStart();
  }
  onStart() {
    this._audiobuffer && this.properties.autoplay && this.playBuffer(this._audiobuffer);
  }
  onStop() {
    this.stopAllSounds();
  }
  onPause() {
    this.pauseAllSounds();
  }
  onUnpause() {
    this.unpauseAllSounds();
  }
  onRemoved() {
    this.stopAllSounds(), this._dropped_url && URL.revokeObjectURL(this._url);
  }
  stopAllSounds() {
    for (var t = 0; t < this._audionodes.length; ++t)
      this._audionodes[t].started && (this._audionodes[t].started = !1, this._audionodes[t].stop());
    this._audionodes.length = 0;
  }
  pauseAllSounds() {
    LGAudio.getAudioContext().suspend();
  }
  unpauseAllSounds() {
    LGAudio.getAudioContext().resume();
  }
  onExecute() {
    if (this.inputs)
      for (let t = 0; t < this.inputs.length; ++t) {
        let r = this.inputs[t];
        if (r.link == null)
          continue;
        let s = this.getInputData(t);
        if (s !== void 0) {
          if (r.name == "gain") this.audionode.gain.value = s;
          else if (r.name == "src")
            this.setProperty("src", s);
          else if (r.name == "playbackRate") {
            this.properties.playbackRate = s;
            for (let a = 0; a < this._audionodes.length; ++a)
              this._audionodes[a].playbackRate.value = s;
          }
        }
      }
    if (this.outputs)
      for (let t = 0; t < this.outputs.length; ++t)
        this.outputs[t].name == "buffer" && this._audiobuffer && this.setOutputData(t, this._audiobuffer);
  }
  onAction(t) {
    this._audiobuffer && (t == "Play" ? this.playBuffer(this._audiobuffer) : t == "Stop" && this.stopAllSounds());
  }
  onPropertyChanged(t, r) {
    if (t == "src")
      this.loadSound(r);
    else if (t == "gain")
      this.audionode.gain.value = r;
    else if (t == "playbackRate")
      for (var s = 0; s < this._audionodes.length; ++s)
        this._audionodes[s].playbackRate.value = r;
  }
  playBuffer(t) {
    var r = this, s = LGAudio.getAudioContext(), a = s.createBufferSource();
    return this._last_sourcenode = a, a.graphnode = this, a.buffer = t, a.loop = this.properties.loop, a.playbackRate.value = this.properties.playbackRate, this._audionodes.push(a), a.connect(this.audionode), this._audionodes.push(a), this.trigger("start"), a.onended = function() {
      r.trigger("ended");
      var o = r._audionodes.indexOf(a);
      o != -1 && r._audionodes.splice(o, 1);
    }, a.started || (a.started = !0, a.start()), a;
  }
  loadSound(t) {
    var r = this;
    this._request && (this._request.abort(), this._request = null), this._audiobuffer = null, this._loading_audio = !1, t && (this._request = LGAudio.loadSound(t, (s) => {
      this.boxcolor = LiteGraph.NODE_DEFAULT_BOXCOLOR, r._audiobuffer = s, r._loading_audio = !1, r.graph && r.graph.status === LiteGraph.LGraph.STATUS_RUNNING && r.onStart();
    }), this._loading_audio = !0, this.boxcolor = "#AA4");
  }
  onGetInputs() {
    return [
      ["playbackRate", "number"],
      ["src", "string"],
      ["Play", LiteGraph.ACTION],
      ["Stop", LiteGraph.ACTION]
    ];
  }
  onGetOutputs() {
    return [
      ["buffer", "audiobuffer"],
      ["start", LiteGraph.EVENT],
      ["ended", LiteGraph.EVENT]
    ];
  }
  onDropFile(t) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    var r = URL.createObjectURL(t);
    this.properties.src = r, this.loadSound(r), this._dropped_url = r;
  }
}
g(LGAudioSource, "title", "Source"), g(LGAudioSource, "desc", "Plays an audio file"), g(LGAudioSource, "supported_extensions", ["wav", "ogg", "mp3"]), g(LGAudioSource, "@src", { widget: "resource" });
LGAudioSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;
LiteGraph.registerNodeType("audio/source", LGAudioSource);
class LGAudioMediaSource {
  constructor() {
    this.properties = { gain: 0.5 }, this._audionodes = [], this._media_stream = null, this.addOutput("out", "audio"), this.addInput("gain", "number");
    var t = LGAudio.getAudioContext();
    this.audionode = t.createGain(), this.audionode.graphnode = this, this.audionode.gain.value = this.properties.gain;
  }
  onAdded(t) {
    t.status === LiteGraph.LGraph.STATUS_RUNNING && this.onStart();
  }
  onStart() {
    this._media_stream == null && !this._waiting_confirmation && this.openStream();
  }
  onStop() {
    this.audionode.gain.value = 0;
  }
  onPause() {
    this.audionode.gain.value = 0;
  }
  onUnpause() {
    this.audionode.gain.value = this.properties.gain;
  }
  onRemoved() {
    if (this.audionode.gain.value = 0, this.audiosource_node && (this.audiosource_node.disconnect(this.audionode), this.audiosource_node = null), this._media_stream) {
      var t = this._media_stream.getTracks();
      t.length && t[0].stop();
    }
  }
  openStream() {
    var s;
    if (!navigator.mediaDevices) {
      (s = console.log) == null || s.call(console, "getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
      return;
    }
    this._waiting_confirmation = !0, navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }).then(this.streamReady.bind(this)).catch(r);
    var t = this;
    function r(a) {
      var o;
      (o = console.log) == null || o.call(console, "Media rejected", a), t._media_stream = !1, t.boxcolor = "red";
    }
  }
  streamReady(t) {
    this._media_stream = t, this.audiosource_node && this.audiosource_node.disconnect(this.audionode);
    var r = LGAudio.getAudioContext();
    this.audiosource_node = r.createMediaStreamSource(t), this.audiosource_node.graphnode = this, this.audiosource_node.connect(this.audionode), this.boxcolor = "white";
  }
  onExecute() {
    if (this._media_stream == null && !this._waiting_confirmation && this.openStream(), this.inputs)
      for (var t = 0; t < this.inputs.length; ++t) {
        var r = this.inputs[t];
        if (r.link != null) {
          var s = this.getInputData(t);
          s !== void 0 && r.name == "gain" && (this.audionode.gain.value = this.properties.gain = s);
        }
      }
  }
  onAction(t) {
    t == "Play" ? this.audionode.gain.value = this.properties.gain : t == "Stop" && (this.audionode.gain.value = 0);
  }
  onPropertyChanged(t, r) {
    t == "gain" && (this.audionode.gain.value = r);
  }
  onGetInputs() {
    return [
      ["playbackRate", "number"],
      ["Play", LiteGraph.ACTION],
      ["Stop", LiteGraph.ACTION]
    ];
  }
}
g(LGAudioMediaSource, "title", "MediaSource"), g(LGAudioMediaSource, "desc", "Plays microphone");
LGAudioMediaSource.prototype.onConnectionsChange = LGAudio.onConnectionsChange;
LiteGraph.registerNodeType("audio/media_source", LGAudioMediaSource);
class LGAudioAnalyser {
  constructor() {
    this.properties = {
      fftSize: 2048,
      minDecibels: -100,
      maxDecibels: -10,
      smoothingTimeConstant: 0.5
    };
    var t = LGAudio.getAudioContext();
    this.audionode = t.createAnalyser(), this.audionode.graphnode = this, this.audionode.fftSize = this.properties.fftSize, this.audionode.minDecibels = this.properties.minDecibels, this.audionode.maxDecibels = this.properties.maxDecibels, this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant, this.addInput("in", "audio"), this.addOutput("freqs", "array"), this.addOutput("samples", "array"), this._freq_bin = null, this._time_bin = null;
  }
  onPropertyChanged(t, r) {
    this.audionode[t] = r;
  }
  onExecute() {
    let t;
    this.isOutputConnected(0) && (t = this.audionode.frequencyBinCount, (!this._freq_bin || this._freq_bin.length != t) && (this._freq_bin = new Uint8Array(t)), this.audionode.getByteFrequencyData(this._freq_bin), this.setOutputData(0, this._freq_bin)), this.isOutputConnected(1) && (t = this.audionode.frequencyBinCount, (!this._time_bin || this._time_bin.length != t) && (this._time_bin = new Uint8Array(t)), this.audionode.getByteTimeDomainData(this._time_bin), this.setOutputData(1, this._time_bin));
    for (var r = 1; r < this.inputs.length; ++r) {
      var s = this.inputs[r];
      if (s.link != null) {
        var a = this.getInputData(r);
        a !== void 0 && (this.audionode[s.name].value = a);
      }
    }
  }
  onGetInputs() {
    return [
      ["minDecibels", "number"],
      ["maxDecibels", "number"],
      ["smoothingTimeConstant", "number"]
    ];
  }
  onGetOutputs() {
    return [
      ["freqs", "array"],
      ["samples", "array"]
    ];
  }
}
g(LGAudioAnalyser, "title", "Analyser"), g(LGAudioAnalyser, "desc", "Audio Analyser");
LiteGraph.registerNodeType("audio/analyser", LGAudioAnalyser);
class LGAudioGain {
  constructor() {
    this.properties = { gain: 1 }, this.audionode = LGAudio.getAudioContext().createGain(), this.addInput("in", "audio"), this.addInput("gain", "number"), this.addOutput("out", "audio");
  }
  onExecute() {
    if (!(!this.inputs || !this.inputs.length))
      for (var t = 1; t < this.inputs.length; ++t) {
        var r = this.inputs[t], s = this.getInputData(t);
        s !== void 0 && (this.audionode[r.name].value = s);
      }
  }
}
g(LGAudioGain, "title", "Gain"), g(LGAudioGain, "desc", "Audio gain");
LGAudio.createAudioNodeWrapper(LGAudioGain);
LiteGraph.registerNodeType("audio/gain", LGAudioGain);
class LGAudioConvolver {
  constructor() {
    this.properties = {
      impulse_src: "",
      normalize: !0
    }, this.audionode = LGAudio.getAudioContext().createConvolver(), this.addInput("in", "audio"), this.addOutput("out", "audio");
  }
  onRemove() {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
  }
  onPropertyChanged(t, r) {
    t == "impulse_src" ? this.loadImpulse(r) : t == "normalize" && (this.audionode.normalize = r);
  }
  onDropFile(t) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url), this._dropped_url = URL.createObjectURL(t), this.properties.impulse_src = this._dropped_url, this.loadImpulse(this._dropped_url);
  }
  loadImpulse(t) {
    var r = this;
    if (this._request && (this._request.abort(), this._request = null), this._impulse_buffer = null, this._loading_impulse = !1, !t)
      return;
    this._request = LGAudio.loadSound(t, s), this._loading_impulse = !0;
    function s(a) {
      var o;
      r._impulse_buffer = a, r.audionode.buffer = a, (o = console.log) == null || o.call(console, "Impulse signal set"), r._loading_impulse = !1;
    }
  }
}
g(LGAudioConvolver, "title", "Convolver"), g(LGAudioConvolver, "desc", "Convolves the signal (used for reverb)");
LGAudio.createAudioNodeWrapper(LGAudioConvolver);
LiteGraph.registerNodeType("audio/convolver", LGAudioConvolver);
class LGAudioDynamicsCompressor {
  constructor() {
    this.properties = {
      threshold: -50,
      knee: 40,
      ratio: 12,
      reduction: -20,
      attack: 0,
      release: 0.25
    }, this.audionode = LGAudio.getAudioContext().createDynamicsCompressor(), this.addInput("in", "audio"), this.addOutput("out", "audio");
  }
  onExecute() {
    if (!(!this.inputs || !this.inputs.length))
      for (var t = 1; t < this.inputs.length; ++t) {
        var r = this.inputs[t];
        if (r.link != null) {
          var s = this.getInputData(t);
          s !== void 0 && (this.audionode[r.name].value = s);
        }
      }
  }
  onGetInputs() {
    return [
      ["threshold", "number"],
      ["knee", "number"],
      ["ratio", "number"],
      ["reduction", "number"],
      ["attack", "number"],
      ["release", "number"]
    ];
  }
}
g(LGAudioDynamicsCompressor, "title", "DynamicsCompressor"), g(LGAudioDynamicsCompressor, "desc", "Dynamics Compressor");
LGAudio.createAudioNodeWrapper(LGAudioDynamicsCompressor);
LiteGraph.registerNodeType("audio/dynamicsCompressor", LGAudioDynamicsCompressor);
class LGAudioWaveShaper {
  constructor() {
    this.properties = {}, this.audionode = LGAudio.getAudioContext().createWaveShaper(), this.addInput("in", "audio"), this.addInput("shape", "waveshape"), this.addOutput("out", "audio");
  }
  onExecute() {
    if (!(!this.inputs || !this.inputs.length)) {
      var t = this.getInputData(1);
      t !== void 0 && (this.audionode.curve = t);
    }
  }
  setWaveShape(t) {
    this.audionode.curve = t;
  }
}
g(LGAudioWaveShaper, "title", "WaveShaper"), g(LGAudioWaveShaper, "desc", "Distortion using wave shape");
LGAudio.createAudioNodeWrapper(LGAudioWaveShaper);
class LGAudioMixer {
  constructor() {
    this.properties = {
      gain1: 0.5,
      gain2: 0.5
    }, this.audionode = LGAudio.getAudioContext().createGain(), this.audionode1 = LGAudio.getAudioContext().createGain(), this.audionode1.gain.value = this.properties.gain1, this.audionode2 = LGAudio.getAudioContext().createGain(), this.audionode2.gain.value = this.properties.gain2, this.audionode1.connect(this.audionode), this.audionode2.connect(this.audionode), this.addInput("in1", "audio"), this.addInput("in1 gain", "number"), this.addInput("in2", "audio"), this.addInput("in2 gain", "number"), this.addOutput("out", "audio");
  }
  getAudioNodeInInputSlot(t) {
    if (t == 0)
      return this.audionode1;
    if (t == 2)
      return this.audionode2;
  }
  onPropertyChanged(t, r) {
    t == "gain1" ? this.audionode1.gain.value = r : t == "gain2" && (this.audionode2.gain.value = r);
  }
  onExecute() {
    if (!(!this.inputs || !this.inputs.length))
      for (var t = 1; t < this.inputs.length; ++t) {
        var r = this.inputs[t];
        if (!(r.link == null || r.type == "audio")) {
          var s = this.getInputData(t);
          s !== void 0 && (t == 1 ? this.audionode1.gain.value = s : t == 3 && (this.audionode2.gain.value = s));
        }
      }
  }
}
g(LGAudioMixer, "title", "Mixer"), g(LGAudioMixer, "desc", "Audio mixer");
LGAudio.createAudioNodeWrapper(LGAudioMixer);
LiteGraph.registerNodeType("audio/mixer", LGAudioMixer);
class LGAudioADSR {
  constructor() {
    this.properties = {
      A: 0.1,
      D: 0.1,
      S: 0.1,
      R: 0.1
    }, this.audionode = LGAudio.getAudioContext().createGain(), this.audionode.gain.value = 0, this.addInput("in", "audio"), this.addInput("gate", "boolean"), this.addOutput("out", "audio"), this.gate = !1;
  }
  onExecute() {
    var t = LGAudio.getAudioContext(), r = t.currentTime, s = this.audionode, a = s.gain, o = this.getInputData(1), u = this.getInputOrProperty("A"), h = this.getInputOrProperty("D"), l = this.getInputOrProperty("S"), c = this.getInputOrProperty("R");
    !this.gate && o ? (a.cancelScheduledValues(0), a.setValueAtTime(0, r), a.linearRampToValueAtTime(1, r + u), a.linearRampToValueAtTime(l, r + u + h)) : this.gate && !o && (a.cancelScheduledValues(0), a.setValueAtTime(a.value, r), a.linearRampToValueAtTime(0, r + c)), this.gate = o;
  }
  onGetInputs() {
    return [
      ["A", "number"],
      ["D", "number"],
      ["S", "number"],
      ["R", "number"]
    ];
  }
}
g(LGAudioADSR, "title", "ADSR"), g(LGAudioADSR, "desc", "Audio envelope");
LGAudio.createAudioNodeWrapper(LGAudioADSR);
LiteGraph.registerNodeType("audio/adsr", LGAudioADSR);
class LGAudioDelay {
  constructor() {
    this.properties = { delayTime: 0.5 }, this.audionode = LGAudio.getAudioContext().createDelay(10), this.audionode.delayTime.value = this.properties.delayTime, this.addInput("in", "audio"), this.addInput("time", "number"), this.addOutput("out", "audio");
  }
  onExecute() {
    var t = this.getInputData(1);
    t !== void 0 && (this.audionode.delayTime.value = t);
  }
}
g(LGAudioDelay, "title", "Delay"), g(LGAudioDelay, "desc", "Audio delay");
LGAudio.createAudioNodeWrapper(LGAudioDelay);
LiteGraph.registerNodeType("audio/delay", LGAudioDelay);
class LGAudioBiquadFilter {
  constructor() {
    this.properties = {
      frequency: 350,
      detune: 0,
      Q: 1
    }, this.addProperty("type", "lowpass", "enum", {
      values: [
        "lowpass",
        "highpass",
        "bandpass",
        "lowshelf",
        "highshelf",
        "peaking",
        "notch",
        "allpass"
      ]
    }), this.audionode = LGAudio.getAudioContext().createBiquadFilter(), this.addInput("in", "audio"), this.addOutput("out", "audio");
  }
  onExecute() {
    if (!(!this.inputs || !this.inputs.length))
      for (var t = 1; t < this.inputs.length; ++t) {
        var r = this.inputs[t];
        if (r.link != null) {
          var s = this.getInputData(t);
          s !== void 0 && (this.audionode[r.name].value = s);
        }
      }
  }
  onGetInputs() {
    return [
      ["frequency", "number"],
      ["detune", "number"],
      ["Q", "number"]
    ];
  }
}
g(LGAudioBiquadFilter, "title", "BiquadFilter"), g(LGAudioBiquadFilter, "desc", "Audio filter");
LGAudio.createAudioNodeWrapper(LGAudioBiquadFilter);
LiteGraph.registerNodeType("audio/biquadfilter", LGAudioBiquadFilter);
class LGAudioOscillatorNode {
  constructor() {
    this.properties = {
      frequency: 440,
      detune: 0,
      type: "sine"
    }, this.addProperty(
      "type",
      "sine",
      "enum",
      {
        values: [
          "sine",
          "square",
          "sawtooth",
          "triangle",
          "custom"
        ]
      }
    ), this.audionode = LGAudio.getAudioContext().createOscillator(), this.addOutput("out", "audio");
  }
  onStart() {
    var t;
    if (!this.audionode.started) {
      this.audionode.started = !0;
      try {
        this.audionode.start();
      } catch (r) {
        (t = console.warn) == null || t.call(console, r);
      }
    }
  }
  onStop() {
    this.audionode.started && (this.audionode.started = !1, this.audionode.stop());
  }
  onPause() {
    this.onStop();
  }
  onUnpause() {
    this.onStart();
  }
  onExecute() {
    if (!(!this.inputs || !this.inputs.length))
      for (var t = 0; t < this.inputs.length; ++t) {
        var r = this.inputs[t];
        if (r.link != null) {
          var s = this.getInputData(t);
          s !== void 0 && (this.audionode[r.name].value = s);
        }
      }
  }
  onGetInputs() {
    return [
      ["frequency", "number"],
      ["detune", "number"],
      ["type", "string"]
    ];
  }
}
g(LGAudioOscillatorNode, "title", "Oscillator"), g(LGAudioOscillatorNode, "desc", "Oscillator");
LGAudio.createAudioNodeWrapper(LGAudioOscillatorNode);
LiteGraph.registerNodeType("audio/oscillator", LGAudioOscillatorNode);
class LGAudioVisualization {
  constructor() {
    this.properties = {
      continuous: !0,
      mark: -1
    }, this.addInput("data", "array"), this.addInput("mark", "number"), this.size = [300, 200], this._last_buffer = null;
  }
  onExecute() {
    this._last_buffer = this.getInputData(0);
    var t = this.getInputData(1);
    t !== void 0 && (this.properties.mark = t), this.setDirtyCanvas(!0, !1);
  }
  onDrawForeground(t) {
    if (this._last_buffer) {
      var r = this._last_buffer, s = r.length / this.size[0], a = this.size[1];
      t.fillStyle = "black", t.fillRect(0, 0, this.size[0], this.size[1]), t.strokeStyle = "white", t.beginPath();
      var o = 0;
      if (this.properties.continuous) {
        t.moveTo(o, a);
        for (let l = 0; l < r.length; l += s)
          t.lineTo(o, a - r[l | 0] / 255 * a), o++;
      } else
        for (let l = 0; l < r.length; l += s)
          t.moveTo(o + 0.5, a), t.lineTo(o + 0.5, a - r[l | 0] / 255 * a), o++;
      if (t.stroke(), this.properties.mark >= 0) {
        var u = LGAudio.getAudioContext().sampleRate, h = u / r.length;
        o = 2 * (this.properties.mark / h) / s, o >= this.size[0] && (o = this.size[0] - 1), t.strokeStyle = "red", t.beginPath(), t.moveTo(o, a), t.lineTo(o, 0), t.stroke();
      }
    }
  }
}
g(LGAudioVisualization, "title", "Visualization"), g(LGAudioVisualization, "desc", "Audio Visualization");
LiteGraph.registerNodeType("audio/visualization", LGAudioVisualization);
class LGAudioBandSignal {
  constructor() {
    this.properties = {
      band: 440,
      amplitude: 1
    }, this.addInput("freqs", "array"), this.addOutput("signal", "number");
  }
  onExecute() {
    if (this._freqs = this.getInputData(0), !!this._freqs) {
      var t = this.properties.band, r = this.getInputData(1);
      r !== void 0 && (t = r);
      var s = LGAudio.getAudioContext().sampleRate, a = s / this._freqs.length, o = 2 * (t / a);
      if (r = 0, o < 0 && (r = this._freqs[0]), o >= this._freqs.length)
        r = this._freqs[this._freqs.length - 1];
      else {
        var u = o | 0, h = this._freqs[u], l = this._freqs[u + 1], c = o - u;
        r = h * (1 - c) + l * c;
      }
      this.setOutputData(0, r / 255 * this.properties.amplitude);
    }
  }
  onGetInputs() {
    return [["band", "number"]];
  }
}
g(LGAudioBandSignal, "title", "Signal"), g(LGAudioBandSignal, "desc", "extract the signal of some frequency");
LiteGraph.registerNodeType("audio/signal", LGAudioBandSignal);
const vt = class vt {
  constructor() {
    g(this, "@code", { widget: "code", type: "code" });
    var o;
    if (!vt.default_code) {
      var t = vt.default_function.toString(), r = t.indexOf("{") + 1, s = t.lastIndexOf("}");
      vt.default_code = t.substr(r, s - r);
    }
    this.properties = { code: vt.default_code };
    var a = LGAudio.getAudioContext();
    a.createScriptProcessor ? this.audionode = a.createScriptProcessor(4096, 1, 1) : ((o = console.warn) == null || o.call(console, "ScriptProcessorNode deprecated"), this.audionode = a.createGain()), this.processCode(), vt._bypass_function || (vt._bypass_function = this.audionode.onaudioprocess), this.addInput("in", "audio"), this.addOutput("out", "audio");
  }
  onAdded(t) {
    t.status == LiteGraph.LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback);
  }
  onStart() {
    this.audionode.onaudioprocess = this._callback;
  }
  onStop() {
    this.audionode.onaudioprocess = vt._bypass_function;
  }
  onPause() {
    this.audionode.onaudioprocess = vt._bypass_function;
  }
  onUnpause() {
    this.audionode.onaudioprocess = this._callback;
  }
  onExecute() {
  }
  onRemoved() {
    this.audionode.onaudioprocess = vt._bypass_function;
  }
  processCode() {
    var r;
    try {
      var t = new Function("properties", this.properties.code);
      this._script = new t(this.properties), this._old_code = this.properties.code, this._callback = this._script.onaudioprocess;
    } catch (s) {
      (r = console.error) == null || r.call(console, "Error in onaudioprocess code", s), this._callback = vt._bypass_function, this.audionode.onaudioprocess = this._callback;
    }
  }
  onPropertyChanged(t, r) {
    t == "code" && (this.properties.code = r, this.processCode(), this.graph && this.graph.status == LiteGraph.LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback));
  }
  static default_function() {
    this.onaudioprocess = function(t) {
      for (var r = t.inputBuffer, s = t.outputBuffer, a = 0; a < s.numberOfChannels; a++)
        for (var o = r.getChannelData(a), u = s.getChannelData(a), h = 0; h < r.length; h++)
          u[h] = o[h];
    };
  }
};
g(vt, "title", "Script"), g(vt, "desc", "apply script to signal");
let LGAudioScript = vt;
LGAudio.createAudioNodeWrapper(LGAudioScript);
LiteGraph.registerNodeType("audio/script", LGAudioScript);
class LGAudioDestination {
  constructor() {
    this.audionode = LGAudio.getAudioContext().destination, this.addInput("in", "audio");
  }
}
g(LGAudioDestination, "title", "Destination"), g(LGAudioDestination, "desc", "Audio output");
LiteGraph.registerNodeType("audio/destination", LGAudioDestination);
class LGWebSocket {
  constructor() {
    this.size = [60, 20], this.addInput("send", LiteGraph.ACTION), this.addOutput("received", LiteGraph.EVENT), this.addInput("in", 0), this.addOutput("out", 0), this.properties = {
      url: "",
      room: "lgraph",
      // allows to filter messages,
      only_send_changes: !0
    }, this._ws = null, this._last_sent_data = [], this._last_received_data = [];
  }
  onPropertyChanged(t, r) {
    t == "url" && this.connectSocket();
  }
  onExecute() {
    if (!this._ws && this.properties.url && this.connectSocket(), !(!this._ws || this._ws.readyState != WebSocket.OPEN)) {
      var t = this.properties.room, r = this.properties.only_send_changes;
      for (let o = 1; o < this.inputs.length; ++o) {
        var s = this.getInputData(o);
        if (s != null) {
          var a;
          try {
            a = JSON.stringify({
              type: 0,
              room: t,
              channel: o,
              data: s
            });
          } catch {
            continue;
          }
          r && this._last_sent_data[o] == a || (this._last_sent_data[o] = a, this._ws.send(a));
        }
      }
      for (let o = 1; o < this.outputs.length; ++o)
        this.setOutputData(o, this._last_received_data[o]);
      this.boxcolor == "#AFA" && (this.boxcolor = "#6C6");
    }
  }
  connectSocket() {
    var t = this, r = this.properties.url;
    r.substr(0, 2) != "ws" && (r = "ws://" + r), this._ws = new WebSocket(r), this._ws.onopen = function() {
      var s;
      (s = console.log) == null || s.call(console, "ready"), t.boxcolor = "#6C6";
    }, this._ws.onmessage = function(s) {
      t.boxcolor = "#AFA";
      var a = JSON.parse(s.data);
      if (!(a.room && a.room != t.properties.room))
        if (a.type == 1)
          if (a.data.object_class && LiteGraph[a.data.object_class]) {
            var o = null;
            try {
              o = new LiteGraph[a.data.object_class](a.data), t.triggerSlot(0, o);
            } catch {
              return;
            }
          } else
            t.triggerSlot(0, a.data);
        else
          t._last_received_data[a.channel || 0] = a.data;
    }, this._ws.onerror = function(s) {
      var a;
      (a = console.log) == null || a.call(console, "couldnt connect to websocket"), t.boxcolor = "#E88";
    }, this._ws.onclose = function(s) {
      var a;
      (a = console.log) == null || a.call(console, "connection closed"), t.boxcolor = "#000";
    };
  }
  send(t) {
    !this._ws || this._ws.readyState != WebSocket.OPEN || this._ws.send(JSON.stringify({ type: 1, msg: t }));
  }
  onAction(t, r) {
    !this._ws || this._ws.readyState != WebSocket.OPEN || this._ws.send({
      type: 1,
      room: this.properties.room,
      action: t,
      data: r
    });
  }
  onGetInputs() {
    return [["in", 0]];
  }
  onGetOutputs() {
    return [["out", 0]];
  }
}
g(LGWebSocket, "title", "WebSocket"), g(LGWebSocket, "desc", "Send data through a websocket");
LiteGraph.registerNodeType("network/websocket", LGWebSocket);
class HTTPRequestNode {
  constructor() {
    this.addInput("request", LiteGraph.ACTION), this.addInput("url", "string"), this.addProperty("url", ""), this.addOutput("ready", LiteGraph.EVENT), this.addOutput("data", "string"), this.addWidget("button", "Fetch", null, this.fetch.bind(this)), this._data = null, this._fetching = null;
  }
  fetch() {
    var t = this.getInputOrProperty("url");
    if (t) {
      this.boxcolor = "#FF0";
      var r = this;
      this._fetching = fetch(t).then((s) => {
        if (!s.ok)
          this.boxcolor = "#F00", r.trigger("error");
        else
          return this.boxcolor = "#0F0", s.text();
      }).then((s) => {
        r._data = s, r._fetching = null, r.trigger("ready");
      });
    }
  }
  onAction(t) {
    t == "request" && this.fetch();
  }
  onExecute() {
    this.setOutputData(1, this._data);
  }
  onGetOutputs() {
    return [["error", LiteGraph.EVENT]];
  }
}
g(HTTPRequestNode, "title", "HTTP Request"), g(HTTPRequestNode, "desc", "Fetch data through HTTP");
LiteGraph.registerNodeType("network/httprequest", HTTPRequestNode);
export {
  ContextMenu,
  DragAndScale,
  LGraph,
  LGraphCanvas,
  LGraphGroup,
  LGraphNode,
  LLink,
  LiteGraph
};
